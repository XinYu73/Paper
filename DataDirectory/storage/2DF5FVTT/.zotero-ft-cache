Building efficient parallel applications
Milan Curcic
Foreword by Damian Rouson
MANNING

The main program is the fundamental Fortran unit. It is the only unit that can be invoked as an executable from the operating system.

program foo
implicit none integer :: a, b, n real :: x
n = 1, 10 do n = 1, 10
call add(a, n) end do
end program foo

The main program can declare data, have executable code, as well as invoke other units, such as functions and subroutines.

Like programs, functions can also declare data and have executable code. Unlike programs, they can only be invoked in expressions; for example, total = 2 * sum(3, 5).

function sum(a, b) integer, intent(in) :: a, b integer :: sum sum = a + b
end function sum

Subroutines receive input arguments, modify them in-place, and return any number of output arguments. Subroutines can only be invoked with a call statement; for example, call add(a, 3).

subroutine add(a, b)
integer, intent(in out) :: a integer, intent(in) :: b
a = a + b print ∗, ‘a = ‘, a

end subroutine add

An overview of a Fortran program, function, and subroutine

Functions can take any number of input arguments, but always return only one result.
Use functions for side effect-free calculations.
The intent attribute determines whether an input argument can be modiﬁed in-place (in out) or not (i.n)
Use subroutines when you need to modify input arguments in place, or write data to screen or external ﬁles.

Modern Fortran
BUILDING EFFICIENT PARALLEL APPLICATIONS
MILAN CURCIC
FOREWORD BY DAMIAN ROUSON
MANNING
SHELTER ISLAND

For online information and ordering of this and other Manning books, please visit www.manning.com. The publisher offers discounts on this book when ordered in quantity. For more information, please contact
Special Sales Department Manning Publications Co. 20 Baldwin Road PO Box 761 Shelter Island, NY 11964 Email: orders@manning.com
©2020 by Manning Publications Co. All rights reserved.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in the book, and Manning Publications was aware of a trademark claim, the designations have been printed in initial caps or all caps.
Recognizing the importance of preserving what has been written, it is Manning’s policy to have the books we publish printed on acid-free paper, and we exert our best efforts to that end. Recognizing also our responsibility to conserve the resources of our planet, Manning books are printed on paper that is at least 15 percent recycled and processed without the use of elemental chlorine.

Manning Publications Co. 20 Baldwin Road PO Box 761 Shelter Island, NY 11964

Development editor: Lesley Trites Technical development editor: Michiel Trimpe
Review editor: Aleksandar Dragosavljevic´ Production editor: Lori Weidert
Copy editor: Frances Buran Proofreader: Melody Dolab Technical proofreader: Maurizio Tomasi
Typesetter: Dennis Dalinnik Cover designer: Marija Tudor

ISBN: 9781617295287 Printed in the United States of America

contents
foreword xi preface xiii acknowledgments xiv about this book xvi about the author xxii about the cover illustration xxiii
PART 1 GETTING STARTED WITH MODERN FORTRAN........1
1 Introducing Fortran 3 1.1 What is Fortran? 4 1.2 Fortran features 6 1.3 Why learn Fortran? 8 1.4 Advantages and disadvantages 10 Side-by-side comparison with Python 10 1.5 Parallel Fortran, illustrated 12 1.6 What will you learn in this book? 13 1.7 Think parallel! 14 Copying an array from one processor to another 17
iii

iv

CONTENTS

1.8 Running example: A parallel tsunami simulator 22
Why tsunami simulator? 22 ■ Shallow water equations 23 What we want our app to do 24
1.9 Further reading 25
2 Getting started: Minimal working app 26 2.1 Compiling and running your first program 27 2.2 Simulating the motion of an object 28 What should our app do? 29 ■ What is advection? 30
2.3 Implementing the minimal working app 31
Implementation strategy 32 ■ Defining the main program 33 Declaring and initializing variables 34 ■ Numeric data types 35 Declaring the data to use in our app 37 ■ Branching with an if block 40 ■ Using a do loop to iterate 42 ■ Setting the initial water height values 44 ■ Predicting the movement of the object 45 ■ Printing results to the screen 47 ■ Putting it all together 47
2.4 Going forward with the tsunami simulator 51 2.5 Answer key 52
Exercise: Cold front propagation 52
2.6 New Fortran elements, at a glance 52 2.7 Further reading 52

PART 2 CORE ELEMENTS OF FORTRAN ...........................55
3 Writing reusable code with functions and subroutines 57 3.1 Toward higher app complexity 58 Refactoring the tsunami simulator 58 ■ Revisiting the cold front problem 61 ■ An overview of Fortran program units 63
3.2 Don’t repeat yourself, use procedures 65
Your first function 65 ■ Expressing finite difference as a function in the tsunami simulator 70
3.3 Modifying program state with subroutines 72
Defining and calling a subroutine 72 ■ When do you use a subroutine over a function? 74 ■ Initializing water height in the tsunami simulator 75

CONTENTS

v

3.4 Writing pure procedures to avoid side effects 76
What is a pure procedure? 76 ■ Some restrictions on pure procedures 77 ■ Why are pure functions important? 77
3.5 Writing procedures that operate on both scalars and arrays 77
3.6 Procedures with optional arguments 79 3.7 Tsunami simulator: Putting it all together 81 3.8 Answer key 82
Exercise 1: Modifying state with a subroutine 82 ■ Exercise 2: Writing an elemental function that operates on both scalars and arrays 83
3.9 New Fortran elements, at a glance 83 3.10 Further reading 84
4 Organizing your Fortran code using modules 85 4.1 Accessing a module 86 Getting compiler version and options 86 ■ Using portable data types 89
4.2 Creating your first module 91
The structure of a custom module 92 ■ Defining a module 93 Compiling Fortran modules 95 ■ Controlling access to variables and procedures 97 ■ Putting it all together in the tsunami simulator 98
4.3 Toward realistic wave simulations 99
A brief look at the physics 101 ■ Updating the finite difference calculation 102 ■ Renaming imported entities to avoid name conflict 104 ■ The complete code 105
4.4 Answer key 107
Exercise 1: Using portable type kinds in the tsunami simulator 107 Exercise 2: Defining the set_gaussian subroutine in a module 107
4.5 New Fortran elements, at a glance 108 4.6 Further reading 108
5 Analyzing time series data with arrays 110 5.1 Analyzing stock prices with Fortran arrays 111 Objectives for this exercise 111 ■ About the data 112 Getting the data and code 114

vi

CONTENTS

5.2 Finding the best and worst performing stocks 114
Declaring arrays 116 ■ Array constructors 118 ■ Reading stock data from files 121 ■ Allocating arrays of a certain size or range 122 ■ Allocating an array from another array 123 Automatic allocation on assignment 123 ■ Cleaning up after use 124 ■ Checking for allocation status 126 ■ Catching allocation and deallocation errors 126 ■ Implementing the CSV reader subroutine 127 ■ Indexing and slicing arrays 129
5.3 Identifying risky stocks 132 5.4 Finding good times to buy and sell 135 5.5 Answer key 139
Exercise 1: Convenience (de)allocator subroutines 139 ■ Exercise 2: Reversing an array 140 ■ Exercise 3: Calculating moving average and standard deviation 140
5.6 New Fortran elements, at a glance 141 5.7 Further reading 141
6 Reading, writing, and formatting your data 143 6.1 Your first I/O: Input from the keyboard and output to the screen 144 The simplest I/O 144 ■ Reading and writing multiple variables at once 147 ■ Standard input, output, and error 148
6.2 Formatting numbers and text 151
Designing the aircraft dashboard 151 ■ Formatting strings, broken down 152 ■ Format statements in legacy Fortran code 157
6.3 Writing to files on disk: A minimal note-taking app 157
Opening a file and writing to it 158 ■ Opening a file 159 Writing to a file 161 ■ Appending to a file 162 ■ Opening files in read-only or write-only mode 163 ■ Checking whether a file exists 164 ■ Error handling and closing the file 167
6.4 Answer key 168
Exercise: Redirect stdout and stderr to files 168
6.5 New Fortran elements, at a glance 169

CONTENTS

vii

PART 3 ADVANCED FORTRAN USE ................................171
7 Going parallel with Fortran coarrays 173 7.1 Why write parallel programs? 174 7.2 Processing real-world weather buoy data 175 About the data 176 ■ Getting the data and code 178 Objectives 178 ■ Serial implementation of the program 179
7.3 Parallel processing with images and coarrays 181
Fortran images 182 ■ Getting information about the images 183 Telling images what to do 184 ■ Gathering all data to a single image 186
7.4 Coarrays and synchronization, explained 187
Declaring coarrays 188 ■ Allocating dynamic coarrays 188 Sending and receiving data 189 ■ Controlling the order of image execution 191
7.5 Toward the parallel tsunami simulator 192
Implementation strategy 192 ■ Finding the indices of neighbor images 194 ■ Allocating the coarrays 195 ■ The main time loop 196
7.6 Answer key 199
Exercise 1: Finding the array subranges on each image 199 Exercise 2: Writing a function that returns the indices of neighbor images 200
7.7 New Fortran elements, at a glance 201 7.8 Further reading 201
8 Working with abstract data using derived types 202 8.1 Recasting the tsunami simulator with derived types 203 8.2 Defining, declaring, and initializing derived types 206 Defining a derived type 209 ■ Instantiating a derived type 210 Accessing derived type components 212 ■ Positional vs. keyword arguments in derived type constructors 212 ■ Providing default values for derived type components 214 ■ Writing a custom type constructor 215 ■ Custom type constructor for the Field type 218
8.3 Binding procedures to a derived type 220
Your first type-bound method 220 ■ Type-bound methods for the Field type 221 ■ Controlling access to type components and methods 222 ■ Bringing it all together 224

viii

CONTENTS

8.4 Extending tsunami to two dimensions 224
Going from 1-D to 2-D arrays 225 ■ Updating the equation set 226 ■ Finite differences in x and y 226 ■ Passing a class instance to diffx and diffy functions 228 ■ Derived type implementation of the tsunami solver 229
8.5 Answer key 231
Exercise 1: Working with private components 231 ■ Exercise 2: Invoking a type-bound method from an array of instances 233 Exercise 3: Computing finite difference in y direction. 233
8.6 New Fortran elements, at a glance 234 8.7 Further reading 235
9 Generic procedures and operators for any data type 236 9.1 Analyzing weather data of different types 237 About the data 238 ■ Objectives 241 ■ Strategy for this exercise 242
9.2 Type systems and generic procedures 242
Static versus strong typing 242
9.3 Writing your first generic procedure 243
The problem with strong typing 243 ■ Writing the specific functions 244 ■ Writing the generic interface 247 ■ Results and complete program 251
9.4 Built-in and custom operators 253
What’s an operator? 253 ■ Things to do with operators 253 Fortran’s built-in operators 255 ■ Operator precedence 257 Writing custom operators 257 ■ Redefining built-in operators 258
9.5 Generic procedures and operators in the tsunami simulator 259
Writing user-defined operators for the Field type 259
9.6 Answer key 260
Exercise 1: Specific average function for a derived type 260 Exercise 2: Defining a new string concatenation operator 262
9.7 New Fortran elements, at a glance 263
10 User-defined operators for derived types 264 10.1 Happy Birthday! A countdown app 265 Some basic specification 265 ■ Implementation strategy 266

CONTENTS

ix

10.2 Getting user input and current time 266
Your first datetime class 266 ■ Reading user input 267 Getting current date and time 271
10.3 Calculating the difference between two times 272
Modeling a time interval 273 ■ Implementing a custom subtraction operator 273 ■ Time difference algorithm 275 The complete program 280
10.4 Overriding operators in the tsunami simulator 282
A refresher on the Field class 283 ■ Implementing the arithmetic for the Field class 284 ■ Synchronizing parallel images on assignment 286
10.5 Answer key 288
Exercise 1: Validating user input 288 ■ Exercise 2: Leap year in the Gregorian calendar 289 ■ Exercise 3: Implementing the addition for the Field type 289
10.6 New Fortran elements, at a glance 290

PART 4 THE FINAL STRETCH ........................................291

11 Interoperability with C: Exposing your app to the web 293 11.1 Interfacing C: Writing a minimal TCP client and server 294 Introducing networking to Fortran 295 ■ Installing libdill 297

11.2

TCP server program: Receiving network
connections 297
IP address data structures 299 ■ Initializing the IP address structure 301 ■ Checking IP address values 306 ■ Intermezzo: Matching compatible C and Fortran data types 308 ■ Creating a socket and listening for connections 310 ■ Accepting incoming connections to a socket 311 ■ Sending a TCP message to the client 312 ■ Closing a connection 315

11.3 TCP client program: Connecting to a remote server 317

Connecting to a remote socket 317 ■ Receiving a message 319 The complete client program 321

11.4 Some interesting mixed Fortran-C projects 322

11.5 Answer key 322

Exercise 1: The Fortran interface to ipaddr_port 322 ■ Exercise 2: Fortran interfaces to suffix_detach and tcp_close 323

x

CONTENTS

11.6 New Fortran elements, at a glance 324 11.7 Further reading 324
12 Advanced parallelism with teams, events, and collectives 326 12.1 From coarrays to teams, events, and collectives 327 12.2 Grouping images into teams with common tasks 328 Teams in the tsunami simulator 329 ■ Forming new teams 331 Changing execution between teams 332 ■ Synchronizing teams and exchanging data 335
12.3 Posting and waiting for events 338
A push notification example 339 ■ Posting an event 341 Waiting for an event 341 ■ Counting event posts 342
12.4 Distributed computing using collectives 343
Computing the minimum and maximum of distributed arrays 343 Collective subroutines syntax 345 ■ Broadcasting values to other images 346
12.5 Answer key 347
Exercise 1: Hunters and gatherers 347 ■ Exercise 2: Tsunami time step logging using events 350 ■ Exercise 3: Calculating the global mean of water height 351
12.6 New Fortran elements, at a glance 353 12.7 Further reading 353

appendix A Setting up the Fortran development environment 355 appendix B From calculus to code 361 appendix C Concluding remarks 366
index 381

foreword
I was immediately excited to find out that Milan Curcic would be writing a modern Fortran book. Almost weekly, I meet people who express surprise that Fortran remains in use more than 60 years after its creation, so any signs of new life in a language so often written off as dead or dying are cause for celebration. I usually explain that Fortran has its strongest footholds in fields that embraced computing early. I go on to tell them that they almost certainly use the results of Fortran programs daily when checking weather forecasts. What makes Milan’s work intriguing is the extent to which it connects established domains, where Fortran has long held sway, and emerging domains, where Fortran is rare. This book grew out of the unique perspective Milan brings from having been involved in bridging the divides that prevent many disciplines from writing Fortran and prevent most Fortran programmers from exploiting programming paradigms that have come into widespread use in other languages.
To Milan’s credit, the book focuses on teaching Fortran programming rather than promoting the intriguing software libraries and applications to which he has contributed. The lucky reader who follows the links to his work and that of others will gain more than just an understanding of Fortran programming. Such a reader will embark on a journey that connects numerical weather prediction, a subject as old as computing, and cloud computing, a twenty-first-century innovation. Such a reader will also discover how to incorporate aspects of functional programming, a paradigm around which whole languages have been built, in Fortran, the language that’s the ultimate ancestor of all high-level programming languages. And such a reader will be exposed
xi

xii

FOREWORD

to neural networks, a subject undergoing explosive growth and impacting technologies as disparate as autonomous driving and cancer diagnosis.
Milan has led or contributed to popular software in each of these areas, and some of the packages grew out of this book or vice versa. Cloudrun (https://cloudrun.co), a service he develops with others, for example, pioneered numerical weather prediction software-as-a-service (SaaS) using cloud computing platforms. The open source functional-fortran library (http://mng.bz/vxy1) provides utilities supporting a programming paradigm that hasn’t penetrated the Fortran world as much as I would like. The open source Fortran Standard Library (https://github.com/fortran-lang/stdlib) aims to put Fortran on more even standing with other languages that benefit from large libraries considered part of the language. His neural-fortran (https://github.com/ modern-fortran/neural-fortran), which grew out of his work on one chapter of this book, demonstrates the application of Fortran’s scalable parallel programming model in a domain dominated by languages that lack built-in parallel programming models able to exploit distributed-memory platforms. Collectively, these projects are used by hundreds of developers worldwide, and the interplay between his work on this book and work on these projects informs and inspires the book’s coverage of the language.
For the reader seeking proof of life for modern Fortran, Milan’s work provides ample evidence of the language’s ongoing role in technological modernity. This book is one of the more vibrant buds growing out of his work, and the interested reader will learn the features of the language that have proven useful in the aforementioned broad portfolio of Milan’s projects.
—DAMIAN ROUSON, PhD, P.E. President, Sourcery Institute, Oakland, California, USA

preface
When Mike Stephens from Manning first reached out to me in the summer of 2017, he wrote, “We saw some of your forum posts and GitHub repositories; would you consider writing a Fortran book with Manning?” Writing a book had never crossed my mind, nor did I believe I was cut out for the job. I closed my eyes and took a leap of faith. “Of course, I’d love to! Where do I send a proposal?” By the end of the summer, we had a contract and a tentative table of contents in place. Two development editors, two technical editors, four peer reviews, three chapter rewrites, two hurricanes, and almost three years later, we have the finished book.
Welcome to Modern Fortran: Building Efficient Parallel Applications! If you’re holding this book, chances are you either want to learn Fortran programming for school or work, or you’re an experienced Fortran programmer looking to brush up on the latest developments in the language. Either way, you’ve come to the right place. If you’re just starting to learn, my goal with this book is to give you a straightforward, hands-on, practical approach to Fortran programming. If you have prior experience with the language, I want this to be a handy survival guide in the Fortran world. Forgot how to write functions that operate on both scalars and arrays? Wondering how to write your program for parallel execution? Practical projects and exercises with solutions are here to show you how.
I’m happy to have the opportunity to share with you what I’ve learned over the past 14 years. Thank you in advance for trusting me with your time and money. Modern Fortran is my way of giving back to dozens of you who taught me and helped me along the way. I hope you use this book to teach the next generation of Fortran programmers.
xiii

acknowledgments
It takes a village to make a great book. Mike Stephens was the acquisitions editor—he brought me on board and helped work out the table of contents, as well as getting clear on who this book is for. My development editors, Kristen Watterson and Lesley Trites, guided me along the way and diligently pushed me forward. Kristen worked with me on the initial drafts of nine of the chapters; then Lesley took over for the remainder and putting it all together. Technical editors Michiel Trimpe and Alain Couniot made sure to point out any mistakes in the code and confusing paragraphs that didn’t make sense. Bert Bates chimed in on occasion to help me pull out the concrete from the abstract. Maurizio Tomasi was the technical proofreader and made sure that all the code in the book works as advertised. Melody Dolab was the final proofreader and Lori Weidert was the production editor. Also, the rest of the Manning staff who worked with me: Candace Gillhoolley, Ana Romac, Rejhana Markanovic, Aleksandar Dragosavljevic´, Matko Hrvatin, and others. Thank you all—I’ve learned a lot from you.
I also want to thank all of the reviewers: Anders Johansson, Anton Menshov, Bridger Howell, David Celements, Davide Cadamuro, Fredric Ragnar, Jan Pieter Herweijer, Jose San Leandro, Joseph Ian Walker, Kanak Kshetri, Ken W. Alger, Konrad Hinsen, Kyle Mandli, Leonardo Costa Prauchner, Lottie Greenwood, Luis MouxDomínguez, Marcio Nicolau, Martin Beer, Matthew Emmett, Maurizio Tomasi, Michael Jensen, Michal Konrad Owsiak, Mikkel Arentoft, Ondrˇej Cˇertík, Patrick Seewald, Richard Fieldsend, Ryan B. Harvey, Srdjan Santic, Stefano Borini, Tiziano Müller, Tom Gueth, Valmiky Arquissandas, and Vincent Zaballa. Your suggestions helped make this a better book.
xiv

ACKNOWLEDGMENTS

xv

Arjen Markus provided thorough reviews and suggestions on every chapter as they became available in the Manning Early Access Program. Izaak Beekman, Jacob Williams, Marcus Van Lier-Walqui, and Steve Lionel provided helpful comments on early drafts of the book. Damian Rouson and his own books were an inspiration, and he encouraged me further along the way. Michael Hirsch helped with continuous integration of some of the GitHub repositories associated with the book. Finally, all my readers who trusted me and bought the book while still in the works—you helped me to keep at it and finish the job.
Last but not least, to my wife, family, and friends who supported me and were proud of me—I couldn’t have done it without your love and help.

about this book
Modern Fortran aims to fill a glaring gap in the existing Fortran literature: a book that teaches modern Fortran through practical, hands-on examples, with extra attention on parallel programming and the latest developments in the language. This is a book for scientists and engineers who want to solve the challenging computational problems of tomorrow using mature, highly performant, easy-to-use technology. If you don’t have a clue about Fortran and want to work on a Fortran project (new or existing), I believe this book is the easiest and fastest way to get you up to speed.
Modern Fortran isn’t a complete reference on all features of the language. Instead, it’s a straightforward and hands-on practical course on Fortran programming, covering the most essential features you’re likely to use in your work. I also intend this to be a useful reference text for solving practical everyday problems in science and engineering. Examples in this book range from the more general, like a note-taking app and working with dates and times; to the specialized, such as stock price and weather data analysis; to the more sophisticated, such as parallel tsunami simulation. You’ll find many examples and solutions to problems that are typically not covered by other books on Fortran.
Also, unlike most other Fortran books, this one gives extra attention to parallel programming. As of the 2008 release, Fortran is a natively parallel programming language, and the recent 2018 release only brings more to the table. In particular, this book will show you how to write parallel Fortran programs using coarrays, teams, events, and collectives, without relying on external libraries such as the Message Passing Interface.
xvi

ABOUT THIS BOOK

xvii

However, parallel programming is an advanced topic, and most chapters in the book focus on gently introducing nonparallel language concepts. There’s only so much material that we could fit in a single book, so important topics such as parallel algorithms and scaling aren’t covered. Message Passing Interface, OpenMP, and OpenACC, while all important technologies in their own right, were simply out of scope for this book. Ditto for debugging, preprocessors, and working with legacy code. I’ll provide references for further reading where appropriate.
Who should read this book
This book is primarily for readers who are new to Fortran and want to learn it. It will also be useful to experienced Fortran programmers who want to brush up on the latest in Fortran development through fun exercises. Whether you’ve had any contact with Fortran or not, I assume you have at least some experience programming and understand the basic concepts of source code, variables, and functions. Perhaps you’re a proficient Fortran programmer looking to step up your parallel programming game. Maybe your company is embedding a large Fortran simulation codebase into the existing software stack, and the project fell into your lap. Whatever your story is, I believe you’ll learn something new from this book.
I believe the following professions will benefit most from this book:
■ Students and researchers in science or engineering, especially disciplines that involve computational fluid dynamics
■ Meteorologists, oceanographers, and climate scientists, especially those who work on numerical prediction problems
■ Data analysis professionals, such as data engineers and data scientists ■ Machine learning researchers and practitioners ■ Quantitative finance analysts ■ High-performance computing system administrators ■ Teachers and instructors in any of the above disciplines or anybody else curious
about programming languages and computation in general.
A bit of Fortran history
Fortran is a compiled, statically typed, general-purpose programming language. It was developed by John Backus and his team at IBM, with the first release in 1957 for the IBM 704 computer. Originally called FORTRAN (FORmula TRANslation), it allowed programmers to write programs more easily compared to writing machine instructions of the era. Fortran was one of the first high-level programming languages in history and is the oldest language still in active use and development today. In that sense, Fortran was the very beginning of the modern computing that we practice today.
The language has since evolved through more than a dozen revisions and several ISO standards. Fortran remains the dominant language of high-performance computing (HPC), where many interconnected processors work together to solve huge problems. Fortran 2018 is the most recent iteration of the language. The next revision,

xviii

ABOUT THIS BOOK

with the current working name Fortran 202x, is in development and expected to come out in the next few years.
Today, Fortran is the leading programming language used in many areas of physical science and engineering. These include computational fluid dynamics, numerical weather prediction, climate science, aerodynamics, astrophysics and so on. Fortran is also used to benchmark the world’s fastest and largest supercomputers (https://top500.org). Many universities still teach Fortran programming in science and engineering tracks because Fortran remains relevant in those industries. With the explosion of internet and mobile technologies over the past 20 years, it’s evident that the Fortran ecosystem has fallen into the shadows, at least from the point of view of mainstream computing. However, its relevance never lessened on an absolute scale. In fact, Fortran compilers, Fortran libraries, and its open source community are stronger than ever. Fortran is the only standardized language with a native parallel programming model, expressed using an intuitive array-like syntax. With the current trend toward many-core architectures, it’s safe to say that Fortran will be relevant for many years to come.
How this book is organized: a roadmap
Modern Fortran is organized in four parts and twelve chapters:
■ Part 1—Getting started with modern Fortran – Chapter 1 will give you a taste of Fortran and what kind of problems it solves best. – Chapter 2 will guide you through a basic, yet complete Fortran program.
■ Part 2—Core elements of Fortran – Chapter 3 will teach you to use procedures to simplify and reuse your Fortran program. – Chapter 4 explains how to organize your procedures and variables in modules. – Chapter 5 covers arrays and whole-array arithmetic. – Chapter 6 tackles input and output, and formatting numerical data as text.
■ Part 3—Advanced Fortran use – Chapter 7 will show you how to use images and coarrays for parallel programming. – Chapter 8 covers derived types for working with abstract and complex data structures. – Chapter 9 explains how to write generic procedures that can work on arguments of any data type. – Chapter 10 covers user-defined operators for derived types.
■ Part 4—The final stretch – Chapter 11 will teach you how to interface with existing C libraries from Fortran. – Chapter 12 covers advanced parallel programming concepts: teams, events, and collectives.

ABOUT THIS BOOK

xix

Part 1 will give you a taste of Fortran. Work through this part if you’re new to Fortran. Even if you have some Fortran experience, if you’d like to work through the running example (a tsunami simulator), it’s introduced in chapter 2. At the end of part 1, you’ll be able to write, compile, and run basic working Fortran programs.
In part 2, I cover the core elements of the language: procedures (functions and subroutines), modules, arrays, and I/O. These are the features that you’ll find in most Fortran projects and that are essential for writing clean, organized, and reusable code. At the end of part 2, you’ll be able to write more complex Fortran programs and libraries to solve real problems. You can start here if you’re proficient with one or more other programming languages. After working through this part, and with some practical experience, you’ll be a functional and independent Fortran programmer.
Part 3 introduces parallel programming with coarrays (chapter 7), as well as derived types (chapter 8), generic procedures (chapter 9), and custom operators (chapter 10). Here, you’ll write your first parallel program, model complex data structures with classes, and write generic procedures that can work with any data type. This part depends on concepts introduced in part 2. Become familiar with those concepts first. After you work through part 3, you’ll be able to understand, reuse, and extend most of the existing Fortran code in the wild, as well as write innovative parallel Fortran solutions. This is the heaviest part of the book—approach it with patience and an open mind.
Finally, part 4 covers specialty topics: interfacing C code from Fortran (chapter 11) and advanced parallel features that were most recently added to the language—teams, events, and collectives (chapter 12). The former is important if you’ll use Fortran for systems programming, networking, interfacing with instruments, or reusing existing C libraries for any task. The latter is the cutting edge of parallel programming in Fortran. I recommend working through these chapters only after you’re familiar with the concepts covered in parts 2 and 3.
When it came to deciding on the order in which to organize different chapters and topics, we found that there’s no obvious answer. Depending on your experience and interest, you may find that some more basic topics may be covered later in the book. If that’s the case, feel free to skip ahead and come back at a later time. Just like any new creation, this book is an experiment. Choose your own adventure, and do what feels good.
About the code
This book develops quite a bit of source code, mostly organized in one large running example (tsunami simulator) and several miniprojects. All of the code in this book is organized in Git repositories at https://github.com/modern-fortran. The tsunami simulator and the miniprojects each have their own GitHub repository, so you can explore and tinker with them independently from one another. Miscellaneous examples and source code listings that don’t belong to any single project are organized in the “listings” repository at https://github.com/modern-fortran/listings. I maintain these

xx

ABOUT THIS BOOK

as active projects, so if you spot any issues or have a question about the code, feel free to open an issue in the appropriate repository.
Although all the code is available to download, I recommend that you type out the source code by hand as you work through this book. Doing this will get you accustomed to Fortran’s syntax and help you develop muscle memory. However, if you still want to just download the code and run it, you of course can. If you’re familiar with Git, the easiest way to get the code is to git clone each project repository from the command line. If you don’t have Git or don’t want to use it, just download the zip archive of the source code from the repository page. The README file in each project will instruct you on how to build it.
This book contains many examples of source code in numbered listings, in code snippets, and inline with normal text. In all cases, except code annotations, source code is formatted in a fixed-width font like this to separate it from ordinary text.
In many cases, the original source code has been reformatted; we’ve added line breaks and reworked indentation to accommodate the available page space in the book. Additionally, comments in the source code have often been removed from the listings when the code is described in the text. Code annotations accompany many of the listings, highlighting important concepts.
Requirements
To work through this book, you’ll need a computer, ideally with Linux or macOS. If you work with Windows 10, you may already have access to the Windows Subsystem for Linux, which provides a native Linux environment, and I recommend using that. If you’re on an older version of Windows, I suggest setting up a Linux Virtual Machine on your system. The advantage of Linux operating systems is that they’re designed for software development. I worked with both Ubuntu 18.10 (desktop) and Fedora 28 (laptop) while writing this book. They’re both great for Fortran development.
You’ll also need working knowledge of a text editor with syntax highlighting to read and write source code, as well as knowing how to use the Linux/UNIX command line to compile programs. I’m a minimalist when it comes to text editors and prefer Vim (Vi IMproved). If you like more sophisticated editors like Sublime, Atom, or VS Code, those are fine as well. After all, an editor is just a tool. Pick one that gets out of your way of doing actual work. You’ll find more info on text editors in appendix A.
Get involved
If you like Fortran, and this book inspires you to do more, consider joining the Fortran open source community and/or the Standard Committees:
■ Fortran home on the internet: https://fortran-lang.org ■ Fortran home on GitHub: https://github.com/fortran-lang ■ Fortran Standard Library: https://github.com/fortran-lang/stdlib ■ Fortran Package Manager: https://github.com/fortran-lang/fpm

ABOUT THIS BOOK

xxi

■ Proposals for the Fortran Standard Committee: https://github.com/j3-fortran/ fortran_proposals
■ US Fortran Standards Committee: https://j3-fortran.org ■ International Fortran Standards Committee: https://wg5-fortran.org
The community is friendly and open to all newcomers with goodwill. We need help— join us!
liveBook discussion forum
Purchase of Modern Fortran: Building Efficient Parallel Applications includes free access to a private web forum run by Manning Publications, where you can make comments about the book, ask technical questions, and receive help from the author and other users. To access the forum, go to https://livebook.manning.com/#!/book/modernfortran/discussion. You can also learn more about Manning’s forums and the rules of conduct at https://livebook.manning.com/#!/discussion.
Manning’s commitment to our readers is to provide a venue where a meaningful dialog between individual readers and between readers and the author can take place. It’s not a commitment to any specific amount of participation on the part of the author, whose contribution to the forum remains voluntary (and unpaid). We suggest you try asking the author some challenging questions lest his interest stray! The forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print.

about the author
MILAN CURCIC is a meteorologist and oceanographer. He studies ocean waves and turbulence and their importance for numerical weather and ocean prediction at the University of Miami. He’s also working on enabling numerical weather prediction in the scalable compute cloud. A Fortran programmer since 2006, he has worked with teams from the United States Navy and NASA on developing and improving Earth system prediction models. He has authored several open source Fortran libraries and collaborates with the Fortran Standards Committee on developing the next Fortran release, as well as its standard library.
Milan lives with his wife, Evelyn, and son, Nolan, in Boca Raton, Florida. You can stay up to date and get in touch with him at https://milancurcic.com.
xxii

about the cover illustration
The figure on the cover of Modern Fortran: Building Efficient Parallel Applications is captioned “Ingrienne,” which refers to a woman from the historical geographic area of Ingria, located along the southern shore of the Gulf of Finland. The illustration is taken from a collection of dress costumes from various countries by Jacques Grasset de Saint-Sauveur (1757–1810), titled Costumes Civils Actuels de Tous les Peuples Connus, published in France in 1788. Each illustration is finely drawn and colored by hand. The rich variety of Grasset de Saint-Sauveur’s collection reminds us vividly of how culturally apart the world’s towns and regions were just 200 years ago. Isolated from each other, people spoke different dialects and languages. In the streets or in the countryside, it was easy to identify where they lived and what their trade or station in life was just by their dress.
The way we dress has changed since then, and the diversity by region, so rich at the time, has faded away. It’s now hard to tell apart the inhabitants of different continents, let alone different towns, regions, or countries. Perhaps we’ve traded cultural diversity for a more varied personal life—certainly for a more varied and fast-paced technological life.
At a time when it’s hard to tell one computer book from another, Manning celebrates the inventiveness and initiative of the computer business with book covers based on the rich diversity of regional life of two centuries ago, brought back to life by Grasset de Saint-Sauveur’s pictures.
xxiii

Part 1
Getting started with Modern Fortran
In this part, you’ll get a taste of Fortran and a gentle introduction into the
language. In chapter 1, we’ll discuss the design and features of Fortran, and the kinds
of problems for which Fortran is suitable. You’ll learn why parallel programming is important and when you should use it.
In chapter 2, we’ll build a minimal working example of the tsunami simulator that we’ll be working on throughout the book. This example will give you a taste of the Fortran essentials: variable declaration, data types, arrays, loops, and branches.
If you’re new to Fortran, this is the place to start. At the end of this part of the book, you’ll be able to write simple yet useful Fortran programs. More importantly, you’ll be ready to learn about Fortran essentials in more depth.

Introducing Fortran
This chapter covers
 What is Fortran and why learn it?  Fortran’s strengths and weaknesses  Thinking in parallel  Building a parallel simulation app from scratch
This is a book about Fortran, one of the first high-level programming languages in history. It will teach you the language by guiding you step-by-step through the development of a fully featured, parallel physics simulation app. Notice the emphasis on parallel. Parallel programming allows you to break your problem down into pieces and let multiple processors each work on only part of the problem, thus reaching the solution in less time. By the end, you’ll be able to recognize problems that can be parallelized, and use modern Fortran techniques to solve them.
This book is not a comprehensive reference manual for every Fortran feature— I’ve omitted significant parts of the language on purpose. Instead, I focus on the most practical features that you’d use to build a real-world Fortran application. As we work on our app chapter by chapter, we’ll apply modern Fortran features and software design techniques to make our app robust, portable, and easy to use and
3

4

CHAPTER 1 Introducing Fortran

extend. This isn’t just a book about Fortran; it’s a book about building robust, parallel software using modern Fortran.
1.1 What is Fortran?
I don’t know what the language of the year 2000 will look like, but I know it will be called Fortran.
—Tony Hoare, winner of the 1980 Turing Award
Fortran is a general-purpose, parallel programming language that excels in scientific and engineering applications. Originally called FORTRAN (FORmula TRANslation) in 1957, it has evolved over decades to become a robust, mature, and high perfomanceoriented programming language. Today, Fortran keeps churning under the hood of many systems that we take for granted:
 Numerical weather, ocean, and surf prediction  Climate science and prediction  Computational fluid dynamics software used in mechanical and civil engineering  Aerodynamics solvers for designing cars, airplanes, and spacecraft  Fast linear algebra libraries used by machine learning frameworks  Benchmarking the fastest supercomputers in the world (https://top500.org)
Here’s a specific example. In my work, I develop numerical models of weather, ocean surface waves, and deep ocean circulation. Talking about it over the years, I found that most people didn’t know where weather forecasts came from. They had the idea that meteorologists would get together and draw a chart of what the weather would be like tomorrow, next week, or a month from now. This is only partly true. In reality, we use sophisticated numerical models that crunch a huge amount of numbers on computers the size of a warehouse. These models simulate the atmosphere to create an educated guess about what the weather will be like in the future. Meteorologists use the output of these models to create a meaningful weather map, like the one shown in figure 1.1. This map shows just a sliver of all the data that this model produces. The output size of a weather forecast like this is counted in hundreds of gigabytes.
The most powerful Fortran applications run in parallel on hundreds or thousands of CPUs. Development of the Fortran language and its libraries has been largely driven by the need to solve extremely large computational problems in physics, engineering, and biomedicine. To access even more computational power than what the most powerful single computer at the time could offer, in the late 20th century we started connecting many computers with high-bandwidth networks and let them each work on a piece of the problem. The result is the supercomputer, a massive computer made up of thousands of commodity CPUs (figure 1.2). Supercomputers are similar to modern server farms hosted by Google or Amazon, except that the network infrastructure in supercomputers is designed to maximize bandwidth and minimize latency between the servers themselves, rather than between them and the outside world. As a result, the CPUs in

What is Fortran?

5

Latitude

40 40

35

35

30

30

25

20

25

15

10

20

5

0 15
–100 –95 –90 –85 –80 –75 –70 –65 –60
Longitude

Figure 1.1 A forecast of Hurricane Irma on September 10, 2017, computed by an operational weather prediction model written in Fortran. Shading and barbs show surface wind speed in meters per second, and contours are isolines of sea-level pressure. A typical weather forecast is computed in parallel using hundreds or thousands of CPUs. (Data provided by the NOAA National Center for Environmental Prediction [NCEP])

Figure 1.2 The MareNostrum 4 supercomputer at the Barcelona Supercomputing Center. The computer is housed inside the Torre Girona Chapel in Barcelona, Catalonia, Spain. A highspeed network connects all of the cabinets to each another. With 153,216 Intel Xeon cores, MareNostrum 4 is the fastest supercomputer in Spain, and the 37th fastest in the world as of June 2020. (https://www.top500.org/lists/2020/06). It’s used for many scientific applications, from astrophysics and materials physics, to climate and atmospheric dust transport prediction, to biomedicine. (Image source: https://www.bsc.es/marenostrum/marenostrum)

6

CHAPTER 1 Introducing Fortran

a supercomputer act like one giant processor with distributed-memory access that’s nearly as fast as local memory access. To this day, Fortran remains the dominant language used for such massive-scale parallel computations.
1.2 Fortran features
This is not your parents’ Fortran.
—Damian Rouson
In the context of programming languages, Fortran is all of the following:  Compiled—You’ll write whole programs and pass them to the compiler before executing them. This is in contrast to interpreted programming languages like Python or JavaScript, which are parsed and executed line by line. Although this makes writing programs a bit more tedious, it allows the compiler to generate efficient executable code. In typical use cases, it’s not uncommon for Fortran programs to be one or two orders of magnitude faster than equivalent Python programs.

What is a compiler?
A compiler is a computer program that reads source code written in one programming language and translates it to equivalent code in another programming language. In our case, a Fortran compiler will read Fortran source code and generate appropriate assembly code and machine (binary) instructions.

 Statically typed—In Fortran, you’ll declare all variables with a type, and they’ll remain of that type until the end of the program:

real :: pi pi = 3.141592

pi must be declared before use.
pi remains a “real” number until the program halts.

You’ll also need to explicitly declare the variables before their use, which is known as manifest typing. Finally, Fortran employs so-called strong typing, which means that the compiler will raise an error if a procedure is invoked with an argument of the wrong type. While static typing helps the compiler to generate efficient programs, manifest and strong typing enforce good programming hygiene and make Fortran a safe language. I find it’s easier to write correct Fortran programs than Python or Javascript, which come with many hidden caveats and “gotchas.”
 Multiparadigm—You can write Fortran programs in several different paradigms, or styles: imperative, procedural, object-oriented, and even functional. Some paradigms are more appropriate than others, depending on the problem you’re trying to solve. We’ll explore different paradigms as we develop code throughout the book.

Fortran features

7

 Parallel—Fortran is also a parallel language. Parallelism is the capability to split the computational problem between processes that communicate through a network. Parallel processes can be running on the same processing core (threadbased parallelism), on different cores that share RAM (shared-memory parallelism), or distributed across the network (distributed-memory parallelism). Computers working together on the same parallel program can be physically located in the same cabinet, across the room from each other, or across the world. Fortran’s main parallel structure is a coarray, which allows you to express parallel algorithms and remote data exchange without any external libraries. Coarrays allow you to access remote memory just like you’d access elements of an array, as shown in the following listing.

Listing 1.1 Example data exchange between parallel images

program hello_coarrays

implicit none

Each image declares a local copy of an integer “a.”

integer :: a[*] integer :: i

Each image assigns its number (1, 2, 3, etc.) to “a.”

a = this_image()

Only image 1 will enter this if block.

if (this_image() == 1) then do i = 1, num_images()

Iterates from 1 to the total number of images

print *, 'Value on image', i, 'is', a[i] end do end if
end program hello_coarrays

For each remote image, image 1 will get the value of “a” on that image and print it to the screen.

The Fortran standard doesn’t dictate how the data exchange is implemented under the hood; it merely specifies the syntax and the expected behavior. This allows the compiler developers to use the best approach available on any specific hardware. Given a capable compiler and libraries, a Fortran programmer can write code that runs on conventional CPUs or general-purpose GPUs alike. Listing 1.1 is meant for illustration; however, if you’d like to compile and run it, do so after following the instructions in Appendix A to set up your Fortran development environment.
 Mature—In 2016, we celebrated 60 years since the birth of Fortran. The language has evolved through several revisions of the standard: – FORTRAN 66, also known as FORTRAN IV (ANSI, 1966) – FORTRAN 77 (ANSI, 1978) – Fortran 90 (ISO/IEC, 1991; ANSI, 1992) – Fortran 95 (ISO/IEC, 1997)

8

CHAPTER 1 Introducing Fortran

– Fortran 2003 (ISO/IEC, 2004) – Fortran 2008 (ISO/IEC, 2010) – Fortran 2018 (ISO/IEC, 2018) Fortran development and implementation in compilers have been heavily supported by the industry: IBM, Cray, Intel, NAG, NVIDIA, and others. There has also been significant open source development, most notably free compilers— gfortran (https://gcc.gnu.org/wiki/GFortran), Flang (https://github.com/flangcompiler/flang), and LFortran (https://lfortran.org)—as well as other community projects (https://fortran-lang.org/community). Thanks to Fortran’s dominance in the early days of computer science, today we have a vast set of robust and mature libraries that are the computational backbone of many applications. With mature compilers and a large legacy code base, Fortran remains the language of choice for many new software projects for which computational efficiency and parallel execution are key.  Easy to learn—Believe it or not, Fortran is quite easy to learn. This was my experience and that of many of my colleagues. It’s easy to learn partly due to its strict type system, which allows the compiler to keep the programmer in check and warn them at compile time when they make a mistake. Although verbose, the syntax is clean and easy to read. However, like every other programming language or skill in general, Fortran is difficult to master. This is one of the reasons why I chose to write this book.
1.3 Why learn Fortran?
There were programs here that had been written five thousand years ago, before Humankind ever left Earth. The wonder of it—the horror of it, Sura said—was that unlike the useless wrecks of Canberra’s past, these programs still worked! And via a million million circuitous threads of inheritance, many of the oldest programs still ran in the bowels of the Qeng Ho system.
—Vernor Vinge, A Deepness in the Sky
Since the early 1990s, we’ve seen an explosion of new programming languages and frameworks, mainly driven by the widespread use of the internet and, later, mobile devices. C++ took over computer science departments, Java has been revered in the enterprise, JavaScript redefined the modern web, R became the mother tongue of statisticians, and Python took the machine learning world by storm. Where does Fortran fit in all this? Through steady revisions of the language, Fortran has maintained a solid footing in its niche domain, high-performance computing (HPC). Its computational efficiency is still unparalleled, with only C and C++ coming close. Unlike C and C++, Fortran has been designed for array-oriented calculations, and is, in my opinion, significantly easier to learn and program. A more recent strong argument for Fortran has come about through its native support for parallel programming.

Why learn Fortran?

9

What is high-performance computing?
High-performance computing (HPC) is the practice of combining computer resources to solve computational problems that would otherwise not be possible with a single desktop computer. HPC systems typically aggregate hundreds or thousands of servers and connect them with fast networks. Most HPC systems today run some flavor of Linux OS.
Despite being a decades-old technology, Fortran has several attractive features that make it indispensable, even compared to more recent languages:
 Array-oriented—Fortran provides whole-array arithmetic and operations, which greatly simplify element-wise operations. Consider the task of multiplying two two-dimensional arrays:
do j = 1, jm do i = 1, im c(i,j) = a(i,j) * b(i,j) end do
end do
With Fortran’s whole-array arithmetic, you write
c=a*b
This is not only more expressive and readable code, it also hints to the compiler that it can choose the optimal way to perform the operation. Arrays lend themselves well to CPU architectures and computer memory because they’re contiguous sequences of numbers, and thus mirror the physical layout of the memory. Fortran compilers are capable of generating extremely efficient machine code, thanks to the assumptions that they can safely make.  The only parallel language developed by a standards committee (ISO)—The Fortran standards committee ensures that the development of Fortran goes in the direction that supports its target audience: computational scientists and engineers.  Mature libraries for science, engineering, and math—Fortran started in the 1950s as the programming language for science, engineering, and mathematics. Decades later, we have a rich legacy of robust and trusted libraries for linear algebra, numerical differentiation and integration, and other mathematical problems. These libraries have been used and tested by generations of programmers, to the point that they are guaranteed to be almost bug-free.  Growing general-purpose library ecosystem—In the past decade, Fortran has also seen a growing ecosystem of general-purpose libraries: text parsing and manipulation, I/O libraries for many data formats, working with dates and times, collections and data structures, and so on. Any programming language is as

10

CHAPTER 1 Introducing Fortran

powerful as its libraries, and the growing number of Fortran libraries make it more useful today than ever before.  Unmatched performance—Compiled Fortran programs are as close to the metal as it gets with high-level programming languages. This is thanks to both its arrayoriented design and mature compilers that continuously improve at optimizing code. If you’re working on a problem that does math on large arrays, few other languages come close to Fortran’s performance.
In summary, learn Fortran if you need to implement efficient and parallel numerical operations on large multidimensional arrays.

1.4 Advantages and disadvantages
Many Fortran features give it both an advantage and a disadvantage. For example, it’s all of the following:
 A domain-specific language—Despite being technically a general-purpose language, Fortran is very much a domain-specific language, in the sense that it has been designed for science, engineering, and math applications. If your problem involves some arithmetic on large and structured arrays, Fortran will shine. If you want to write a web browser or low-level device drivers, Fortran is not the right tool for the task.
 A niche language—Fortran is extremely important to a relatively small number of people: scientists and engineers in select disciplines. As a consequence, it may be difficult to find as many tutorials or blogs about Fortran as there are for more mainstream languages.
 A statically and strongly typed language—As I mentioned earlier, this makes Fortran a very safe language to program in and helps compilers generate efficient executables. On the flip side, it makes it less flexible and more verbose, and thus not the ideal language for rapid prototyping.
The comparison of Fortran to Python that follows will help you better understand its advantages and disadvantages in the general-purpose programming context.

1.4.1

Side-by-side comparison with Python
How does modern Fortran compare to a more recent general-purpose programming language? Python has had the most rapidly growing ecosystem in the past few years for data analysis and light number crunching (http://mng.bz/XP71). It’s used by many Fortran programmers for postprocessing of model output and data analysis. In fact, Python is my second favorite programming language. Because of the application domain overlap between Fortran and Python, it’s useful to summarize key differences between the two, as shown in table 1.1. If you’re a Python programmer, this summary will give you an idea of what you can and can’t do with Fortran.

Advantages and disadvantages

11

Table 1.1 Comparison between Fortran and Python (CPython specifically)

Language

Fortran

First appeared

1957

Latest release International standard

Fortran 2018 ISO/IEC

Implementation language
Compiled vs. interpreted Typing discipline

C, Fortran, Assembly (compiler-dependent)
Compiled
Static, strong

Parallel Multidimensional arrays

Shared and distributed memory
Yes, up to 15 dimensions

Built-in types

character, complex, integer, logical, real

Constants Classes Generic programming Pure functions Higher order functions Anonymous functions Interoperability with other languages OS interface Exception handling

Yes Yes Limited Yes Limited No C (limited)
Limited Limited

Python 1991 3.8.5 (2020) No C
Interpreted Dynamic, strong Shared memory only
Third-party library only (numpy) bool, bytearray, bytes, complex, dict, ellipsis, float, frozenset, int, list, set, str, tuple No Yes Yes No Yes Yes C
Yes Yes

From table 1.1, a few key differences between Fortran and Python stand out. First, Fortran is compiled and statically typed, while Python is interpreted and dynamically typed. This makes Fortran more verbose and slower to program but allows the compiler to generate fast binary code. This is a blessing and a curse: Fortran isn’t designed for rapid prototyping, but can produce robust and efficient programs. Second, Fortran is a natively parallel programming language, with syntax that allows you to write parallel code that’s independent of whether it will run on shared or distributed memory computers. In contrast, distributed parallel programming in Python is possible only with external libraries, and is overall more difficult to do. Finally, Fortran is a smaller language that focuses on efficient computation over large multidimensional

12

CHAPTER 1 Introducing Fortran

arrays of a few different numeric data types. On the other side, Python has a much broader arsenal of data structures, algorithms, and general-purpose utilities built in.
In summary, whereas Python is akin to a comprehensive and flexible toolbox, Fortran is like a highly specialized power tool. Fortran thus isn’t well suited for writing device drivers, video games, or web browsers. However, if you need to solve a large numerical problem that can be distributed across multiple computers, Fortran is the ideal language for you.
1.5 Parallel Fortran, illustrated
I’ll illustrate the kind of problem where Fortran really shines. Let’s call this example “Summer ends on old Ralph’s farm.”
Farmer Ralph has two sons and two daughters, and a big farm. It’s the end of the summer and about time to cut the grass and make hay for the cattle to eat. But the pasture is big, and old Ralph is weak. His children, however, are young and strong. If they all work hard and as a team, they could get it done in a day. They agree to split the work between themselves in four equal parts. Each of Ralph’s children grabs a scythe and a fork and heads to their part of the pasture. They work hard, cutting grass row by row. Every hour or so, they meet at the edges to sharpen their tools and chat about how it’s going. The work is going well, and almost all of the grass is cut by mid-afternoon. Near the end of the day, they collect the hay into bales and take them to the barn. Old Ralph is happy that he has strong and hard-working children, but even more so that they make such a great team! Working together, they completed work that would take four times as long if only one of them was working.
Now you must be thinking, what the heck does old Ralph’s farm have to do with parallel Fortran programming? More than meets the eye, I can tell you! Old Ralph and his big pasture are an analogy to a slow computer and a big compute problem. Just like Ralph asked his children to help him with the chores, in a typical parallel problem we’ll divide the computational domain, or input data, into equal pieces and distribute them between CPUs. Recall that his children cut the grass row by row— some of the most efficient and expressive aspects of Fortran code are the whole-array operations and arithmetic. Periodically, they met at the edges to sharpen their tools and have a chat. In many real-world apps, you’ll instruct the parallel processes to exchange data, and this is true for most of the parallel examples that I’ll guide you through in this book. Finally, each parallel process asynchronously writes its data to disk, like taking the hay bales to the barn. I illustrate this pattern in figure 1.3.
Much like farmer Ralph, Fortran is old. This is by no means a bad thing! It’s a mature, robust, and dependable language that isn’t going anywhere. Although it does have some quirks of an old programming language, it’s been improved over decades by generations of computer scientists and programmers, and has been battle-tested in countless applications where performance is critical. The ease of parallel programming with Fortran is key for high-performance apps, which is why I made it a central theme of this book.

What will you learn in this book?

13

1. Big compute problem

2. Divide the work into smaller pieces.

?

CPU 1 CPU 2

CPU 1 CPU 2

CPU 3 CPU 4 CPU 1 CPU 2

CPU 3 CPU 4

CPU 3 CPU 4

3. Exchange data between CPUs when needed.

4. Store the data to disk.

Figure 1.3 Parallel programming patterns: divide the problem, exchange data, compute, and store the results to disk

1.6 What will you learn in this book?
This book will teach you how to write modern, efficient, and parallel Fortran programs. Working through each chapter, we’ll build from scratch a fully functional, parallel, fluid dynamics solver with a specific application to tsunami prediction. If you work through the book, you’ll come out with three distinct skill sets:
 You’ll be fluent with most modern Fortran features. This is a unique and desired skill in a robust, multibillion-dollar market that is HPC.
 You’ll be able to recognize problems that are parallel in nature. You’ll think parallel-first, and parallel solutions to problems will seem intuitive. In contrast, a serial solution to a parallel problem will become an edge-case scenario.
 You’ll get a grasp on good software design, writing reusable code, and sharing your project with the online community. You’ll also be able to adapt existing Fortran libraries in your project and contribute back. This will not only make your project useful to others, but can open doors in terms of career and learning opportunities. It did for me!

14

CHAPTER 1 Introducing Fortran

While I’m not expecting you to have prior Fortran experience, I assume you have at least some programming experience in a language like Python, R, MATLAB, or C. We won’t go into detail about what is a program, a variable, a data type, source code, or computer memory, and I’ll assume that you have an idea about these concepts. Occasionally, we’ll touch on elements of calculus, although it’s not crucial that you’re familiar with it. We’ll also work quite a bit in the terminal (compiling and running programs), so I assume you’re at least comfortable navigating the command line. Whatever the case, to help ensure clarity, any Fortran concept in this book will be taught from scratch.
Given the theme of the book, I expect it will be ideal for several audiences, such as the following:
 Undergraduate and graduate students in physical science, engineering, or applied math, especially with a focus on fluid dynamics
 Instructors and researchers in the above fields  Meteorologists, oceanographers, and other fluid dynamicists working in the
industry  Serial Fortran programmers who want to step up their parallel game  HPC system administrators
If you fit in one of the above categories, you may already know that Fortran’s main selling point is its ease of programming efficient and parallel programs for large supercomputers. This has kept it as the dominant HPC language of physical sciences and engineering. Although this book will teach you Fortran from the ground up, I will also take the unconventional approach and teach it in the context of parallel programming from the get-go. Rather than gaining just another technical skill as an afterthought, you’ll learn how to think parallel. You’ll recognize ways you can distribute the workload and memory to arrive at the solution more efficiently. With parallel thinking, you’ll come out with two critical advantages:
1 You’ll be able to solve problems in less time. 2 You’ll be able to solve problems that can’t fit onto a single computer.
While the first is at least a nice-to-have, the second is essential. Some problems simply can’t be solved without parallel programming. The next section will give you a gentle introduction and an example of parallel programming.
1.7 Think parallel!
For over a decade prophets have voiced the contention that the organization of a single computer has reached its limits and that truly significant advances can be made only by interconnection of a multiplicity of computers in such a manner as to permit cooperative solution.
—Gene Amdahl (computer architect) in 1967
Parallel programming is only becoming more important with time. Although still positive, the rate of semiconductor density increase, as described by Moore’s law, is

Think parallel!

15

limited. Traditionally we went past this limit by placing more processing cores on a single die. Even the processors in most smartphones today are multicore. Beyond the shared-memory computer, we’ve connected many machines into networks, and made them talk to each other to solve huge computational problems. Your weather forecast this morning was computed on hundreds or thousands of parallel processors. Due to the practical limits of Moore’s law and the current tendency toward many-core architectures, there’s a sense of urgency to teach programming parallel-first.

What is Moore’s law?
Gordon Moore, cofounder of Intel, noticed in 1965 that the number of transistors in a CPU was doubling each year. He later revised this trend to doubling every two years. Nevertheless, the rate of increase is exponential and closely related to a continuous decrease in the cost of computers. A computer you buy today for $1,000 is about twice as powerful as one you could buy for the same amount two years ago.
Similarly, when you buy a new smartphone, the OS and the apps run smoothly and quickly. What happens two years later? As the apps update and bloat with new features, they demand increasingly more CPU power and memory. As the hardware in your phone stays the same, eventually the apps slow down to a crawl.

All parallel problems fall into two categories:
1 Embarrassingly parallel—And by this, I mean “embarrassingly easy”—it’s a good thing! These problems can be distributed across processors with little to no effort (figure 1.4, left). Any function f(x) that operates element-wise on an array x without need for communication between elements is embarrassingly parallel. Because the domain decomposition of embarrassingly parallel problems is trivial, modern compilers can often autoparallelize such code. Examples include rendering graphics, serving static websites, or processing a large number of independent data records.
2 Nonembarrassingly parallel—Any parallel problem with interdependency between processes requires communication and synchronization (figure 1.4, right). Most partial differential equation solvers are nonembarrassingly parallel. The relative amount of communication versus computation dictates how well a parallel problem can scale. The objective for most physical solvers is thus to minimize communication and maximize computation. Examples are weather prediction, molecular dynamics, and any other physical process that’s described by partial differential equations. This class of parallel problems is more difficult and, in my opinion, more interesting!

16

CHAPTER 1 Introducing Fortran

Embarassingly parallel

Input

x1

x2

Nonembarassingly parallel

Input

x = (x1, x2)

CPU 1

CPU 2

CPU 1

CPU 2

Output

y1

y2

Output

y = (y1, y2)

Figure 1.4 An embarrassingly parallel problem (left) versus a nonembarrassingly parallel problem (right). In both cases, the CPUs receive input (x1, x2) and process it to produce output (y1, y2). In an embarrassingly parallel problem, x1 and x2 can be processed independently of each other. Furthermore, both input and output data are local in memory to each CPU, indicated by solid arrows. In a nonembarrassingly parallel problem, input data is not always local in memory to each CPU and has to be distributed through the network, indicated by dashed arrows. In addition, there may be data interdependency between CPUs during the computation step, which requires synchronization (horizontal dashed arrow).

Why is it called embarrassingly parallel?
It refers to overabundance, as in an embarrassment of riches. It’s the kind of problem that you want to have. The term is attributed to Cleve Moler, inventor of MATLAB and one of the authors of EISPACK and LINPACK, Fortran libraries for numerical computing. LINPACK is still used to benchmark the fastest supercomputers in the world.
Because our application domain deals mainly with nonembarrassingly parallel problems, we’ll focus on implementing parallel data communication in a clean, expressive, and minimal way. This will involve both distributing the input data among processors (downward dashed arrows in figure 1.4) and communicating data between them (horizontal dashed arrow in figure 1.4).
Parallel Fortran programming in the past has been done either using the OpenMP directives for shared-memory computers only, or with the Message Passing Interface (MPI) for both shared and distributed memory computers. Differences between sharedmemory (SM) and distributed-memory (DM) systems are illustrated in figure 1.5. The main advantage of SM systems is very low latency in communication between processes. However, there’s a limit to the number of processing cores you can have in an SM system. Since OpenMP was designed for SM parallel programming exclusively, we’ll focus on MPI for our specific example.

Think parallel!

17

Shared memory

Distributed memory

RAM

CPU 1

CPU 2

CPU 3

CPU 4

CPU 1 CPU 3

CPU 2 Network
CPU 4

Figure 1.5 A shared-memory system (left) versus a distributedmemory system (right). In a shared-memory system, processors have access to common memory (RAM). In a distributed-memory system, each processor has its own memory, and they exchange data through a network, indicated by dashed lines. The distributed-memory system is most commonly composed of multicore shared-memory systems.

OpenMP versus MPI
OpenMP is a set of directives that allows the programmer to indicate to the compiler the sections of code that are to be parallelized. OpenMP is implemented by most Fortran compilers and doesn’t require external libraries. However, OpenMP is limited to shared-memory machines.
Message Passing Interface (MPI) is a standardized specification for portable message passing (copying data) between arbitrary remote processes. This means that MPI can be used for multithreading on a single core, multicore processing on a shared-memory machine, or distributed-memory programming across networks. MPI implementations typically provide interfaces for C, C++, and Fortran. MPI is often described as the assembly language of parallel programming, illustrating the fact that most MPI operations are low-level.
Although still ubiquitous in HPC, OpenMP and MPI are specific approaches to parallel computing that can be more elegantly expressed with coarrays. This book will focus on coarrays exclusively for parallel programming.

1.7.1

Copying an array from one processor to another
In most scientific and engineering parallel applications, there’s data dependency between processes. Typically, a two-dimensional array is decomposed into tiles like a chessboard, and the workload of each tile is assigned to a processor. Each tile has its own data in memory that’s local to its processor. To illustrate the simplest case of parallel programming in a real-world scenario, let’s take the following meteorological situation for example. Suppose that the data consists of two variables: wind and air

18

CHAPTER 1 Introducing Fortran

temperature. Wind is blowing from one tile with a lower temperature (cold tile) toward another tile with a higher temperature (warm tile). If we were to solve how the temperature evolves over time, the warm tile would need to know what temperature is coming in with the wind from the cold tile. Because this is not known a priori (remember that the data is local to each tile), we need to copy the data from the cold tile into the memory that belongs to the warm tile. On the lowest level, this is done by explicitly copying the data from one processor to another. When the copy is finished, the processors can continue with the remaining computations. Copying one or more values from one process to another is the most common operation done in parallel programming (figure 1.6).

CPU 1

CPU 2

12345 Array

00000 Array

Figure 1.6 An illustration of a remote array copy between two CPUs. Numbers inside the boxes indicate initial array values. Our goal is to copy values of array from CPU 1 to CPU 2.

Let’s focus on just this one operation. Our goal is to do the following:
1 Initialize array on each process—[1, 2, 3, 4, 5] on CPU 1 and all zeros on CPU 2.
2 Copy values of array from CPU 1 to CPU 2. 3 Print the new values of array on CPU 2. These should be [1, 2, 3, 4, 5].
I’ll show you two example solutions to this problem. One is the traditional approach using an external library like MPI. Unless you’re a somewhat experienced Fortran programmer, don’t try to understand every detail in this example. I merely want to demonstrate how complicated and verbose it is. Then, I’ll show you the solution using coarrays. In contrast to MPI, coarrays use an array indexing-like syntax to copy remote data between parallel processes.
MPI: THE TRADITIONAL WAY TO DO PARALLEL PROGRAMMING As noted before, MPI is often described as the assembly language of parallel programming, and, indeed, that was its developers’ original intention. MPI was meant to be implemented by compiler developers to enable natively parallel programming languages. Over the past three decades, however, application developers have been faster at adopting MPI directly in their programs, and it has become, for better or worse, a de facto standard tool for parallel programming in Fortran, C, and C++. As a result, most HPC applications today rely on low-level MPI calls.

Think parallel!

19

The following Fortran program sends data from one process to another using MPI.

Listing 1.2 Copying an array from one process to another using MPI

program array_copy_mpi
use mpi implicit none

Accesses MPI subroutines and the mpi_comm_world global variable from a module

integer :: ierr, nproc, procsize, request integer :: stat(mpi_status_size)

Initializes MPI

integer :: array(5) = 0 integer, parameter :: sender = 0, receiver = 1
call mpi_init(ierr) call mpi_comm_rank(mpi_comm_world, nproc, ierr) call mpi_comm_size(mpi_comm_world, procsize, ierr)

Which processor number am I?
How many processes are there?

if (procsize /= 2) then call mpi_finalize(ierr) stop 'Error: This program must be run & on 2 parallel processes'
end if

Shuts down MPI and stops the program if we’re not running on two processors

Initializes array on sending process
Waits here for both
processes
Receiver waits for
the message

if (nproc == sender) array = [1, 2, 3, 4, 5]

print '(a,i1,a,5(4x,i2))', 'array on proc ', nproc, & ' before copy:', array

Prints text to screen with specific formatting

call mpi_barrier(mpi_comm_world, ierr)

if (nproc == sender) then call mpi_isend(array, size(array), mpi_int, & receiver, 1, mpi_comm_world, request, ierr)
else if (nproc == receiver) then call mpi_irecv(array, size(array), mpi_int, & sender, 1, mpi_comm_world, request, ierr) call mpi_wait(request, stat, ierr)
end if

Sender posts a nonblocking send
Receiver posts a nonblocking receive

print '(a,i1,a,5(4x,i2))', 'array on proc ', nproc, & ' after copy: ', array

call mpi_finalize(ierr)

Finalizes MPI at the end of the program

end program array_copy_mpi

Running this program on two processors outputs the following:

array on proc 0 before copy:

1

2

3

4

5

array on proc 1 before copy:

0

0

0

0

0

array on proc 0 after copy:

1

2

3

4

5

array on proc 1 after copy:

1

2

3

4

5

20

CHAPTER 1 Introducing Fortran

This confirms that our program did what we wanted: copied the array from process 0 to process 1.

Compiling and running the examples
Don’t worry about building and running these examples yourself for now. At the start of the next chapter, I’ll ask you to set up the complete compute environment for working with examples in this book, including this example. If you prefer, you can follow the instructions in appendix A now instead of waiting.

ENTER FORTRAN COARRAYS Coarrays are the main data structure for native parallel programming in Fortran. Originally developed by Robert Numrich and John Reid in the 1990s as an extension for the Cray Fortran compiler, coarrays have been introduced into the standard starting with the 2008 release. Coarrays are much like arrays, as the name implies, except that their elements are distributed along the axis of parallel processes (cores or threads). As such, they provide an intuitive way to copy data between remote processes.
The following listing shows the coarray version of our array copy example.
Listing 1.3 Copying an array from one process to another using coarrays
program array_copy_caf

implicit none integer :: array(5)[*] = 0

Declares and initializes an integer coarray

integer, parameter :: sender = 1, receiver = 2

Throws an error if we’re not running on two processes

if (num_images() /= 2) &

stop 'Error: This program must be run on 2 parallel processes'

if (this_image() == sender) array = [1, 2, 3, 4, 5]

print '(a,i2,a,5(4x,i2))', 'array on proc ', this_image(), &

' before copy:', array sync all

Waits here for all images; equivalent to mpi_barrier()

Initializes array in sender

if (this_image() == receiver) & array(:) = array(:)[sender]

Nonblocking copy from sending image to receiving image

print '(a,i1,a,5(4x,i2))', 'array on proc ', this_image(), & ' after copy: ', array

end program array_copy_caf

Think parallel!

21

The output of the program is the same as in the MPI variant:

array on proc 1 before copy:

1

2

3

4

5

array on proc 2 before copy:

0

0

0

0

0

array on proc 1 after copy:

1

2

3

4

5

array on proc 2 after copy:

1

2

3

4

5

These two programs are thus semantically the same. Let’s look at the key differences in the code:
 The number of lines of code (LOC) dropped from 27 in the MPI example to 14 in the coarray example. That’s almost a factor of 2 decrease. However, if we look specifically for MPI-related boilerplate code, we can count 15 lines of such code. Compare this to two lines of code related to coarrays! As debugging time is roughly proportional to the LOC, we see how coarrays can be more cost-effective for developing parallel Fortran apps.
 The core of the data copy in the MPI example is quite verbose for such a simple operation
if (nproc == 0) then call mpi_isend(array, size(array), mpi_int, receiver, 1, & mpi_comm_world, request, ierr)
else if (nproc == 1) then call mpi_irecv(array, size(array), mpi_int, sender, 1, & mpi_comm_world, request, ierr) call mpi_wait(request, stat, ierr)
end if

compared to the intuitive array-indexing and assignment syntax of coarrays:

if (this_image() == receiver) array(:) = array(:)[sender]
 Finally, MPI needs to be initialized and finalized using mpi_init() and mpi_ finalize() subroutines. Coarrays need no such code. This one is a minor but welcome improvement.

Parallel process indexing
Did you notice that our parallel processes were indexed 0 and 1 in the MPI example and 1 and 2 in the coarray example? MPI is implemented in C, in which array indices begin at 0. In contrast, coarray images start at 1 by default.

As we saw in this example, both MPI and coarrays can be used effectively to copy data between parallel processes. However, MPI code is low-level and verbose, and would soon become tedious and error-prone as your app grows in size and complexity. Coarrays offer an intuitive syntax analogous to the array operations. Furthermore, with MPI, you tell the compiler what to do; with coarrays, you tell the compiler what you

22

CHAPTER 1 Introducing Fortran

want, and let it decide how best to do it. This lifts a big load of responsibility off your shoulders and lets you focus on your application. I hope this convinces you that Fortran coarrays are the way to go for expressive and intuitive data copy between parallel processes.

A partitioned global address space language
Fortran is a partitioned global address space (PGAS) language. In a nutshell, PGAS abstracts the distributed-memory space and allows you to do the following:
 View the memory layout as a shared-memory space—This will give you a tremendous boost in productivity and ease of programming when designing parallel algorithms. When performing data copy, you won’t need to translate or transform array indices from one image to another. Memory that belongs to remote images will appear as local, and you’ll be able to express your algorithms in such a way.
 Exploit the locality of reference—You can design and code your parallel algorithms without foresight about whether a subsection of memory is local to the current image or not. If it is, the compiler will use that information to its advantage. If not, the most efficient data copy pattern available will be performed.
PGAS allows you to use one image to initiate a data copy between two remote images:
if (this_image() == 1) array(:)[7] = array(:)[8]
The if statement ensures that the assignment executes only on image 1. However, the indices inside the square brackets refer to images 7 and 8. Image 1 will thus asynchronously request an array copy from image 8 to image 7. From our point of view, the indices inside the square brackets can be treated just like any other array elements that are local in memory. In practice, these images could be mapped to different cores on the same shared-memory computer, across the server room, or even around the world.

1.8 Running example: A parallel tsunami simulator
Learning happens by doing rather than reading, especially when we’re immersed in a longer project. Lessons in this book are thus framed around developing your own, minimal and yet complete, tsunami simulator.

1.8.1

Why tsunami simulator?
A tsunami is a sequence of long water waves that are triggered by a displacement in a large body of water. This typically occurs because of earthquakes, underwater volcanoes, or landslides. Once generated, a tsunami propagates radially outward across the ocean surface. It grows in height and steepness as it enters shallow waters. A tsunami simulator is a good running example for this book because tsunamis are the following:

Running example: A parallel tsunami simulator

23

 Fun—Speaking strictly as a scientist here! A tsunami is a process that’s fun to watch and play with in a numerical sandbox.
 Dangerous—Tsunamis are a great threat to low-lying and heavily populated coastal areas. There’s a need to better understand and predict them.
 Simple math—They can be simulated using a minimal set of equations—shallow water equations (SWEs). This will help us not get bogged down by the math and focus on implementation instead.
 Parallelizable—They involve a physical process that’s suitable for teaching parallel programming, especially considering that it’s a nonembarrassingly parallel problem. To make it work, we’ll carefully design data copy patterns between images.
To simulate tsunamis, we’ll write a solver for the shallow water system of equations.

1.8.2

Shallow water equations
Shallow water equations are a simple system of equations derived from Navier-Stokes equations. They are also known as the Saint-Venant equations, after the French engineer and mathematician A. J. C. Barre de Saint-Venant, who derived them in pursuit of his interest in hydraulic engineering and open-channel flows. SWEs are powerful because they can reproduce many observed motions in the atmosphere and the ocean:
 Large-scale weather, such as cyclones and anticyclones  Western boundary currents, such as the Gulf Stream in the Atlantic and the
Kuroshio in the Pacific  Long gravity waves, such as tsunamis and tidal bores  Watershed from rainfall and snow melt over land  Wind-generated (surf) waves  Ripples in a pond
This system consists of only a few terms, as shown in figure 1.7.

Velocity

Pressure

tendency Advection gradient

Water height tendency

Water height divergence

Figure 1.7 Shallow water equations. The top equation is the momentum (velocity) conservation law, and the bottom is the mass (water level) conservation law. u is the 2-d velocity vector, g is the gravitational acceleration, h is the water elevation, H is the unperturbed water depth, and t is time. The “nabla” symbol (upside-down triangle) is a vector differentiation operator.

24

CHAPTER 1 Introducing Fortran

What’s the physical interpretation of this system? The top equation states that where there’s slope along the water surface, water will accelerate and move toward a region of lower water level because of the pressure gradient. The advection term is nonlinear and causes chaotic behavior in fluids (turbulence). The bottom equation states that where there’s convergence (water coming together), the water level will increase. This is because water has to go somewhere, and it’s why we also call it conservation of mass. Similarly, if water is diverging, its level will decrease in response.

Comfortable with math?
If you’re experienced with calculus and partial differential equations, great! There’s more for you in appendix B. Otherwise, don’t worry! This book won’t dwell on math much more than this; it will focus on programming.

Shallow water equations are dear to me because I first learned Fortran programming by modeling these equations in my undergraduate meteorology program at the University of Belgrade. In a way, I go back to my roots as I write this book. Despite my Fortran code looking (and working) much differently now than back then, I still find this example an ideal case study for teaching parallel Fortran programming. I hope you enjoy the process as much as I did.

1.8.3

What we want our app to do
Let’s narrow down on the specification for our tsunami simulator:
 Parallel—The model will scale to hundreds of processors with nothing but pure Fortran code. This is not only important for speeding up the program and reducing compute time, but also for enabling very large simulations that otherwise wouldn’t fit into the memory of a single computer. With most modern laptops having at least four cores, you should be able to enjoy the fruits of your (parallel programming) labor.
 Extensible—Physics terms can be easily formulated and added to the solver. This is important for the general usability of the model. If we can design our computational kernel in the form of reusable classes and functions, we can easily add new physics terms as functional, parallel operators, following the approach by Damian Rouson (http://mng.bz/vxPq). This way, the technical implementation is abstracted inside these functions, and on a high level we’d program our equations much like we’d write them on a blackboard.
 Software library—This will provide a reusable set of classes and functions that can be used to build other parallel models.
 Documented—All software should be useful, and no user should have to guess what the author of the program intended. We’ll write and document our app in such way that the code can be easily read and understood.

Summary

25

 Discoverable online—Writing a program just for yourself is great for learning and discovery. However, software becomes truly useful when you can share it with others to solve their problems. The tsunami simulator and other projects developed in this book are all online at https://github.com/modern-fortran. Feel free to explore them and poke around, and we’ll dive together into the details as we work through this book.
By working through this book chapter by chapter, you’ll gain the experience of developing a fully featured parallel app from scratch. If it’s your first software project, I hope it excites your inner software developer and inspires you to go make something on your own. We’ll start the next chapter by setting up the development environment so that you can compile and run the minimal working version of the tsunami simulator.

Visualizing tsunami output
As we build and run our simulator, we’ll mostly look at raw numbers and time step counts that it logs to the terminal. However, it’s both helpful and satisfying to be able to visualize the output of the model. We’ll do so every time we add a new piece to the simulator, which makes the solution different and more interesting. I provide Python scripts in the GitHub repository of the project so you can visualize the output yourself. Although it’s possible to create high-quality graphics directly from Fortran, it’s not as easy to do as it is with Python.

1.9 Further reading
 Fortran website: https://fortran-lang.org  The history of Fortran on Wikipedia: https://en.wikipedia.org/wiki/Fortran  Partitioned global address space: http://mng.bz/4A6g  Companion blog to this book: https://medium.com/modern-fortran
Summary
 Fortran is the oldest high-level programming language still in use today.  It’s the dominant language used for many applications in science and engi-
neering.  Fortran isn’t suitable for programming video games or web browsers but excels
at numerical, parallel computation over large multidimensional arrays.  It’s the only standardized natively parallel programming language.  Coarrays provide a cleaner and more expressive syntax for parallel data exchange
compared to traditional Message Passing Interface (MPI) programming.  Fortran compilers and libraries are mature and battle-tested.

Getting started: Minimal working app
This chapter covers
 Compiling and running your first Fortran program  Data types, declaration, arithmetic, and
control flow  Building and running your first simulation app
In this chapter, we’ll implement the minimal working version of the tsunami simulator. For simplicity, we’ll start by simulating the movement of water in space due to background flow, without changing its shape. This problem is sufficiently complex to introduce basic elements of Fortran: numeric data types, declaration, arithmetic expressions and assignment, and control flow. Once we successfully simulate the movement of an object in this chapter, we’ll refactor the code to add other physics processes in chapters 3 and 4, which will allow the simulated water to flow more realistically. Implementing the other processes will be easier because we’ll be able to reuse much of the code that we’ll write in this chapter.
We’ll start off by compiling, linking, and running your first Fortran program. Then I’ll introduce the physical problem that we want to solve and show you how to express it in the form of a computer program. We’ll then dive into the essential elements of Fortran: data types, declaration, arithmetic, and control flow. At the
26

Compiling and running your first program

27

end of the chapter, you’ll have the working knowledge to write basic, yet useful, Fortran programs.

2.1 Compiling and running your first program
Let’s start by creating, compiling, and running your first Fortran program. I assume you’ve already installed the GNU Fortran compiler (gfortran) on your system. If you haven’t yet, follow the directions in appendix A to get yourself set up.
When you have the compiler installed, test it by compiling and running your first Fortran program, as shown in the following listing.

Listing 2.1 Your first Fortran program: hello.f90

program hello print *, 'Hello world!'
end program hello
Ends the program

Begins the program and gives it a name
Prints a short greeting to the terminal

This program does only one thing—it prints a short greeting message to the terminal— as is common for the first example in most programming books. Let’s save it in a file called hello.f 90. Compiling is as simple as passing the source file to the compiler and, optionally, specifying the name of the output (-o) executable:

gfortran hello.f90 -o hello

If you don’t specify the name of the output file with -o, the name of the executable defaults to a.out.
Running the program produces the expected output:

./hello Hello world!

Runs the program by entering the executable name
The output of the program in the terminal

That’s it—you wrote and compiled your first Fortran program! Let’s take a look at what happens here under the hood. Building a program typically involves two steps:

1 Compiling—The compiler parses the source code in a high-level language (here, Fortran) and outputs a corresponding set of machine instructions. In our case, gfortran will read a Fortran source file with a .f90 suffix and output a corresponding binary object file with a .o suffix. Other suffixes for source files, like .f, .f03, or .f08, are acceptable by most compilers; however, I recommend sticking with .f90 for consistency.
2 Linking —Binary object files (.o), which are the result of the compilation step, aren’t executable on their own. The linker, typically invoked by the compiler under the hood, puts binary object files together into one or more executable programs.

28

CHAPTER 2 Getting started: Minimal working app

To build our first program, we issued only one command, gfortran hello.f90 -o hello, meaning there weren’t two separate steps for compiling and linking. This is sufficient when the whole program is contained in a single file, and compiling and linking steps are combined together in one command. That command is equivalent to the following listing.

Listing 2.2 Compilation and linking as separate steps

gfortran -c hello.f90 gfortran hello.o -o hello

Compiles only, no linking
Links the object to an executable

In this snippet, the compiler option -c means compile only, do not link. This procedure is necessary whenever we need to compile multiple source files before linking them into a single program. As your app or library grows in size, you’ll find that splitting it into multiple files will make it easier to organize and further develop.
I illustrate the build sequence in figure 2.1.

hello.f 90 gfortran -c hello.f 90
hello.o gfortran hello.o -o hello
hello

Source code

Compiling step Binary object Linking step Binary executable

Figure 2.1 Compiling and linking steps that take the input source code and generate binary object and executable files. The source file, hello.f90, is passed to the compiler, which outputs a binary object file, hello.o. The object file is then passed to the linker, which outputs a binary executable file, hello. The linker is implicitly included in the compiler command (gfortran).

The GNU Fortran compiler can take many other options that control language rules, warning messages, optimization, and debugging. I encourage you to go ahead and skim through the manual. You can access it by typing man gfortran on the command line. If the manual pages aren’t available on your system, you can always access the most recent documentation for gfortran at https://gcc.gnu.org/onlinedocs/gfortran.
2.2 Simulating the motion of an object
Near the end of the previous chapter, I introduced the shallow water system of equations, which we’ll work to solve over the course of this book to produce a realistic simulation of a tsunami. Here we’ll start implementing the simulator from scratch, both in terms of the source code and the physics that we’ll simulate with it. The first process

Simulating the motion of an object

29

that we’ll simulate is the motion of an object due to background flow. In physics, we call this linear advection. Advection means movement through space, and the linear property implies that the background flow is independent from the shape and position of the object. Don’t worry if you’re not a math or physics whiz and this sounds daunting! In the following subsections, I’ll illustrate how advection works and show how you can calculate it without having to understand all the math behind it.

From calculus to code
If you want to delve deeper into the math behind this problem, head over to appendix B. There, I explain the gradient, which is the key concept behind advection, and how to express it in computer code using finite differences. This step is important, as it forms the foundation to express all other terms in the shallow water equations. Otherwise, if you want to skip the math and jump straight to programming, carry on!

In the next subsection, I’ll state the problem and set some requirements for our app. Then, I’ll guide you through an illustrative example of advection and show how you can calculate it yourself without writing any code. Finally, we’ll work together to implement the first version of our app in the remainder of this chapter.

2.2.1

What should our app do?
At this stage, we’ll simulate only the movement of an object (or fluid) due to background flow. This will provide the foundation for other physical processes that we’ll add to the solver in later chapters. Simulating only one process for now will guide the design of our program structure and its elements: declaration and initialization of data, iterating the simulation forward in time, and writing the results to the terminal. I sketched the result that we expect in figure 2.2.

Initial time

Moving an object forward in space Background ﬂow

Future time

Height

Distance
Figure 2.2 Advecting an object in space from left to right. The initial state is on the left. The object is advected from left to right by a background flow and after some time arrives at its final position on the right.

30

CHAPTER 2 Getting started: Minimal working app

Note that the advected object can be any quantity, such as water height, temperature, or concentration of a pollutant. For now, we’ll just refer to it as the object for simplicity. The shape of the object is also arbitrary—it can be any continuous or discontinuous function. I chose a smooth bulge for convenience. At the initial time, the object is located near the left edge of the domain. Our goal is to simulate the movement of the object due to background flow and record the state of the object at some future time. Internally, our app will need to perform the following steps:
1 Initialize—Define the data structure that will keep the state of the object in computer memory, and initialize its value.
2 Simulate—This step will calculate how the position of the object will change over time. At this stage, we expect it only to move from left to right, without change in shape. The simulation is done over many discrete time steps and makes up for most of the compute time spent by the program.
3 Output—At each time step, we’ll record the state of the object so that we can visualize it with an external program.
As you can guess, the core of our program will revolve around the simulation step. How do we go about simulating the movement of the object? Before writing any code, we need to understand how advection works.

2.2.2

What is advection?
Wikipedia defines advection as “the transport of a substance or quantity by bulk motion.” Advection is a fundamental process in physics, engineering, and earth sciences. It governs how a solid object or a fluid moves in space because of background flow. When a swimmer is swimming against the current, they’re advected by the current, and their speed relative to the ground is lower than if there were no current at all. Advection is also why we find Saharan dust in the atmosphere over the Caribbean, Brazil, or northern Europe, or why garbage patches converge in the middle of ocean basins.
I mentioned earlier that in this chapter we’ll deal only with linear advection. The word linear here means that the background flow can be assumed to be constant, and not changing because of interactions with the advected object itself. As shown in figure 2.2, the object is moving with constant speed that’s independent from the object itself. In other words, the shape and position of the object do not influence the background flow. In the real world, however, this is almost never the case! Nonlinear advection of velocity is what creates turbulence. Small vortices in a stream, occasional bumps on commercial flights, and marbled texture that we see in photographs of Jupiter’s atmosphere are all examples of turbulence caused by nonlinear advection on different spatial scales. We’ll save the nonlinear advection for chapter 4; here, we’ll focus only on the linear part.
To better understand how advection works, consider a cold front moving across the southeast United States (figure 2.3). A cold front is a large-scale weather phenomenon

Implementing the minimal working app

31

Atlanta Cold
12 °C 18 °C 24 °C

Warm Miami

Figure 2.3 An illustration of a cold front moving from Atlanta toward Miami. Curved lines are contours of constant temperature. The dashed arrow shows the direction of front propagation.

associated with mid-latitude cyclones. It typically moves from northwest to southeast in the Northern Hemisphere (southwest to northeast in the Southern Hemisphere) and brings cool and dry air in its wake. Where I live in South Florida, passages of cold fronts are eagerly anticipated because they bring refreshingly cool and dry air from the north.
Now I have a little exercise for you. Consider the following:
 The temperature is 12 °C in Atlanta and 24 °C in Miami.  The distance between Atlanta and Miami is 960 kilometers.  The front is moving toward Miami at a constant speed of 20 kilometers per
hour (km/h).
Assume there are no other processes at play, and the change of temperature is uniform in space:
1 What is the temperature gradient between Atlanta and Miami? Gradient is the difference of a quantity (here, temperature) between two locations, divided by the distance between them. In this case, the temperature gradient has units of °C/km.
2 How many hours will it take for the temperature in Miami to fall to 12 °C? 3 Finally, what will the temperature in Miami be after 24 hours? How did you
arrive at this result?
Try to solve this problem with pen and paper. After you’ve worked through the exercise, you’ll have solved the linear advection equation, even if you didn’t realize it. The advection equation predicts the change of any quantity due to the spatial gradient of that quantity and the background flow. We’ll do the exact same calculation to predict the motion of the object in our simulator. You can find the solution to this exercise in the “Answer key” section near the end of this chapter.
2.3 Implementing the minimal working app
Having set the problem to solve, we’ll soon be able to dive into Fortran coding. But first we’ll go over the implementation strategy (you should always have one) in the next subsection. Then, we’ll go over the core elements of the language and apply them to implement the first version of the tsunami simulator.

32

CHAPTER 2 Getting started: Minimal working app

2.3.1

Implementation strategy
Before we do any coding, it will be helpful to sketch out our tentative strategy for implementing the first version of our app:
1 Define the main program. This will define the program name and scope. The main program unit provides a skeleton to hold the declaration of data and the executable code, such as arithmetic, loops, and so on.
2 Declare and initialize variables and constants. We need to declare all variables and constants that we intend to use in our program: – Integer counters i and n, for space and time, respectively, and corresponding loop dimensions grid_size and num_time_steps. The spatial dimension size, grid_size, will determine the length of the arrays, whereas the time dimension size, num_time_steps, will determine for how many iterations we’ll calculate the solution. – Physical constants for background flow speed, c, time step, dt, and grid spacing, dx. – Arrays with real values for water height, h, and its finite difference, dh, such that dh(i) = h(i) - h(i-1) for each i. The array dh is necessary for computing the solution without keeping multiple time levels in memory.
3 Calculate the equation solution for a set number of time steps. This step consists of three distinct parts: – Loop for a set number of time steps (num_time_steps). – At each step, calculate the new value for water height, h, based on the value from the previous time step. – Because our domain is limited in size (grid_size), we need to define the boundary conditions. What happens to the object when it reaches the far right edge of the domain (figure 2.4)?

What happens when the object leaves the domain?

Initial time

Background ﬂow

Future time
?

Height

Distance
Figure 2.4 Boundary conditions determine what happens to the object when it reaches an edge of the domain. Should it just leave? Reflect back into the domain like a ball bouncing off a wall? Or perhaps cycle and reappear on the left side?

Implementing the minimal working app

33

We have a few choices here. The object could be absorbed by the boundary and completely leave the domain without a trace, or it could be reflected back into the domain like a ball bouncing off a wall. Another option is a periodic (or cyclical) boundary condition that connects the right and left edges of the domain. In this case, the object would pass through on the right and reappear on the left. This is a common choice in global atmosphere and ocean prediction because of how our planet is represented in the computational domain. If you go far enough east, you end up in the west! For this reason, we’ll implement the periodic boundary condition in our app.
4 Print the solution to the terminal at each step. To start, we don’t need fancy or specially formatted output. Let’s just output our solution in a default text format to the screen. If we want to store the output in a file for analysis or plotting, we can easily direct the output into a file.
Sound good? Let’s dive in and tackle these one at a time.

2.3.2

Defining the main program
The main program is the fundamental program unit in Fortran. It allows you to assign a name to your program and defines the program scope, as shown in the following listing.

Listing 2.3 Defining the program unit and scope

program tsunami end program tsunami

Begins the new program and gives it a name
Ends the program

Assigning a name to a program doesn’t do anything in practice, but it can help you stay organized when you start working with dozens of different programs.
Compiling and linking a main program source file results in an executable file that you can invoke from the host operating system (see figure 2.1). You can’t invoke a main program from other program units.

What other program units are there?
Here, I give you a sneak peek of what’s coming in chapters 3 and 4. Different program units can together form an executable program or a nonexecutable library:
 Main program —Top-level unit that can be invoked only from the operating system
 Function—An executable subprogram that is invoked from expressions and always returns a single result
 Subroutine—An executable subprogram that can modify multiple arguments in-place but can’t be used in expressions

34

CHAPTER 2 Getting started: Minimal working app

(continued)  Module—A nonexecutable collection of variable, function, and subroutine definitions  Submodule—Extends an existing module and is used for defining variable and procedure definitions that only that module can access; useful for more complex apps and libraries
For now, we can work with only the main program. We’ll dive deep into functions and subroutines in chapter 3, and modules in chapter 4.

The program statement is not mandatory. It can be useful to omit it for short test programs. However, it’s good practice to include it and pair it with a matching end program statement. Technically, end is the only required statement for any Fortran program. That statement also makes the shortest possible, though useless, Fortran program.

TIP Always pair the program statement with a matching end program statement.

2.3.3

Declaring and initializing variables
Explicit is better than implicit.
—Tim Peters
The first part of any program unit is the declaration section. Fortran employs a static, manifest, strong typing system:
 Static—Every variable has a data type at compile time, and that type remains the same throughout the life of the program.
 Manifest—All variables must be explicitly declared in the declaration section before their use. An exception and caveat is implicit typing, described in the sidebar.
 Strong—Variables must be type-compatible when they’re passed between a program and functions or subroutines.

Implicit typing
Fortran has a historical feature called implicit typing, which allows variable types to be inferred by the compiler based on the first letter of the variable. Yes, you read that right.
Implicit typing comes from the early days of Fortran (ahem, FORTRAN), before type declarations were introduced to the language. Any variable that began with I, J, K, L, M, or N was an integer, and it was a real (floating point) otherwise. FORTRAN 66 introduced data types, and FORTRAN 77 introduced the IMPLICIT statement to override the default implicit typing rules. It wasn’t until Fortran 90 that the language allowed completely disabling the implicit typing behavior by using the statement implicit none before the declaration.
The implicit none statement will instruct the compiler to report an error if you try to use a variable that hasn’t been declared. Always use implicit none!

Implementing the minimal working app

35

Intrinsic types are defined by the language standard and are immediately available for use. Fortran has three numeric types:
 integer—Whole numbers, such as 42 or -17  real—Floating point numbers, such as 3.141 or 1.82e4  complex—A pair of numbers: one for the real part and one for the imaginary
part of the complex number; for example, (0.12, -1.33)
Numeric types also come in different kinds. A Fortran kind refers to the memory size that’s reserved for a variable. It determines the permissible range of values and, in the case of real and complex numbers, the precision. In general, higher integer kinds allow a wider range of values. Higher real and complex kinds yield a higher allowed range and a higher precision of values. You’ll learn more about numeric type kinds in chapter 4.
Besides the numerical intrinsic types, Fortran also has the logical type to represent Boolean (true or false) states and character for text data. These five intrinsic types (integer, real, complex, logical, and character) are the basis for all variables in Fortran programs. You also can use them to create compound types of any complexity, called derived types, which are analogous to struct in C and class in Python. We’ll dive deep into derived types in chapter 8.

TIP Always use implicit none. This statement enforces explicit declaration of all variables, which both serves as documentation for the programmer and allows the compiler to find and report type errors for you.

2.3.4

Numeric data types
Fortran provides three numerical data types out of the box: integer, real, and complex.
INTEGER NUMBERS The integer is the simplest numeric type in Fortran. Here are some examples of integer literals:

0 1 42 100 -500 +1234567

You declare one or more integers like this:

integer :: i, n

This statement instructs the compiler to reserve the space in memory for integer variables i and n. It’s made of the type statement (integer) on the left, double colons (::) in the middle, and a list of variables separated by commas.
General rules for integers:
 Integers are always signed—they can be both negative and positive, as well as zero.
 They have a limited range that’s determined by their type kind. Larger type kinds result in a wider range.

36

CHAPTER 2 Getting started: Minimal working app

 Exceeding the permissible range of a variable results in an overflow. In that event, the value of the variable will wrap around its range limits.
 The default integer size in memory isn’t defined by the Fortran standard and is system dependent. However, on most systems, the default integer size is 4 bytes.
REAL NUMBERS Real numbers, also known as floating-point numbers, describe any number that has a value along a continuous (nondiscrete) axis. Here are some examples of real numbers:

0.0 1.000 42. 3.14159256 -5e2 +1.234567e5

The first four of these are intuitive enough—the decimal point separates the whole part of the number on the left and the fractional part of the number on the right. The last two may seem strange, as they’re written using exponential notation. They consist of an integer or real number on the left side of the character e, and an integer on its right side that denotes the decimal exponent. -5e2 thus corresponds to –5 × 102, and +1.234567e5 corresponds to 1.234567 × 105. For positive numbers, the unary plus symbol is optional. We’ll talk more about formatting real numbers in chapter 6.

Be mindful about the decimal point!
When writing literal constants, there’s a fine line between what the compiler will understand as an integer or a real. A single period after the number makes the difference. For example, 42 is an integer, but 42. is a real. This is the same behavior as in C or Python.

We declare real numbers using the keyword real:
real :: x
This declaration statement is analogous to the one for integers, except for the type and variable names. COMPLEX NUMBERS A complex number is simply a pair of real numbers, one for the real component and one for the imaginary component. They’re declared and initialized like this:
complex :: c = (1.1, 0.8)
The complex intrinsic type was introduced into Fortran to make arithmetic with complex numbers easier to program. Depending on your application, you’ll either use them often or not at all.

Implementing the minimal working app

37

2.3.5

Declaring the data to use in our app
Now that you have an idea of how to declare a variable of a specific numeric type, let’s declare some variables, constants, and arrays that we’ll use in the tsunami simulator.
DECLARING VARIABLES What kinds of variables will we need? As a reminder, based on our implementation strategy in section 2.3.1, we’ll need the following:
 Spatial array size, grid_size, and number of time steps, num_time_steps  Physical constants, such as time step, dt, grid size, dx, and background flow
speed, c  One-dimensional arrays to carry the values of water height, h, and its difference
in space, dh  An integer index, i, to reference individual array elements, h(i), and another
to loop through time, n
Since we need to first specify grid_size before we declare the array h, let’s first declare scalar variables and constants, and declare the arrays afterward, as shown in the following listing.

Listing 2.4 Declaring and initializing integer and real variables

program tsunami implicit none

Enforces explicit typing

integer :: i, n integer :: grid_size integer :: num_time_steps

Integer declarations

real :: dt ! time step [s] real :: dx ! grid spacing [m] real :: c ! phase speed [m/s]

Real (floating point) declarations

grid_size = 100 num_time_steps = 100

Initializes integers

dt = 1. dx = 1. c = 1.

Initializes reals

end program tsunami

The declaration section begins with implicit none and ends immediately before the first executable line of code (grid_size = 100). All declarations are done in one place, at the beginning of the program.

38

CHAPTER 2 Getting started: Minimal working app

Commenting the code
Fortran comments begin with an exclamation mark (!). They can start at the beginning of the line, or they can follow any valid statement.
Ideally, your code should be clear enough that it doesn’t need any comments. However, this is often not possible, and most programs need at least some comments. Use your best judgment. If the intent isn’t obvious from the code itself, describe it in comments.
Finally, having no comment is always better than having an inaccurate or outdated comment.

For variables that won’t change value for the duration of the program, it’s useful to declare them as constants. This allows the compiler to better optimize the code and prevents you from accidentally changing the value of a constant. We’ll declare constants in the next section.
Our program won’t do much for now, as we only have the data declarations in it. However, feel free to tweak it, recompile it, and, even better, try to break it! See if the compiler complains.
DECLARING CONSTANTS Some of the variables will be constant, and Fortran allows you to declare them as such explicitly. Doing so will help you write correct code by triggering a compiler error if you try to change the value of a constant, and will help the compiler optimize the code. You can declare a constant (also known as immutable) using the parameter attribute, as shown in the following listing.

Listing 2.5 Declaring and initializing constants

integer, parameter :: grid_size = 100 integer, parameter :: num_time_steps = 100
real, parameter :: dt = 1, dx = 1, c = 1
Time step in seconds (s), grid spacing in meters (m), and background flow speed in meters per second (m/s)

Declares grid size as a constant parameter
Ditto for the number of time steps in the simulation

Using the parameter attribute requires us to initialize the variable on the same line.
TIP If the value of a variable is known at compile time and won’t change for the duration of the program, declare it as a parameter.
DECLARING ARRAYS Arrays are among Fortran’s most powerful features. They have several useful properties:
 Contiguous—Array elements are contiguous in memory. Indexing them and performing element-wise arithmetic on arrays is extremely efficient on modern processors.

Implementing the minimal working app

39

 Multidimensional—The Fortran standard allows up to 15 dimensions for arrays. In contrast, in C you have to emulate multiple dimensions by defining arrays of arrays.
 Static or dynamic—Fortran arrays can be static, with dimensions set at compile time, or dynamic, with dimensions set at runtime.
 Whole-array arithmetic—You can use the usual scalar arithmetic operators and mathematical functions with arrays as well.
 Column-major indexing—Fortran arrays use column-major indexing, like MATLAB or R, and unlike C or Python, which are row-major. The first (leftmost) index thus varies fastest. For example, a(1,1), a(2,1), a(3,1), and so on, are consecutive elements of array a. Keep this in mind when you loop over elements of a multidimensional array.
Having declared the integer grid size as a parameter, we can use it to set the size of the array, h, that holds the water height values. You can declare a fixed-length (static) real array using the dimension attribute, and an integer parameter for the array size:

real, dimension(grid_size) :: h

Declares h as a real array with the number of elements equal to grid_size

The argument to dimension is the integer length of the array—in our case, the parameter grid_size.

Shorthand syntax for declaring arrays
You can declare arrays in an even shorter form by omitting the dimension attribute and specifying the array length in parentheses immediately after the array name:
real :: h(grid_size)
Whether you use the dimension attribute or the more concise form is completely up to you. However, to conserve space in code listings, I’ll use the shorthand syntax throughout this book.

As I mentioned earlier, one of Fortran’s strengths is its intrinsic support for multidimensional arrays. You can define an array of up to 15 dimensions by specifying it in the declaration statement, for example:
real, dimension(10, 5, 2) :: h
Here, h is declared as a three-dimensional array, with a total of 100 elements (10 * 5 * 2).

40

CHAPTER 2 Getting started: Minimal working app

How about dynamic arrays?
You may have noticed that in both array declarations, we used integer literals to set the size and shape of the array. However, what if our array dimensions are not known until runtime? Fortran provides excellent support for dynamic arrays, also known as allocatable arrays. When you declare an allocatable array, you only specify the rank (number of dimensions) of the array in the declaration, not the size of the dimensions. Once the size is known, the allocate statement is used to allocate the array with specified dimensions. Allocatable arrays can also be reallocated dynamically any number of times. You’ll see more on allocatable arrays in chapter 5, where we’ll put them to good use in our app.

For now, we need two arrays in our app—one for water height, h, and another for its finite difference, dh:

real :: h(grid_size), dh(grid_size)

Now that we have our data structures declared and ready for action, let’s see what we can do with them.

2.3.6

Branching with an if block
One of the key elements of almost every computer program is taking different execution paths (branches) depending on some criterion. Take, for example, a program that parses a bank account registration form for a customer. If one of the input fields isn’t entered correctly, such as a Social Security number having letters or a name having numbers, the program should alert the user and ask for correct input rather than proceeding. You can define this program behavior using an if block. In our tsunami simulator, for now we’ll use an if block to check the values of the input grid and physics parameters, as shown in the following listing.

Listing 2.6 Checking for values of input parameters
if (grid_size <= 0) stop 'grid_size must be > 0' if (dt <= 0) stop 'time step dt must be > 0' if (dx <= 0) stop 'grid spacing dx must be > 0' if (c <= 0) stop 'background flow speed c must be > 0'

Here, we check the values of the parameters to make sure the program can carry out a meaningful simulation. Specifically, we need a grid with at least one element, although this won’t make for a particularly interesting simulation. We also need time step, grid spacing, and background flow speed to all have positive values. The conditions are stated in parentheses, immediately after if. On the right side, we specify the statement to be executed if the condition in parentheses evaluates as true. In this case, we use the stop statement to abort the program execution and print a helpful message for the user.

Implementing the minimal working app

41

This is only the simplest kind of use case for an if statement. Here’s its general syntax:

if (condition) ...
You can use a more verbose if block if you need to execute multiple statements on a condition, as shown in the following listing.

Listing 2.7 General syntax of an if block with one condition and one branch

if (condition) then ...
end if

This branch will execute if condition is true.

So far, the statements inside this if block execute only on a condition that evaluates as true, and nothing happens otherwise. If we need our program to do something in either case, we can use a more general if/else/end if block, as shown in the following listing.

Listing 2.8 General syntax of an if block with one condition and two branches

if (condition) then ...
else

This branch will execute if condition is true.

... end if

This branch will execute otherwise.

Unlike the single-liner if and the if/end if block, this one allows for two branches of execution: one if condition is true, and another if it’s false. It’s also possible to test for multiple specific conditions in a single if block, as shown in the following listing.

Listing 2.9 The most general syntax of an if block

if (condition) then ...
else if (other_condition) then ...
else ...
end if

You can have as many of these as you want.

The conditions are expressions of the logical type. The comparison operators, like the ones we used to check the values of the input parameters, work just like the comparison operators in general arithmetic we learned in elementary school. There are a few other edge cases and logical operators that I’ll put on the back burner for now, and that we’ll explore later as we encounter them.
In summary, we have a few different forms of an if-block:
1 if single-liner—Useful for simple checks and statements that fit on a single line; for example, zeroing a variable if negative: if (a < 0) a = 0

42

CHAPTER 2 Getting started: Minimal working app

2 if/end if—A more verbose form of the single-line if; useful when you have a single condition but multiple statements to execute
3 if/else/end if—Allows executing a statement for either the true or false value of the condition
4 if/else if/else/end if—Like if/else/end if, but allows checking the values of multiple specific conditions
That’s all you need to know about branching for now. We’ll apply these more complex if blocks in the following chapters.

2.3.7

Using a do loop to iterate
We need to implement looping in our app to do two things:
1 Loop over array elements to set initial values of water height and calculate the solution at the next time step.
2 Loop for a number of time steps to iterate the numerical solution forward in time.
The main construct for looping or iterating in Fortran is the do loop:

do n = start, end ...

Increment n from start to end.

end do

Code inside the loop will execute end - start + 1 times.

Here, n is the integer index that changes value with each iteration. In the first iteration, n equals start. When the program reaches the end do line, n is incremented by one. Internally, the program then checks if n is larger than end. If yes, the program breaks out of the loop and proceeds to the code that follows the loop. Otherwise, the control is returned to the beginning of the loop and another iteration is done. The process repeats until the program exits the loop.
By default, do loops increment the counter by one. However, you can specify a custom integer increment immediately after the end index:

do n = start, end, increment ...

Increment n from start to end by increment.

end do

Code inside the do loop will execute (end - start) / increment + 1 times.

In this case, the loop begins with n equal to start and is incremented by the value of increment with each iteration.
There are several rules to remember when coding do loops:
 The loop index (n) must be an integer variable (not a parameter).  start, end, and increment must be integers of either sign. They can be vari-
ables, parameters, or expressions that evaluate to integer values.

Implementing the minimal working app

43

 If start equals end, the loop body will execute only once.  If start is greater than end and increment is positive, the loop body will not
execute.  If start is less than end and increment is negative, the loop body will not execute.  A bare do statement without the counter and start and end indices is an
infinite do loop that has to be broken out of by other means, such as the exit statement.  Loops can be nested (loops inside loops).  Loops can be named. This is useful for nested loops where you want to associate an end do with its matching do, as shown in the following listing.

Listing 2.10 Using names with nested do loops

Begins a named outer loop (slower varying)

Begins a named inner loop (faster varying)

outer_loop: do j = 1, jm inner_loop: do i = 1, im print *, 'i, j = ', i, j end do inner_loop
end do outer_loop

This could be any code that we want to iterate.
Closing the inner loop

Closing the outer loop

Although naming loops may at first seem unnecessarily verbose, the names become useful in larger programs with multiple levels of nesting. Furthermore, you can use loop names to break out of a specific do loop from any level using the exit statement.
Finally, the general syntax form of a do loop is shown in figure 2.5.

Counter

Start End Increment

[name: ] do [var = expr1, expr2[, expr3]]

Optionally, give your loop a name.

end do [name]

Code to iterate goes here.

Figure 2.5 General syntax of a Fortran do loop. Optional syntax elements are in square brackets.

In the figure, expr1, expr2, and expr3 are start and end indices (inclusive), and the increment, respectively. name can be any given name.

44

CHAPTER 2 Getting started: Minimal working app

2.3.8

Setting the initial water height values
Before iterating the solution forward in time, we need to specify the initial state of the water height. In other words, we need to set the initial values of the array h. A common choice in toy models like ours is a Gaussian (bell) shape (figure 2.6).

Height

Initial state, h(x, 0) 1.00

0.75

0.50

0.25

0.00

25

50

75

100

Spatial grid index

Figure 2.6 Initial values of water height

This is a well-defined, smooth function that we can calculate using the exponential, as shown in the following listing.

Listing 2.11 Initializing the water height with a Gaussian shape

integer, parameter :: icenter = 25 real, parameter :: decay = 0.02

Central index and decay factor of the shape

do i = 1, grid_size

h(i) = exp(-decay * (i - icenter)**2)

end do

Calculates the value and assigns it to each element of the array

Loops over all elements, from index 1 to grid_size

Here, we have the first practical use of the following:
 A do-loop to iterate over array elements. Since we’ve declared h as an array of size grid_size, this loop will iterate over all elements of the array.
 Arithmetic operators -, *, and ** (power).  An intrinsic mathematical function exp (exponential). This and other intrinsic
math functions are readily available to use in Fortran programs and don’t need to be imported in any special way.  Arithmetic assignment (=) of the result of the expression on the right side to the variable on the left side. The value of the left side is updated only after the whole expression on the right side has been evaluated.

Implementing the minimal working app

45

Parameters icenter and decay control the position and width of the water height perturbation, respectively. The integer icenter is the array index at which the perturbation is centered. For example, when i equals icenter, the exponent argument reduces to zero, and h(i) equals 1. The real parameter decay determines the rate of exponential decay. Larger values yield a thinner perturbation.

Can our array assignment be done in parallel?
Recall our discussion of embarrassingly parallel problems in the previous chapter. We said that a problem is embarrassingly parallel if there’s no data dependency between individual iterations. Take a look at our expression for the initial value of h. Could we distribute this workload among multiple processors?
Begin the practice of asking that question for every computational problem, formula, or equation that you encounter. Over time, you’ll find more opportunity to distribute the computation, or at least mark sections of the code that are safe for the compiler to vectorize. Fortran offers a special do loop for this purpose, called do concurrent. It guarantees to the compiler that there’s no dependency between individual iterations and that they can be executed out of order, as we’ll see in the next subsection.

2.3.9

Predicting the movement of the object
We initialized the values of water height and are ready to get to the core of our simulation—iterating forward in time and calculating the solution at each time step. This consists of two steps:
1 Calculate the spatial difference of water height (dh), including the periodic boundary condition.
2 Use dh to calculate the new values of water height h.
The following listing provides the core of the solver.

Listing 2.12 Iterating the solution forward in time

time_loop: do n = 1, num_time_steps dh(1) = h(1) - h(grid_size)

Iterates over num_time_steps time steps

do i = 2, grid_size dh(i) = h(i) - h(i-1)

Applies the periodic boundary condition on the left

end do do i = 1, grid_size

Calculates the finite difference of h in space

h(i) = h(i) - c * dh(i) / dx * dt end do

Evaluates h at the next time step

end do time_loop

The outer loop, what we call time_loop, increments the integer n from 1 to num_ time_steps. Although we’re not using n anywhere inside the body of the loop, we use this loop to repeat the body for num_time_steps times. Inside the time_loop, we perform two calculations:

46

CHAPTER 2 Getting started: Minimal working app

1 We calculate the difference of h in space and store it in the array dh. We do this in two separate steps: a We calculate the value of dh(1), which corresponds to the element on the left edge of the domain. Because we’re applying periodic (cyclic) boundary conditions, dh(1) depends on the value of h from the right edge of the domain. b We loop over the remaining elements (from 2 to grid_size) and set dh(i) to the difference of h in space (h(i) - h(i-1)).
2 Once we have the array dh computed, we use it to compute the new value of h and update it. Here we don’t need to store the value of h for every time step, and we overwrite the old values with new ones.
Fortran follows the same operator precedence rules as general arithmetic:  Exponentiation (**) is evaluated first.  Multiplication (*) and division (/) are evaluated second.  Addition (+) and subtraction (-) are evaluated last.  Finally, the precedence can be overridden with parentheses.
Furthermore, Fortran operations of equal precedence are evaluated left to right. For example, this expression
h(i) = h(i) - c * dh(i) / dx * dt
is equivalent to this one:
h(i) = h(i) - (((c * dh(i)) / dx) * dt)
A few pages back, I asked you if it’s possible to parallelize this loop in a trivial way:
do i = 1, grid_size h(i) = exp(-decay * (i - icenter)**2)
end do
What you should look for is whether any iteration depends on data calculated in any other iteration. Here, the right side depends only on the loop counter i and parameters decay and icenter, whereas the variable on the left side (h(i)) is not used on the right side. Could every iteration be carried out in any order without changing the final result? If yes, the computation can be easily parallelized.
The first step is to inform the compiler that this section of the code can be executed in any order it finds most optimal. Fortran 2008 introduced the do concurrent construct for this purpose. This construct uses a slightly modified syntax, as shown in the following listing.
Listing 2.13 Using do concurrent for embarrassingly parallel calculations
do concurrent (i = 1:grid_size) h(i) = exp(-decay * (i - icenter)**2)
end do

Implementing the minimal working app

47

Here, we use a (i = 1:grid_size) syntax instead of i = 1, grid_size. We’ll cover this in more detail in chapter 6, but for now we’ll use this syntax to promote all our parallelizable loops to do concurrent.

What do concurrent is and what it isn’t
What does do concurrent do exactly? It’s a promise from programmer to compiler that the code inside the loop can be safely vectorized or parallelized. In practice, a good compiler would do this using a system threading library or SIMD machine instructions if available.
do concurrent by no means guarantees that the loop will run in parallel! In cases such as short loops with simple computations, the compiler may determine that serial execution would be more efficient. We’ll study explicit, distributed-memory parallelism with coarrays in chapter 7. For now, we use do concurrent as a note for both ourselves and the compiler that some regions of the code are safe to parallelize.

Inside of time_loop, can you find any other loops that could be expressed using do concurrent? If yes, use the modified syntax to rewrite them as do concurrent loops.

2.3.10 Printing results to the screen
We now have the time loop that iterates the solver for exactly num_time_steps time steps. The last remaining step in this chapter is to print the results to screen. The simplest approach is to print the results to the terminal, from where we can redirect the output to a file for later use, such as plotting. For this, you can use the print statement, which you already encountered in chapter 1:

print *, n, h

Prints values n and h to the terminal using default formatting

print is the simplest output statement in Fortran. The * symbol that’s placed immediately after print signifies default formatting, which tells the compiler to use any format for the data it finds convenient. In most cases, the default format will be reasonable. As noted, here we’re printing the values of n (integer scalar) and h (real array with 100 elements) to the screen. This statement will thus output exactly 101 values to the terminal in a single line.
We’ll explore Fortran input/output in more detail in chapter 6. For now, print * is all we need.
2.3.11 Putting it all together
Finally, we’ve gotten to the exciting part: taking the pieces that we’ve learned and putting them together into a complete and working program. We’ll first look at the solution of our program, visualized with a Python script, and then go through the complete code.

48

CHAPTER 2 Getting started: Minimal working app

THE RESULT The numerical solution of our simple app is shown in figure 2.7. From top to bottom, each panel shows the state of water height at increments of 25 time steps. The top panel corresponds to the initial condition, as in figure 2.6. The position of the water

Height

Height

Time step 0 1.00 0.75 0.50 0.25 0.00

Time step 25 1.00 0.75 0.50 0.25 0.00

Time step 50 1.00 0.75 0.50 0.25 0.00

Time step 75 1.00

0.75

0.50

0.25

0.00

25

50

75

100

Spatial grid index

Height

Height

Figure 2.7 Predicting the linear advection of an object, with periodic boundary conditions. The water height perturbation is advected from left to right with a constant speed of 1 m/s. When the water reaches the boundary on the right, it reenters the domain from the left.

Begins the time
loop

Implementing the minimal working app

49

height peak in each panel is consistent with the configuration of the physical parameters of the simulation: background flow speed (c = 1), grid spacing (dx = 1), and time step (dt = 1). In the bottom panel, we can see the water height peak moving out on the right and reentering on the left. This confirms that our periodic boundary condition works as intended.
Although Fortran is great for high-performance numerical work, it’s less elegant for graphics and visualization of data. For brevity and simplicity, I use Python scripts for visualization of the tsunami results. You can find the visualization code in the tsunami repository on GitHub (https://github.com/modern-fortran/tsunami), alongside the Fortran source code in each chapter directory.
COMPLETE CODE The complete code for the first version of our tsunami simulator is given in the following listing.

Listing 2.14 Complete code of the minimal working tsunami simulator

program tsunami implicit none integer :: i, n

Beginning of the program
Enforces explicit declaration of variables

integer, parameter :: grid_size = 100 integer, parameter :: num_time_steps = 100
real, parameter :: dt = 1 ! time step [s] real, parameter :: dx = 1 ! grid spacing [m] real, parameter :: c = 1 ! background flow speed [m/s]
real :: h(grid_size), dh(grid_size)
integer, parameter :: icenter = 25 real, parameter :: decay = 0.02

Declaration of data

if (grid_size <= 0) stop 'grid_size must be > 0' if (dt <= 0) stop 'time step dt must be > 0' if (dx <= 0) stop 'grid spacing dx must be > 0' if (c <= 0) stop 'background flow speed c must be > 0'

Checks input parameter values and aborts if invalid

do concurrent(i = 1:grid_size) h(i) = exp(-decay * (i - icenter)**2)
end do

print *, 0, h

Writes the initial water height values to the terminal

Loops over array elements and initializes values

time_loop: do n = 1, num_time_steps dh(1) = h(1) - h(grid_size)

Applies the periodic boundary condition at the left edge of the domain

50
Compiles the
program

CHAPTER 2 Getting started: Minimal working app

do concurrent (i = 2:grid_size) dh(i) = h(i) - h(i-1)
end do

Calculates the finite difference of water height in space

do concurrent (i = 1:grid_size) h(i) = h(i) - c * dh(i) / dx * dt
end do

print *, n, h end do time_loop

Prints current values to the terminal

Integrates the solution forward; this is the core of our solver

end program tsunami

With only 30 lines of code, this is a useful little solver! If you compile and run this program, you’ll get a long series of numbers as text output on the screen, as shown in the following listing.

Listing 2.15 Text output of the current version of the tsunami simulator

0 9.92950936E-06 1 0.00000000 2 0.00000000 ...

2.54193492E-05 9.92950845E-06 0.00000000

Initial water height output
6.25215471E-05 ... 2.54193510E-05 ... 9.92950845E-06 ...
Output after second time step

Output after first time step

Although it may look like nonsense, these are our predicted water height values (in meters). However, the output is long and will flood your terminal window. You’ll be able to explore the output more easily if you redirect it to a file, as the following listing demonstrates.

Listing 2.16 Building, running, and visualizing the output from the tsunami simulator

cd src/ch02

Enters the source code directory

gfortran tsunami.f90 -o tsunami

./tsunami > tsunami_output.txt

Runs the program and redirects the output into a text file

python3 plot_height_multipanel.py tsunami_output.txt

Visualizes the output and writes it to an image file

Alternatively, the source code repository on GitHub also comes with a Makefile to streamline the build process, and you can type make ch02 from the top-level directory. This also assumes that you’ve set up the Python virtual environment following the instructions in the README.md file in the repository.

Going forward with the tsunami simulator

51

Go ahead and play with it. Some ideas that come to mind:
 Tweak the initial conditions, perhaps by changing the shape and position of the initial perturbation. For example, you can change the values of the decay and icenter parameters, or use a different function when initializing the h array. Try a sine wave (intrinsic function sin).
 Change the grid size and number of time steps parameters.
Remember that Fortran is a compiled language. Every time you change the code, you’ll need to recompile it before running it.
2.4 Going forward with the tsunami simulator
Looking back at this chapter and what we’ve made so far, it’s helpful to summarize what we don’t have yet and how we’ll get there in the second part of the book:
 In chapter 3, you’ll learn about functions and subroutines, and refactor some of the calculations in our simulator as reusable procedures.
 In chapter 4, you’ll use Fortran modules to reorganize our app, and you’ll implement more realistic physics.
 In chapter 5, you’ll learn all about arrays and whole-array arithmetic.  In chapter 6, we’ll dive deeper into input and output, and you’ll learn how to
output your data in a portable way, format it, and write it to files on disk.
Beyond that, in part 3 of this book we’ll explore parallel computing with coarrays, as well as advanced data structures and procedures.

A note on abstractions
As we work through this book, we’ll come across new layers of abstraction in each chapter. Here, an abstraction is a programming mechanism that aims to black-box the internal implementation away from the programmer. For example, in the next chapter, functions and subroutines are an abstraction over explicit, imperative code. In chapter 8, you’ll learn about derived types, which can contain any number of variables and procedures attached to them, and this is yet another layer of abstraction.
Each layer of abstraction introduces a benefit and a cost. The benefit usually boils down to having to write less boilerplate code, especially when programming repetitive tasks. The cost is that abstractions hide not only the implementation details, but also meaning and side effects if they’re not used conservatively and with care. I’ll warn you each time we come across a new abstraction in this book. Consider each abstraction carefully, and use them only if the benefits outweigh the perceived costs.

52

CHAPTER 2 Getting started: Minimal working app

2.5 Answer key
This section contains the solution to the exercise in this chapter. Skip ahead if you haven’t worked through the exercise yet.

2.5.1

Exercise: Cold front propagation
1 What is the temperature gradient between Atlanta and Miami? Here, the gradient will be the difference in temperature between the two locations, divided by the distance between them. The answer is thus 24 °C minus 12 °C, divided by 960 km: 0.0125 °C/km.
2 How many hours will it take for the temperature in Miami to reach 12 °C? Let’s first get the rate of cooling in Miami. The front is moving with the speed of 20 km/h, and we know that the gradient is 0.0125 °C/km. The cooling rate is then 20 km/h times 0.0125 °C/km: 0.25 °C/hour. The Miami temperature starts at 24 °C, so it will reach 12 °C in 24 °C minus 12 °C, divided by the cooling rate 0.25 °C/hour. The result is 48 hours.
3 What will be the temperature in Miami after 24 hours? We know that the Miami temperature starts at 24 °C and that its cooling rate is 0.25 °C/hour. The answer is then 24 °C - 0.25 °C/hour times 24 hours. The result is 18 °C.

2.6 New Fortran elements, at a glance
 program/end program statements to define a main program  Intrinsic numeric types integer, real, and complex  dimension attribute to declare an array  Arithmetic operators +, -, *, /, and **, and assignment =  if statement and if blocks for branching  stop statement to abort the program and print a message to the terminal  do/end do construct to iterate over any executable section of the code  do concurrent to mark embarrassingly parallel sections of the code  print * statement as the simplest way to print text and variable values to the
terminal

2.7 Further reading
 GNU Fortran compiler documentation: https://gcc.gnu.org/onlinedocs/gfortran  Wikipedia article on advection: https://en.wikipedia.org/wiki/Advection  Wikipedia article on finite differences: https://en.wikipedia.org/wiki/Finite_
difference

Summary

53

Summary
 Building an executable Fortran program consists of the compilation and linking steps.
 There are five program units in Fortran: main program, function, subroutine, module, and submodule.
 A program begins with a program statement and ends with an end program statement.
 In every program, we first declare the data, and executable code comes after.  Use implicit none at the top of your declarative code to enforce explicit decla-
ration of all variables.  There are five built-in data types in Fortran: integer, real, complex, character,
and logical.  if blocks are used to test for conditions and take different execution branches
depending on their values.  Use the stop statement to abort the program immediately and print a helpful
message to the terminal.  do loops are used to iterate over sections of the code a specified number of times.  Start, end, and increment values of a do loop counter can have any integer value.  Fortran’s arithmetic rules are the same as those we learn in school: exponentia-
tion is evaluated first, then multiplication and division are evaluated, and finally addition and subtraction go last; this order can be overruled with parentheses.  print * is an easy way to print the values of any variable or literal constant to the terminal.

Part 2
Core elements of Fortran
This part covers the core elements of Fortran: procedures, modules, arrays,
and I/O. In chapter 3, you’ll learn the most important things to know about functions
and subroutines (collectively called procedures). They’ll allow you to abstract away any piece of code that you need to run many times. Functions and subroutines are fundamental building blocks that will allow you to write reusable, composable, and complex (but not complicated) code. You’ll apply this knowledge to refactor the tsunami simulator we started in chapter 2.
In chapter 4, you’ll learn about modules and how to use them to organize your data and procedures in reusable and portable components.
Chapter 5 covers arrays, the fundamental Fortran data structure. You’ll learn how to declare, initialize, and use arrays, as well as how to leverage whole-array arithmetic to greatly simplify your code. You’ll use arrays for the analysis of stock price time series.
Finally, chapter 6 covers I/O. You’ll learn how to read and write data from the standard input, output, and error streams, as well as how to read from and write to files on disk. You’ll also learn how to format numerical data as text. You’ll practice these skills by writing a minimal note-taking app for the command line.
After you’ve worked through this part of the book, and with some practice, you’ll be a functional and independent Fortran programmer. You’ll be able to write Fortran programs and libraries from scratch to solve real-world problems.

Writing reusable code with functions
and subroutines
This chapter covers
 What procedures are and why we use them  How procedures break down into two kinds:
functions and subroutines  Writing procedures that don’t cause side effects  Writing procedures that work on both scalars
and arrays
In the previous chapter, you learned about the core elements of Fortran: declaration of scalar and array variables, do loops to iterate parts of the code a desired number of times, and arithmetic expressions and assignments. We used them to write a simple simulator that predicts the motion of an object in space and time due to background flow. As we learn new Fortran features, we’ll continuously expand and improve our app to produce more realistic simulations. This chapter introduces functions and subroutines, which will help us manage the complexity of our growing app.
This chapter is all about scaling a growing app while maintaining simplicity through code reuse. Our minimal working app has so far been organized as a single program, with a number of statements that the program executes top to bottom.
57

58

CHAPTER 3 Writing reusable code with functions and subroutines

This is the imperative style of programming—you’re telling the computer what to do, one statement after another. This approach worked well because we tackled a relatively simple problem. However, we’ll now prepare for a more realistic fluid dynamics simulation, which will require more moving parts and complexity.
This is where functions and subroutines, collectively called procedures, come in. They’ll allow us to define self-contained and reusable nuggets of code that we can invoke whenever needed and using different input data. Procedures are the fundamental building blocks that we’ll reuse over and over as we work our way through this book.

3.1 Toward higher app complexity
Simple is better than complex. Complex is better than complicated.
—Tim Peters, The Zen of Python
Although a mantra of Python, the opening quote applies well to Fortran and programming in general. We always aim for simple, whenever possible. This is especially true in software design, where we often deal with increasingly complex systems. Simple is easy to read, understand, and explain to our friends and colleagues. However, it’s a challenge to maintain simplicity as we build an app, a library, or a framework. The more features we add and corner cases we handle, the more bloated our app seems, and we worry that the project will spin out of control. It inevitably becomes more complex. Does that also mean it has to become more complicated?
I don’t have a traditional computer science background. I first learned to program so I could solve physics problems, much like the one we worked on in the previous chapter. Programming for me was more a tool to accomplish a given task than an art in itself. Some of my programs could easily grow to thousands of lines of code, consisting of inscrutable reads and writes to binary files, multiply-nested loops, and endless lists of imperative expressions and assignments. No function calls, no code reuse. Abstracting data with object-oriented classes and methods? Forget about it! It was a programmer’s nightmare.
Over time, I learned about Fortran features designed specifically to make programming easier. For example, rather than repeating the same calculation on different data, you can write it as a function and call it many times with different inputs. You can use modules, introduced by the Fortran 90 standard, to define variables and procedures, which can then be accessed from elsewhere in the program or library. Carefully put together, these elements will make your life easier, whether you prefer an objectoriented, functional, or plain procedural programming approach to your problem.

3.1.1

Refactoring the tsunami simulator
In the previous chapter, we made the first working version of what will become a realistic water wave simulator. Contained in a single program, it included data declaration and initialization, arithmetic expressions and assignment to calculate the solution, a do loop to advance the solution forward in time, and a print statement to output the

Toward higher app complexity

59

results to screen. With 26 lines of code, this is a simple program that does simple things: it initializes the water height, simulates its movement forward due to background flow, and writes its state to the screen at each time step (figure 3.1).

Initial time

Moving an object forward in space Background ﬂow

Future time

Height

Distance
Figure 3.1 Advecting a Gaussian shape in space from left to right. We worked on this problem in the previous chapter.

In this chapter, we’ll refactor the simulator to use a set of common building blocks, such as the finite difference calculation that I introduced in chapter 2. This will allow us to more easily expand the simulator in the following chapters as we move toward a more realistic water wave motion. Recall the core of our solver from the previous chapter, shown in the following listing.

Listing 3.1 Time integration loop from the minimal working tsunami simulator

Calculates the difference on the left boundary
time_loop: do n = 1, num_time_steps
dh(1) = h(1) - h(grid_size)

Iterates for num_time_steps time steps

do concurrent (i = 2:grid_size) dh(i) = h(i) - h(i-1)
end do

Calculates the difference in the rest of the domain

do concurrent (i = 1:grid_size) h(i) = h(i) - c * dh(i) / dx * dt
end do

Computes and stores the value of h at the next time step

end do time_loop

The body of the main loop (time_loop) consists of two steps: calculating the difference of water height h in space, and using that difference to predict and store its new value at the next time step. This solves for only one equation for water height, which features one physics term, namely the linear advection.

60

CHAPTER 3 Writing reusable code with functions and subroutines

To add more terms and another equation, we’ll define a new array, u, for the water velocity and add any calculations inside time_loop to make the solver complete. Without assuming anything about what the equations or the code should look like, figure 3.2 illustrates the tentative update of our app.

Minimal working app
program tsunami Declare data Initialize height do n = 1, nm Compute terms for height do i = 1, im Solve for height end do Write output to screen end do
end program tsunami

Expanded app
program tsunami Declare data Initialize velocity Initialize height do n = 1, nm Compute terms for velocity do i = 1, im Solve for velocity end do Compute terms for height do i = 1, im Solve for height end do Write output to screen end do
end program tsunami

Figure 3.2 Expanding the minimal working app to a more realistic simulator

The key operations we were doing to simulate the evolution of water height— initialization, calculating the change in time, and solving the equation—we’d now be doing for both water height and velocity. It looks like our program would at least double in size if we added code to solve for another variable. Furthermore, if we added more terms to each of the equations, our program would grow further. It’s clear that our program will inevitably become difficult to work with if we keep piling more and more code on top of it.
In the previous chapter, you learned that most of the computational work in fluid dynamics boils down to approximating partial derivatives with a discrete form that can be expressed as code. Finite differences, which we used to calculate the gradient of the water surface to predict its movement due to advection, are what we’ll use for all the other terms in the tsunami simulator. Since we’ll spend most of the time (human and computer time!) on these terms, we should find a way to abstract this low-level calculation and make it reusable from the main solver loop. This is where Fortran procedures and modules come in (figure 3.3).
In this new framework, we define the reusable data and functions inside the module. The module is then accessed from the main program with the use statement. We’ll first refactor our minimal working app to compute the finite difference in a function, while exactly reproducing the existing results. Then, in the next chapter, we’ll define our new custom module to host our functions, and we’ll expand our app to produce more realistic simulations.

Toward higher app complexity

61

Main program

Tsunami app

Module and functions

program tsunami use mod_diﬀ Declare data Initialize height do n = 1, nm Solve for height Write output to screen end do
end program tsunami

module mod_diﬀ Declare data
contains
function diﬀ(u) ... end function diﬀ
end module mod_diﬀ

Figure 3.3 Using a module and a function to reuse and simplify code. Module mod_diff, which defines the difference function diff, is accessed from the main program with the use statement (top arrow). Through use association, the function diff can be used within the scope of the main program (bottom arrow).

3.1.2

Revisiting the cold front problem
In the previous chapter (section 2.2.2), I introduced the example of a cold front to illustrate the concepts of temperature gradient (change in space) and tendency (change in time). There, I asked you to calculate the change of temperature in Miami, considering the temperatures in Atlanta and Miami, the distance between them, and the speed of the front (figure 3.4).

Atlanta Cold
12 °C 18 °C 24 °C

Warm Miami

Figure 3.4 An illustration of a cold front moving from Atlanta toward Miami. Curved lines are contours of constant temperature. The dashed arrow shows the direction of front propagation. We used this example in the previous chapter to illustrate the concept of spatial gradients and advection.

What would the program that solves this problem look like? For simplicity, let’s assume the same initial parameters as in the example:
 The temperature is 12 °C in Atlanta, and 24 °C in Miami.  The distance between Atlanta and Miami is 960 kilometers.  The front is moving toward Miami at a constant speed of 20 km/h.
The compiled program should yield

Temperature after 24.0000000

hours is 18.0000000

degrees.

62

CHAPTER 3 Writing reusable code with functions and subroutines

Computes the
solution

If you worked through the exercise of building the minimal working app in the previous chapter, then you have all the ingredients to solve this problem: defining the program unit, declaring and initializing data, basic arithmetic expression and assignment, and printing to screen. The following listing provides the complete code.

Listing 3.2 Solving for temperature due to passage of a cold front

program cold_front implicit none

All declarations will be explicit.

real :: temp1 = 12, temp2 = 24

Declares and initializes

real :: dx = 960, c = 20, dt = 24

the variables

real :: res ! result in deg. C

The variable to

res = temp2 - c * (temp2 - temp1) / dx * dt

store the result in

print *, 'Temperature after ', dt, & 'hours is ', res, 'degrees'

Writes the solution to screen

end program cold_front

We first declared and initialized all the input parameters:
1 Origin and destination temperatures, temp1 and temp2, respectively 2 Distance in kilometers, dx 3 Front speed in kilometers per hour, c 4 Time interval in hours, dt 5 The variable res to store the result in
The calculation itself fits into a single expression and assignment. This program works well if you need to do the calculation once or twice. However,
what if the exercise required you to calculate the temperature for multiple different values of input parameters, be it temp1, temp2, dx, c, or dt? You can see where I’m going with this. Specifically, I could ask you to calculate the solution in the case of temp1 being 0 °C, another solution for a front speed of 28 km/h, or the solution after 36 hours. How would you solve this problem? You could compute the first solution, then reinitialize variables and compute another solution, and so on. However, this would soon become quite tedious and result in repetition of code. More problematically, how would you implement a solution that had to work with a continuous stream of input parameters in real time, such as those measured at real-world weather stations?

Experiment a bit
Try plugging in different values for input parameters and rerunning the program. (You’ll have to recompile it as well.) Do the results look reasonable? Also, can you find a value of any input parameter that breaks the program? Try it!

Toward higher app complexity

63

3.1.3

An overview of Fortran program units
When I introduced program as the main Fortran program unit in the previous chapter, I also mentioned a few others: functions, subroutines, and modules. Functions and subroutines, which are the focus of this chapter, are both kinds of procedures. A procedure is a miniprogram that can be called any number of times from the main program, or from another procedure. Like the main program, procedures have executable code, the code that does things. Figure 3.5 illustrates functions and subroutines.

The main program is the fundamental Fortran unit. It is the only unit that can be invoked as an executable from the operating system.

program foo
implicit none integer :: a, b, n real :: x
n = 1, 10 do n = 1, 10
call add(a, n) end do
end program foo

The main program can declare data, have executable code, as well as invoke other units, such as functions and subroutines.

Like programs, functions can also declare data and have executable code. Unlike programs, they can only be invoked in expressions; for example, total = 2 * sum(3, 5).

function sum(a, b) integer, intent(in) :: a, b integer :: sum sum = a + b
end function sum

Subroutines receive input arguments, modify them in-place, and return any number of output arguments. Subroutines can only be invoked with a call statement; for example, call add(a, 3).

subroutine add(a, b)
integer, intent(in out) :: a integer, intent(in) :: b
a = a + b print ∗, ‘a = ‘, a

end subroutine add

Functions can take any number of input arguments, but always return only one result.
Use functions for side effect-free calculations.
The intent attribute determines whether an input argument can be modiﬁed in-place (in out) or not (i.n)
Use subroutines when you need to modify input arguments in place, or write data to screen or external ﬁles.

Figure 3.5 Overview of a function and a subroutine, and how they’re invoked from the main program

Each of these units has different properties and a unique purpose:
 Main program—Every Fortran application must have one, and only one, main program. The main program can contain declarative and executable code, as well as definitions of procedures. The main program is the only program unit that you can invoke as its own executable program.

64

CHAPTER 3 Writing reusable code with functions and subroutines

 Function—A function is a kind of procedure. Like the main program, it can contain declarative and executable code, but you can’t invoke it on its own, and you can only call it from the main program or another procedure. A function always returns only one variable as a result and can only be invoked in expressions. Functions are thus best suited for minimal computational tasks that don’t cause side effects.
 Subroutine—A subroutine is another kind of procedure. In many respects, it’s similar to a function, with two notable differences: a You can’t use a subroutine in expressions, and you have to call it using a dedicated call statement. b A subroutine can return any number of results in the argument list. Subroutines are better suited for work that modifies program state or has other side effects, such as input or output.
For short and simple applications, using only the main program does the job. Once you start repeating code, it may be time to define it in a function and call it from the main program. Functions are powerful because you can use them in expressions, and they’re especially well suited for writing pure, side effect-free code. Subroutines are appropriate when side effects are inevitable—for example, for I/O or when working with shared, globally accessible data. Figure 3.6 illustrates how you can define and call functions and subroutines in the main program.

A main program can “contain” function and subroutine deﬁnitions. They are automatically available for use in the main program. This works well for smaller apps.
Here, we call the add subroutine on each iteration and modify variable a in-place.

foo. f90
program foo implicit none integer :: a, n
a = 0 do n = 1, 10
call add(a, n) end do
total = 2 * sum(a, 5)
contains
function sum(a, b) ...
end function sum
subroutine add(a, b) ...
end subroutine add
end program foo

We invoke the function inside the expression to calculate the total.

Compile it like this: gfortran foo.f90 -o foo
Figure 3.6 Defining and accessing an external function and subroutine in the main program

Don’t repeat yourself, use procedures

65

Overall, these are general rules of thumb as best practice, and not hard rules. You’ll discover the best way to use functions and subroutines yourself by applying them in practice.

3.2 Don’t repeat yourself, use procedures
Like I mentioned earlier, procedures allow you to define snippets of code as their own self-contained units of functionality. You can then use them and reuse them as much as you need, by passing different values of input parameters and getting the results back. They’re similar to the main program, in that they can include any declarative and executable code. Unlike the main program, you have to call a procedure from a parent program or another procedure. In other words, you can’t just compile a procedure on its own and run it from the command line. Procedures give you the power to define some piece of functionality once, then reuse it as many times as you need by invoking that procedure.
As a general rule of thumb, we’ll write any reusable code as functions and resort to subroutines only when we must. This simple principle will help us write simpler programs that are easier to understand and debug.

TIP If you find yourself writing the same piece of code more than a few times, consider making it a procedure.

3.2.1

Your first function
Let’s jump straight into it and write our first custom function. We’ll take our cold front program from listing 3.2 and rewrite it to delegate the temperature calculation to an external function. This will allow us to easily compute the solution for a series of different input values. Specifically, we’ll iterate over several values of time interval dt, ranging from 6 to 48 hours at 6-hourly increments, while holding the other input parameters constant. This will tell us how the temperature in Miami drops over time as the cold front moves through:

Temperature after Temperature after Temperature after Temperature after Temperature after Temperature after Temperature after Temperature after

6.00000000 12.0000000 18.0000000 24.0000000 30.0000000 36.0000000 42.0000000 48.0000000

hours is hours is hours is hours is hours is hours is hours is hours is

22.5000000 21.0000000 19.5000000 18.0000000 16.5000000 15.0000000 13.5000000 12.0000000

degrees. degrees. degrees. degrees. degrees. degrees. degrees. degrees.

I’ll first go over the complete program, as shown in the following listing, and then go more in-depth into the function definition syntax and its rules.

66

CHAPTER 3 Writing reusable code with functions and subroutines

Listing 3.3 Calculating the cold front temperature using an external function

Time interval that we pass to the function as a real number

program cold_front implicit none

Explicit declarations apply to the whole program scope, including the contained function.

integer :: n

real :: nhours do n = 6, 48, 6

Loops from 6 to 48 hours with a 6-hourly increment

Prints the function result

nhours = real(n) print *, 'Temperature after ', &
nhours, ' hours is ', &

Converts the integer counter to a real number of hours

cold_front_temperature(12., 24., 20., 960., nhours), ' degrees.'

end do

contains

Separates the program code and the function definition

Inputs arguments

real function cold_front_temperature( & temp1, temp2, c, dx, dt) result(res) real, intent(in) :: temp1, temp2, c, dx, dt res = temp2 - c * (temp2 - temp1) / dx * dt
end function cold_front_temperature

end program cold_front

Closes the function scope

Specifies function type, name, and arguments
Computes the function result

In this program, we loop over several values of time interval in hours. Inside the loop, we invoke the cold_front_temperature function, using four input arguments that have fixed values, with the fifth input argument being the time interval that varies. The function is invoked on the right side of the print statement, so the result is broadcast directly to the screen. Finally, the function is defined in a special section at the end of the program, marked by the contains statement. In summary, we have three new language elements in this program: how the function is defined, where it’s defined, and how it’s called from the main program. I’ll explain how each element works, one at a time.
DEFINING A FUNCTION For brevity, I’ll go over the function definition by using a simpler example, such as calculating the sum of two integers, as shown in the following listing.

Listing 3.4 A function that returns a sum of two integers

Declares the function result

Specifies the name of the

function sum(a, b)

function and input arguments

integer, intent(in) :: a

Declares input arguments

integer, intent(in) :: b

and specifies intent

integer :: sum

Don’t repeat yourself, use procedures

67

sum = a + b end function sum
Closes the function scope

Computes the function result

Let’s break this down. We open the function body with a function statement and specify its name. This is analogous to defining a main program, except for one important difference. With a function, we also list all the arguments in parentheses, immediately following the function name. Like the program statement, the function statement must have a matching end function statement.
Next, we declare the arguments much like we did for the main program, except that here we also have an additional attribute, intent(in). This attribute indicates to the compiler—and to the programmer reading the code—what the intent of the argument is. Here, intent(in) means that the variables a and b are to be provided by the calling program or procedure, and their values won’t change inside this function.
Like when declaring variables in the main program, you can specify input arguments of the same data type on the same line. Furthermore, you can specify the data type of the function result immediately in front of the word function, as shown in the following listing. Notice that we use both of these features in the cold front program as well.

Listing 3.5 Specifying the data type of the function result in the function statement

integer function sum(a, b) integer, intent(in) :: a, b sum = a + b
end function sum

We specified the data type of the function result here.
You can put multiple arguments of the same type and intent on the same line.

It’s also possible, for convenience, to specify a different name for the function result, other than the name of the function, using the result attribute, as the following listing demonstrates.

Listing 3.6 Specifying the function result as different from the function name

integer function sum(a, b) result(res) integer, intent(in) :: a, b res = a + b

Specifies a different name for the function result

end function sum

The function result is now res.

The advantage to using the result attribute may not be obvious from this example because the name of the function (sum) is already quite short, but it comes in handy for longer function names. Note that Fortran comes with an intrinsic (built-in) function sum that returns the sum of all elements in an input array. Because of this, some compilers may warn you if you compile this function, and that’s okay. I used the same name for the example in this section only for convenience.

68

CHAPTER 3 Writing reusable code with functions and subroutines

In listing 3.6, the function returns a single scalar as a result. In general, functions can return a scalar, an array, or a more complex data structure, but it’s always a single entity.
You may be wondering why I omitted the implicit none statement in the declaration section in listing 3.6. In this case, I did it for brevity, and it wouldn’t do much here because we use only the input arguments and no other variables in the calculation of the result. However, I omitted it in the cold_front_temperature function definition (listing 3.3) as well because the function is defined in the scope of the main program, and implicit none then propagates into all procedures defined therein.
As functions always return a single result and can only be invoked from expressions, they’re best suited for minimal bits of functionality. A function that does more than one thing is harder to understand. What happens when you start chaining multiple function calls in a single expression, as I’ll show you in the next subsection? Well, you should be able to tell what a function does simply based on its name. You can see that it’d be difficult to do so if the function was doing many things. When defining a function, consider the result and the smallest set of inputs required to calculate it. If your function does only that and no more, congratulations—you’re on a good track toward clean and maintainable code.
TIP A function should do one and only one thing.
INVOKING THE FUNCTION A Fortran function is invoked in the same way as in C, Python, or JavaScript. To call the function sum defined in listing 3.6 and print the result to the screen, you’d simply say
print *, sum(3, 5)
You can also use a function in expressions or output statements, or pass the function result as an argument to another function. All of the statements in the following listing are valid.

Listing 3.7 Examples of invoking an external function

six = 2 * sum(1, 2)

Invokes a function in an arithmetic expression

print *, '2 plus 4 equals', sum(2, 4)

Invokes a function as part of an output statement

six = sum(sum(1, 2), 3)

Passes a function result as an argument to another function call

You can thus chain functions into more complex expressions, which you can use to write concise and elegant code if used with moderation. In the cold front program in listing 3.3, we invoked the cold_front_temperature function directly on the print statement.

Don’t repeat yourself, use procedures

69

Actual and dummy arguments
The Fortran Standard uses specific terminology to differentiate between arguments defined inside the procedure and those that are passed in the call. Actual arguments are the ones that you pass when invoking the procedure. Dummy arguments are the ones declared in the procedure definition. In the previous example of sum(3, 5), the integer literals 3 and 5 are the actual arguments, and integers a and b in the function definition are dummy arguments. Being aware of this distinction and terminology will prove to be useful later when we tease out more advanced procedure concepts, as well as if you read Fortran Standard documents or other Fortran books.
SPECIFYING THE INTENT OF THE ARGUMENTS If you look closely at the declaration statements for arguments a and b in listings 3.4 to 3.6, you’ll notice the intent attribute—something that we haven’t used in our programs so far. This attribute informs the compiler about the semantic purpose of the arguments, and it can take three different values:
 intent(in)—The argument is an input argument. It will be provided to the procedure by the calling program or procedure, and its value won’t change inside the procedure.
 intent(out)—The argument is an output argument. Its value is assigned inside the procedure and returned back to the calling program or procedure.
 intent(in out)—The argument is an input and output argument. It’s provided to the procedure by the calling program or procedure, its value can be modified inside the procedure, and its value is returned to the calling program or procedure.
Like implicit none, specifying the intent is optional but strongly recommended. First, an intent specification clearly indicates to the programmer (especially if they’re not the original author of the code) what the role of each argument is, which helps with both understanding and debugging the code. Second, specifying intent can help the compiler raise errors if the actual code is in violation of the intent specification. For example, if you declare an argument as an intent(in) variable, the compiler won’t let you use it on the left side of an assignment. Being explicit regarding the intent of all arguments will help you write transparent and correct programs.
TIP Always specify intent for all arguments.
I mentioned earlier that functions are best suited for calculations that don’t cause side effects, whereas subroutines are more appropriate when we need to modify variables in-place. These are best practices, rather than hard rules: Fortran allows intent(in out) and intent(out) arguments for functions as well as subroutines, which means that functions could be used to modify variables in-place.

70

CHAPTER 3 Writing reusable code with functions and subroutines

WHERE TO DEFINE A FUNCTION Before modules were introduced by the Fortran 90 standard, it was common for functions to be defined in their own file. State-of-the-art linear algebra libraries like BLAS (Basic Linear Algebra Subprograms, https://www.openblas.net) or LAPACK (Linear Algebra PACKage, http://www.netlib.org/lapack) are still organized in the one-procedureper-file model. For larger programs and libraries, it’s best practice to define functions in a module and have one module per source file. For short and simple programs, you can place the function definition within the scope of the main program. As we won’t go into more details on modules until the next chapter, we’ll define all our procedures in the main program for now.
To define a function in the main program, place it near the end of the program, immediately following the contains statement and before the end program statement. The contains statement separates the main program code above it from the procedure definitions beneath it, as the following listing demonstrates.

Program code goes
here

Listing 3.8 Defining a function inside the program scope

program cold_front ...
contains

Marks the end of the program executable code, and the beginning of procedure definitions

... end program cold_front

Put any procedure definitions here.

This rule will also apply to defining functions in a module, as you’ll learn in the next chapter.

3.2.2

Expressing finite difference as a function in the tsunami simulator
You now understand how to define a function and how to call it from the main program. Finally, we get to the fun part—applying our new knowledge about functions to refactor our tsunami simulator. Let’s look back at the main time loop in our program, as reprised in the following listing.

Listing 3.9 The time integration loop from the minimal working tsunami simulator

Calculates the
difference on the left boundary

time_loop: do n = 1, num_time_steps
dh(1) = h(1) - h(grid_size)
do concurrent (i = 2:grid_size) dh(i) = h(i) - h(i-1)
end do

Iterates for num_time_steps time steps
Calculates the difference in the rest of the domain

do concurrent (i = 1:grid_size) h(i) = h(i) - c * dh(i) / dx * dt
end do

Computes and stores the value of h at the next time step

end do time_loop

Don’t repeat yourself, use procedures

71

At the beginning of this chapter, I mentioned that we’ll use the finite difference calculation quite a bit as we move toward a more realistic wave simulator. A good first step, then, may be to replace the following
dh(1) = h(1) - h(grid_size)
do concurrent (i = 2:grid_size) dh(i) = h(i) - h(i-1)
end do

with a function call like this:

dh = diff(h)

In a nutshell, we’ll pack both the finite difference calculation (dh(i) = h(i) - h(i-1)) and the handling of the boundary condition (dh(1) = h(1) - h(grid_size)) into a single function diff that we can reuse whenever needed. This will be quite useful down the road as we add more physics terms to our solver. If coded correctly, the new program will output exactly the same results as the original version. Our time_loop in the main program should now look like the following listing.

Listing 3.10 Delegating the finite differencing to a function

time_loop: do n = 1, num_time_steps

dh = diff(h)

Calculates the difference in a function

do concurrent (i = 1:grid_size) h(i) = h(i) - c * dh(i) / dx * dt
end do

Computes and stores the new value of h

print *, n, h end do time_loop

Write the values to screen

And the following listing shows the definition of the diff function.

Listing 3.11 Finite difference calculation expressed as a function

function diff(x) result(dx) real, intent(in) :: x(:)

Assumed-shape real array as input argument

real :: dx(size(x)) integer :: im im = size(x)

The result will be a real array of the same size as x.

dx(1) = x(1) - x(im) dx(2:im) = x(2:im) - x(1:im-1) end function diff

Calculates the boundary value

Calculates the finite difference for all other elements of x

72

CHAPTER 3 Writing reusable code with functions and subroutines

We’re now calculating the difference in space in the function and are down to only one do loop inside the main time loop. Before we move on to subroutines, I’ll give you a sneak peek into one of Fortran’s most powerful features—its array-oriented syntax. While I only mentioned this briefly in chapter 1 when discussing the strengths and weaknesses of Fortran, we haven’t had the opportunity yet to cast arithmetic operations on whole arrays. We’ll go into more depth with everything about arrays in chapter 5, but for now, let’s rewrite the main time loop to greatly simplify it, as the following listing demonstrates.

Listing 3.12 Solving the advection equation with a single expression

time_loop: do n = 1, num_time_steps h = h - c * diff(h) / dx * dt print *, n, h
end do time_loop

Invokes diff(h) directly to update the new value of h
Writes the values to screen

Now this is pretty sweet! We have a solver that not only fits in a single line of code, but also appears almost exactly the same as our original math equation. The internal details of the finite difference calculation are now hidden in the implementation of the function diff, and here we simply call it to calculate the difference when we need it. Substituting a whole loop with an array operation is possible because h and diff(h) are of the same shape (one-dimensional) and size. Notice also that c, dx, and dt are all scalar variables, and they’re compatible with array operations. Stay tuned for more in chapter 5.

3.3 Modifying program state with subroutines
I mentioned earlier that Fortran has two kinds of procedures: functions and subroutines. Many rules that we covered for functions apply to subroutines as well. They’re both designed to be reused many times, and both may have input and output arguments. Unlike functions, subroutines can’t be used in expressions and can only be invoked in a dedicated call statement. They’re more suitable for operations with side effects, such as modifying variables in-place and I/O. In this section, I’ll show you how subroutines are different from functions and when you should use them instead.

3.3.1

Defining and calling a subroutine
Let’s see the difference between a subroutine and a function in an example. The following listing defines a subroutine add that’s equivalent to our function sum from the previous subsection.

Listing 3.13 A subroutine that calculates the sum of two integers

subroutine add(a, b, res) integer, intent(in) :: a, b integer, intent(out) :: res res = a + b
end subroutine add

Inputs arguments like before
Outputs argument that’s returned to the caller

Modifying program state with subroutines

73

Here, a and b are input arguments—notice the intent(in) attribute just like in the sum function—and res is the output argument, with the intent(out) attribute. This subroutine calculates the sum of integers a and b and stores the resulting value into res. These arguments need to be matched in type by the arguments passed in the calling program or procedure.
You invoke a subroutine with a call statement:

call add(3, 5, res)

Calculates the sum of 3 and 5 and stores it into res

As you can see, it’s impossible to invoke a subroutine from an expression, like we did with a function, because Fortran requires a dedicated call statement. Another oddity is that the subroutine itself doesn’t have any value on return, but any result must be returned as an argument with an intent(out) or intent(in out) attribute. This is analogous to void-typed functions in C, or any Python function that doesn’t have a return statement. This is why, as you’ll see in chapter 12, we’ll use subroutines and not functions to interface void-typed C functions in a portable way.
It’s also possible to declare arguments as intent(in out), which would make them both input and output. For an everyday real-world analogy, consider a toaster:
 Your inputs are electric power, a slice of bread, and a setting, such as toasting time and temperature, and you get a toasted slice of bread as a result.
 The electric power and the toaster setting are intent(in) arguments here— they’re not modified or returned by the toaster.
 The slice of bread, however, is an intent(in out) argument.  The bread goes in untoasted, and comes out toasted, warm, and crispy.  The bread is thus modified in-place by the toaster.
Simulating a toaster is thus more appropriate with a subroutine than a function. Figure 3.7 illustrates this scenario. type(bread_type) here is an example of a derived type, which we’ll explore in detail in chapter 8.
Practice some intent(in out) arguments by modifying a global variable with a subroutine in the “Exercise 1” sidebar.

Exercise 1: Modifying state with a subroutine
I discussed earlier the use of the intent attribute in the declaration specification of arguments. You can use the intent(in out) attribute to modify a variable in-place. Can you rewrite the subroutine add (listing 3.13) such that it adds b to a and returns a so that its value is updated in the calling program? For example, the expected behavior should be as shown in listing 3.14.

74

CHAPTER 3 Writing reusable code with functions and subroutines

subroutine toast(bread, power, setting) type(bread_type), intent(in out) :: bread logical, intent(in) :: power integer, intent(in) :: setting
... end subroutine toast

Bread is modiﬁed in-place, and is thus both an input and output argument.

Power and setting are input arguments.

Figure 3.7 An illustration of a subroutine that takes an input/output argument

Listing 3.14 Invoking a subroutine that modifies an input argument in-place

program subroutine_example

implicit none integer :: a a=0

Should print 1 to the screen

call add(a, 1) print *, a call add(a, 2)

Should print 3 to the screen

print *, a contains
...

Define the subroutine “add” here.

end program subroutine_example

You can find the solution to this exercise in the “Answer key” section near the end of this chapter.

3.3.2

When do you use a subroutine over a function?
Whenever I write a new procedure, I use the rules of thumb shown in figure 3.8 to decide whether to make it a function or a subroutine.
This is a simple decision-making process that you can follow. If you know your procedure will cause side effects, such as I/O or modifying a variable declared outside of the procedure, use a subroutine. Also, if you need your procedure to return more than one variable as a result, you have no choice but to use a subroutine. However, these are all special cases. The general rule from figure 3.8 boils down to always using a function unless a subroutine is necessary.

