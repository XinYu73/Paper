GNU Make

GNU Make

A Program for Directing Recompilation GNU make Version 4.3 January 2020

Richard M. Stallman, Roland McGrath, Paul D. Smith

This file documents the GNU make utility, which determines automatically which pieces of a large program need to be recompiled, and issues the commands to recompile them. This is Edition 0.75, last updated 17 January 2020, of The GNU Make Manual, for GNU make version 4.3. Copyright c 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Free Software Foundation, Inc.
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, with the Front-Cover Texts being “A GNU Manual,” and with the Back-Cover Texts as in (a) below. A copy of the license is included in the section entitled “GNU Free Documentation License.” (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and modify this GNU manual. Buying copies from the FSF supports it in developing GNU and promoting software freedom.”
Published by the Free Software Foundation 51 Franklin St. – Fifth Floor Boston, MA 02110-1301 USA ISBN 1-882114-83-3
Cover art by Etienne Suvasa.

i
Short Contents
1 Overview of make. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2 An Introduction to Makefiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 3 Writing Makefiles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 4 Writing Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 5 Writing Recipes in Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 6 How to Use Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 7 Conditional Parts of Makefiles . . . . . . . . . . . . . . . . . . . . . . . . . . 81 8 Functions for Transforming Text . . . . . . . . . . . . . . . . . . . . . . . . 87 9 How to Run make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 10 Using Implicit Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115 11 Using make to Update Archive Files . . . . . . . . . . . . . . . . . . . . . 133 12 Extending GNU make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137 13 Integrating GNU make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 14 Features of GNU make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 15 Incompatibilities and Missing Features . . . . . . . . . . . . . . . . . . 155 16 Makefile Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 A Quick Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173 B Errors Generated by Make . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181 C Complex Makefile Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 D GNU Free Documentation License . . . . . . . . . . . . . . . . . . . . . . 191 Index of Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 Index of Functions, Variables, & Directives . . . . . . . . . . . . . . . . . . . 209

iii
Table of Contents
1 Overview of make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 How to Read This Manual . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 Problems and Bugs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2 An Introduction to Makefiles . . . . . . . . . . . . . . . . . . . 3
2.1 What a Rule Looks Like . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2.2 A Simple Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.3 How make Processes a Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.4 Variables Make Makefiles Simpler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.5 Letting make Deduce the Recipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.6 Another Style of Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.7 Rules for Cleaning the Directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3 Writing Makefiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.1 What Makefiles Contain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 3.1.1 Splitting Long Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.2 What Name to Give Your Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 3.3 Including Other Makefiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 3.4 The Variable MAKEFILES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 3.5 How Makefiles Are Remade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.6 Overriding Part of Another Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 3.7 How make Reads a Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 3.8 How Makefiles Are Parsed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 3.9 Secondary Expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4 Writing Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
4.1 Rule Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 4.2 Types of Prerequisites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 4.3 Using Wildcard Characters in File Names . . . . . . . . . . . . . . . . . . . . . . 25
4.3.1 Wildcard Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 4.3.2 Pitfalls of Using Wildcards. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 4.3.3 The Function wildcard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 4.4 Searching Directories for Prerequisites . . . . . . . . . . . . . . . . . . . . . . . . . 27 4.4.1 VPATH: Search Path for All Prerequisites . . . . . . . . . . . . . . . . . . 27 4.4.2 The vpath Directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 4.4.3 How Directory Searches are Performed . . . . . . . . . . . . . . . . . . . . 29 4.4.4 Writing Recipes with Directory Search . . . . . . . . . . . . . . . . . . . . 29 4.4.5 Directory Search and Implicit Rules . . . . . . . . . . . . . . . . . . . . . . . 30 4.4.6 Directory Search for Link Libraries. . . . . . . . . . . . . . . . . . . . . . . . 30 4.5 Phony Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 4.6 Rules without Recipes or Prerequisites . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.7 Empty Target Files to Record Events . . . . . . . . . . . . . . . . . . . . . . . . . . 33

iv
4.8 Special Built-in Target Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.9 Multiple Targets in a Rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 4.10 Multiple Rules for One Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 4.11 Static Pattern Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.11.1 Syntax of Static Pattern Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.11.2 Static Pattern Rules versus Implicit Rules . . . . . . . . . . . . . . . 40 4.12 Double-Colon Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 4.13 Generating Prerequisites Automatically . . . . . . . . . . . . . . . . . . . . . . . 41

GNU make

5 Writing Recipes in Rules . . . . . . . . . . . . . . . . . . . . . . 43
5.1 Recipe Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 5.1.1 Splitting Recipe Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 5.1.2 Using Variables in Recipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.2 Recipe Echoing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 5.3 Recipe Execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.3.1 Using One Shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 5.3.2 Choosing the Shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 5.4 Parallel Execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 5.4.1 Output During Parallel Execution . . . . . . . . . . . . . . . . . . . . . . . . 49 5.4.2 Input During Parallel Execution . . . . . . . . . . . . . . . . . . . . . . . . . . 51 5.5 Errors in Recipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 5.6 Interrupting or Killing make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 5.7 Recursive Use of make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 5.7.1 How the MAKE Variable Works. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 5.7.2 Communicating Variables to a Sub-make . . . . . . . . . . . . . . . . . . 54 5.7.3 Communicating Options to a Sub-make . . . . . . . . . . . . . . . . . . . 56 5.7.4 The ‘--print-directory’ Option. . . . . . . . . . . . . . . . . . . . . . . . . 57 5.8 Defining Canned Recipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 5.9 Using Empty Recipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

6 How to Use Variables . . . . . . . . . . . . . . . . . . . . . . . . . . 61
6.1 Basics of Variable References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 6.2 The Two Flavors of Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 6.3 Advanced Features for Reference to Variables . . . . . . . . . . . . . . . . . . 64
6.3.1 Substitution References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 6.3.2 Computed Variable Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 6.4 How Variables Get Their Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 6.5 Setting Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 6.6 Appending More Text to Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 6.7 The override Directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 6.8 Defining Multi-Line Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 6.9 Undefining Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 6.10 Variables from the Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 6.11 Target-specific Variable Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 6.12 Pattern-specific Variable Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 6.13 Suppressing Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 6.14 Other Special Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

v
7 Conditional Parts of Makefiles . . . . . . . . . . . . . . . . 81
7.1 Example of a Conditional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 7.2 Syntax of Conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 7.3 Conditionals that Test Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
8 Functions for Transforming Text. . . . . . . . . . . . . . 87
8.1 Function Call Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 8.2 Functions for String Substitution and Analysis . . . . . . . . . . . . . . . . . 88 8.3 Functions for File Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 8.4 Functions for Conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 8.5 The foreach Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 8.6 The file Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 8.7 The call Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 8.8 The value Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 8.9 The eval Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 8.10 The origin Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 8.11 The flavor Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 8.12 Functions That Control Make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 8.13 The shell Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 8.14 The guile Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
9 How to Run make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
9.1 Arguments to Specify the Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 9.2 Arguments to Specify the Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 9.3 Instead of Executing Recipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 9.4 Avoiding Recompilation of Some Files . . . . . . . . . . . . . . . . . . . . . . . . 106 9.5 Overriding Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 9.6 Testing the Compilation of a Program . . . . . . . . . . . . . . . . . . . . . . . . 108 9.7 Summary of Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
10 Using Implicit Rules . . . . . . . . . . . . . . . . . . . . . . . . 115
10.1 Using Implicit Rules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115 10.2 Catalogue of Built-In Rules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 10.3 Variables Used by Implicit Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 10.4 Chains of Implicit Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 10.5 Defining and Redefining Pattern Rules. . . . . . . . . . . . . . . . . . . . . . . 123
10.5.1 Introduction to Pattern Rules . . . . . . . . . . . . . . . . . . . . . . . . . . 123 10.5.2 Pattern Rule Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 10.5.3 Automatic Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 10.5.4 How Patterns Match . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126 10.5.5 Match-Anything Pattern Rules . . . . . . . . . . . . . . . . . . . . . . . . . 127 10.5.6 Canceling Implicit Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 10.6 Defining Last-Resort Default Rules . . . . . . . . . . . . . . . . . . . . . . . . . . 129 10.7 Old-Fashioned Suffix Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129 10.8 Implicit Rule Search Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

vi
11 Using make to Update Archive Files . . . . . . . . 133
11.1 Archive Members as Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 11.2 Implicit Rule for Archive Member Targets . . . . . . . . . . . . . . . . . . . 133
11.2.1 Updating Archive Symbol Directories . . . . . . . . . . . . . . . . . . . 134 11.3 Dangers When Using Archives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 11.4 Suffix Rules for Archive Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135

GNU make

12 Extending GNU make . . . . . . . . . . . . . . . . . . . . . . . . 137
12.1 GNU Guile Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137 12.1.1 Conversion of Guile Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137 12.1.2 Interfaces from Guile to make . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 12.1.3 Example Using Guile in make . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
12.2 Loading Dynamic Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 12.2.1 The load Directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 12.2.2 How Loaded Objects Are Remade . . . . . . . . . . . . . . . . . . . . . . 141 12.2.3 Loaded Object Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141 12.2.4 Example Loaded Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

13 Integrating GNU make . . . . . . . . . . . . . . . . . . . . . . . 147
13.1 Sharing Job Slots with GNU make . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 13.1.1 POSIX Jobserver Interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . 148 13.1.2 Windows Jobserver Interaction . . . . . . . . . . . . . . . . . . . . . . . . . 148
13.2 Synchronized Terminal Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149

14 Features of GNU make . . . . . . . . . . . . . . . . . . . . . . . 151

15 Incompatibilities and Missing Features . . . . 155

16 Makefile Conventions. . . . . . . . . . . . . . . . . . . . . . . . 157
16.1 General Conventions for Makefiles . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 16.2 Utilities in Makefiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 16.3 Variables for Specifying Commands . . . . . . . . . . . . . . . . . . . . . . . . . . 159 16.4 DESTDIR: Support for Staged Installs . . . . . . . . . . . . . . . . . . . . . . . . 160 16.5 Variables for Installation Directories . . . . . . . . . . . . . . . . . . . . . . . . . 160 16.6 Standard Targets for Users . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 16.7 Install Command Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
Appendix A Quick Reference . . . . . . . . . . . . . . . . . . 173

Appendix B Errors Generated by Make . . . . . . 181

Appendix C Complex Makefile Example . . . . . . 185

Appendix D GNU Free Documentation License . . 191

vii
Index of Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
Index of Functions, Variables, & Directives . . . . 209

1
1 Overview of make
The make utility automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them. This manual describes GNU make, which was implemented by Richard Stallman and Roland McGrath. Development since Version 3.76 has been handled by Paul D. Smith.
GNU make conforms to section 6.2 of IEEE Standard 1003.2-1992 (POSIX.2). Our examples show C programs, since they are most common, but you can use make with any programming language whose compiler can be run with a shell command. Indeed, make is not limited to programs. You can use it to describe any task where some files must be updated automatically from others whenever the others change. To prepare to use make, you must write a file called the makefile that describes the relationships among files in your program and provides commands for updating each file. In a program, typically, the executable file is updated from object files, which are in turn made by compiling source files. Once a suitable makefile exists, each time you change some source files, this simple shell command:
make suffices to perform all necessary recompilations. The make program uses the makefile data base and the last-modification times of the files to decide which of the files need to be updated. For each of those files, it issues the recipes recorded in the data base.
You can provide command line arguments to make to control which files should be recompiled, or how. See Chapter 9 [How to Run make], page 103.
1.1 How to Read This Manual
If you are new to make, or are looking for a general introduction, read the first few sections of each chapter, skipping the later sections. In each chapter, the first few sections contain introductory or general information and the later sections contain specialized or technical information. The exception is Chapter 2 [An Introduction to Makefiles], page 3, all of which is introductory.
If you are familiar with other make programs, see Chapter 14 [Features of GNU make], page 151, which lists the enhancements GNU make has, and Chapter 15 [Incompatibilities and Missing Features], page 155, which explains the few things GNU make lacks that others have.
For a quick summary, see Section 9.7 [Options Summary], page 108, Appendix A [Quick Reference], page 173, and Section 4.8 [Special Targets], page 34.
1.2 Problems and Bugs
If you have problems with GNU make or think you’ve found a bug, please report it to the developers; we cannot promise to do anything but we might well want to fix it.
Before reporting a bug, make sure you’ve actually found a real bug. Carefully reread the documentation and see if it really says you can do what you’re trying to do. If it’s not clear whether you should be able to do something or not, report that too; it’s a bug in the documentation!

2

GNU make

Before reporting a bug or trying to fix it yourself, try to isolate it to the smallest possible makefile that reproduces the problem. Then send us the makefile and the exact results make gave you, including any error or warning messages. Please don’t paraphrase these messages: it’s best to cut and paste them into your report. When generating this small makefile, be sure to not use any non-free or unusual tools in your recipes: you can almost always emulate what such a tool would do with simple shell commands. Finally, be sure to explain what you expected to occur; this will help us decide whether the problem was really in the documentation.
Once you have a precise problem you can report it in one of two ways. Either send electronic mail to:
bug-make@gnu.org
or use our Web-based project management tool, at:
http://savannah.gnu.org/projects/make/
In addition to the information above, please be careful to include the version number of make you are using. You can get this information with the command ‘make --version’. Be sure also to include the type of machine and operating system you are using. One way to obtain this information is by looking at the final lines of output from the command ‘make --help’.

3
2 An Introduction to Makefiles
You need a file called a makefile to tell make what to do. Most often, the makefile tells make how to compile and link a program.
In this chapter, we will discuss a simple makefile that describes how to compile and link a text editor which consists of eight C source files and three header files. The makefile can also tell make how to run miscellaneous commands when explicitly asked (for example, to remove certain files as a clean-up operation). To see a more complex example of a makefile, see Appendix C [Complex Makefile], page 185.
When make recompiles the editor, each changed C source file must be recompiled. If a header file has changed, each C source file that includes the header file must be recompiled to be safe. Each compilation produces an object file corresponding to the source file. Finally, if any source file has been recompiled, all the object files, whether newly made or saved from previous compilations, must be linked together to produce the new executable editor.
2.1 What a Rule Looks Like
A simple makefile consists of “rules” with the following shape:
target ... : prerequisites ... recipe ... ...
A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see Section 4.5 [Phony Targets], page 31).
A prerequisite is a file that is used as input to create the target. A target often depends on several files.
A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character (see Section 6.14 [Special Variables], page 75).
Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target ‘clean’ does not have prerequisites.
A rule, then, explains how and when to remake certain files which are the targets of the particular rule. make carries out the recipe on the prerequisites to create or update the target. A rule can also explain how and when to carry out an action. See Chapter 4 [Writing Rules], page 23.
A makefile may contain other text besides rules, but a simple makefile need only contain rules. Rules may look somewhat more complicated than shown in this template, but all fit the pattern more or less.

4

GNU make

2.2 A Simple Makefile
Here is a straightforward makefile that describes the way an executable file called edit depends on eight object files which, in turn, depend on eight C source and three header files.
In this example, all the C files include defs.h, but only those defining editing commands include command.h, and only low level files that change the editor buffer include buffer.h.
edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
main.o : main.c defs.h cc -c main.c
kbd.o : kbd.c defs.h command.h cc -c kbd.c
command.o : command.c defs.h command.h cc -c command.c
display.o : display.c defs.h buffer.h cc -c display.c
insert.o : insert.c defs.h buffer.h cc -c insert.c
search.o : search.c defs.h buffer.h cc -c search.c
files.o : files.c defs.h buffer.h command.h cc -c files.c
utils.o : utils.c defs.h cc -c utils.c
clean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
We split each long line into two lines using backslash/newline; this is like using one long line, but is easier to read. See Section 3.1.1 [Splitting Long Lines], page 12.
To use this makefile to create the executable file called edit, type:
make To use this makefile to delete the executable file and all the object files from the directory, type:
make clean In the example makefile, the targets include the executable file ‘edit’, and the object files ‘main.o’ and ‘kbd.o’. The prerequisites are files such as ‘main.c’ and ‘defs.h’. In fact, each ‘.o’ file is both a target and a prerequisite. Recipes include ‘cc -c main.c’ and ‘cc -c kbd.c’. When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first. In this example, edit depends on each of the eight object files; the object file main.o depends on the source file main.c and on the header file defs.h.

Chapter 2: An Introduction to Makefiles

5

A recipe may follow each line that contains a target and prerequisites. These recipes say how to update the target file. A tab character (or whatever character is specified by the .RECIPEPREFIX variable; see Section 6.14 [Special Variables], page 75) must come at the beginning of every line in the recipe to distinguish recipes from other lines in the makefile. (Bear in mind that make does not know anything about how the recipes work. It is up to you to supply recipes that will update the target file properly. All make does is execute the recipe you have specified when the target file needs to be updated.)
The target ‘clean’ is not a file, but merely the name of an action. Since you normally do not want to carry out the actions in this rule, ‘clean’ is not a prerequisite of any other rule. Consequently, make never does anything with it unless you tell it specifically. Note that this rule not only is not a prerequisite, it also does not have any prerequisites, so the only purpose of the rule is to run the specified recipe. Targets that do not refer to files but are just actions are called phony targets. See Section 4.5 [Phony Targets], page 31, for information about this kind of target. See Section 5.5 [Errors in Recipes], page 51, to see how to cause make to ignore errors from rm or any other command.
2.3 How make Processes a Makefile
By default, make starts with the first target (not targets whose names start with ‘.’). This is called the default goal. (Goals are the targets that make strives ultimately to update. You can override this behavior using the command line (see Section 9.2 [Arguments to Specify the Goals], page 103) or with the .DEFAULT_GOAL special variable (see Section 6.14 [Other Special Variables], page 75).
In the simple example of the previous section, the default goal is to update the executable program edit; therefore, we put that rule first.
Thus, when you give the command:
make
make reads the makefile in the current directory and begins by processing the first rule. In the example, this rule is for relinking edit; but before make can fully process this rule, it must process the rules for the files that edit depends on, which in this case are the object files. Each of these files is processed according to its own rule. These rules say to update each ‘.o’ file by compiling its source file. The recompilation must be done if the source file, or any of the header files named as prerequisites, is more recent than the object file, or if the object file does not exist.
The other rules are processed because their targets appear as prerequisites of the goal. If some other rule is not depended on by the goal (or anything it depends on, etc.), that rule is not processed, unless you tell make to do so (with a command such as make clean).
Before recompiling an object file, make considers updating its prerequisites, the source file and header files. This makefile does not specify anything to be done for them—the ‘.c’ and ‘.h’ files are not the targets of any rules—so make does nothing for these files. But make would update automatically generated C programs, such as those made by Bison or Yacc, by their own rules at this time.
After recompiling whichever object files need it, make decides whether to relink edit. This must be done if the file edit does not exist, or if any of the object files are newer than it. If an object file was just recompiled, it is now newer than edit, so edit is relinked.

6

GNU make

Thus, if we change the file insert.c and run make, make will compile that file to update insert.o, and then link edit. If we change the file command.h and run make, make will recompile the object files kbd.o, command.o and files.o and then link the file edit.
2.4 Variables Make Makefiles Simpler
In our example, we had to list all the object files twice in the rule for edit (repeated here):
edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
Such duplication is error-prone; if a new object file is added to the system, we might add it to one list and forget the other. We can eliminate the risk and simplify the makefile by using a variable. Variables allow a text string to be defined once and substituted in multiple places later (see Chapter 6 [How to Use Variables], page 61).
It is standard practice for every makefile to have a variable named objects, OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object file names. We would define such a variable objects with a line like this in the makefile:
objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
Then, each place we want to put a list of the object file names, we can substitute the variable’s value by writing ‘$(objects)’ (see Chapter 6 [How to Use Variables], page 61).
Here is how the complete simple makefile looks when you use a variable for the object files:

Chapter 2: An Introduction to Makefiles

7

objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
edit : $(objects) cc -o edit $(objects)
main.o : main.c defs.h cc -c main.c
kbd.o : kbd.c defs.h command.h cc -c kbd.c
command.o : command.c defs.h command.h cc -c command.c
display.o : display.c defs.h buffer.h cc -c display.c
insert.o : insert.c defs.h buffer.h cc -c insert.c
search.o : search.c defs.h buffer.h cc -c search.c
files.o : files.c defs.h buffer.h command.h cc -c files.c
utils.o : utils.c defs.h cc -c utils.c
clean : rm edit $(objects)

2.5 Letting make Deduce the Recipes
It is not necessary to spell out the recipes for compiling the individual C source files, because make can figure them out: it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command. For example, it will use the recipe ‘cc -c main.c -o main.o’ to compile main.c into main.o. We can therefore omit the recipes from the rules for the object files. See Chapter 10 [Using Implicit Rules], page 115.
When a ‘.c’ file is used automatically in this way, it is also automatically added to the list of prerequisites. We can therefore omit the ‘.c’ files from the prerequisites, provided we omit the recipe.
Here is the entire example, with both of these changes, and a variable objects as suggested above:

8

GNU make

objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
edit : $(objects) cc -o edit $(objects)
main.o : defs.h kbd.o : defs.h command.h command.o : defs.h command.h display.o : defs.h buffer.h insert.o : defs.h buffer.h search.o : defs.h buffer.h files.o : defs.h buffer.h command.h utils.o : defs.h
.PHONY : clean clean :
rm edit $(objects)
This is how we would write the makefile in actual practice. (The complications associated with ‘clean’ are described elsewhere. See Section 4.5 [Phony Targets], page 31, and Section 5.5 [Errors in Recipes], page 51.)
Because implicit rules are so convenient, they are important. You will see them used frequently.
2.6 Another Style of Makefile
When the objects of a makefile are created only by implicit rules, an alternative style of makefile is possible. In this style of makefile, you group entries by their prerequisites instead of by their targets. Here is what one looks like:
objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o
edit : $(objects) cc -o edit $(objects)
$(objects) : defs.h kbd.o command.o files.o : command.h display.o insert.o search.o files.o : buffer.h
Here defs.h is given as a prerequisite of all the object files; command.h and buffer.h are prerequisites of the specific object files listed for them.
Whether this is better is a matter of taste: it is more compact, but some people dislike it because they find it clearer to put all the information about each target in one place.

Chapter 2: An Introduction to Makefiles

9

2.7 Rules for Cleaning the Directory
Compiling a program is not the only thing you might want to write rules for. Makefiles commonly tell how to do a few other things besides compiling a program: for example, how to delete all the object files and executables so that the directory is ‘clean’.
Here is how we could write a make rule for cleaning our example editor:
clean: rm edit $(objects)
In practice, we might want to write the rule in a somewhat more complicated manner to handle unanticipated situations. We would do this:
.PHONY : clean clean :
-rm edit $(objects)
This prevents make from getting confused by an actual file called clean and causes it to continue in spite of errors from rm. (See Section 4.5 [Phony Targets], page 31, and Section 5.5 [Errors in Recipes], page 51.)
A rule such as this should not be placed at the beginning of the makefile, because we do not want it to run by default! Thus, in the example makefile, we want the rule for edit, which recompiles the editor, to remain the default goal.
Since clean is not a prerequisite of edit, this rule will not run at all if we give the command ‘make’ with no arguments. In order to make the rule run, we have to type ‘make clean’. See Chapter 9 [How to Run make], page 103.

11
3 Writing Makefiles
The information that tells make how to recompile a system comes from reading a data base called the makefile.
3.1 What Makefiles Contain
Makefiles contain five kinds of things: explicit rules, implicit rules, variable definitions, directives, and comments. Rules, variables, and directives are described at length in later chapters.
• An explicit rule says when and how to remake one or more files, called the rule’s targets. It lists the other files that the targets depend on, called the prerequisites of the target, and may also give a recipe to use to create or update the targets. See Chapter 4 [Writing Rules], page 23.
• An implicit rule says when and how to remake a class of files based on their names. It describes how a target may depend on a file with a name similar to the target and gives a recipe to create or update such a target. See Chapter 10 [Using Implicit Rules], page 115.
• A variable definition is a line that specifies a text string value for a variable that can be substituted into the text later. The simple makefile example shows a variable definition for objects as a list of all object files (see Section 2.4 [Variables Make Makefiles Simpler], page 6).
• A directive is an instruction for make to do something special while reading the makefile. These include: • Reading another makefile (see Section 3.3 [Including Other Makefiles], page 13). • Deciding (based on the values of variables) whether to use or ignore a part of the makefile (see Chapter 7 [Conditional Parts of Makefiles], page 81). • Defining a variable from a verbatim string containing multiple lines (see Section 6.8 [Defining Multi-Line Variables], page 71).
• ‘#’ in a line of a makefile starts a comment. It and the rest of the line are ignored, except that a trailing backslash not escaped by another backslash will continue the comment across multiple lines. A line containing just a comment (with perhaps spaces before it) is effectively blank, and is ignored. If you want a literal #, escape it with a backslash (e.g., \#). Comments may appear on any line in the makefile, although they are treated specially in certain situations. You cannot use comments within variable references or function calls: any instance of # will be treated literally (rather than as the start of a comment) inside a variable reference or function call. Comments within a recipe are passed to the shell, just as with any other recipe text. The shell decides how to interpret it: whether or not this is a comment is up to the shell. Within a define directive, comments are not ignored during the definition of the variable, but rather kept intact in the value of the variable. When the variable is expanded they will either be treated as make comments or as recipe text, depending on the context in which the variable is evaluated.

12

GNU make

3.1.1 Splitting Long Lines
Makefiles use a “line-based” syntax in which the newline character is special and marks the end of a statement. GNU make has no limit on the length of a statement line, up to the amount of memory in your computer.
However, it is difficult to read lines which are too long to display without wrapping or scrolling. So, you can format your makefiles for readability by adding newlines into the middle of a statement: you do this by escaping the internal newlines with a backslash (\) character. Where we need to make a distinction we will refer to “physical lines” as a single line ending with a newline (regardless of whether it is escaped) and a “logical line” being a complete statement including all escaped newlines up to the first non-escaped newline.
The way in which backslash/newline combinations are handled depends on whether the statement is a recipe line or a non-recipe line. Handling of backslash/newline in a recipe line is discussed later (see Section 5.1.1 [Splitting Recipe Lines], page 43).
Outside of recipe lines, backslash/newlines are converted into a single space character. Once that is done, all whitespace around the backslash/newline is condensed into a single space: this includes all whitespace preceding the backslash, all whitespace at the beginning of the line after the backslash/newline, and any consecutive backslash/newline combinations.
If the .POSIX special target is defined then backslash/newline handling is modified slightly to conform to POSIX.2: first, whitespace preceding a backslash is not removed and second, consecutive backslash/newlines are not condensed.
Splitting Without Adding Whitespace
If you need to split a line but do not want any whitespace added, you can utilize a subtle trick: replace your backslash/newline pairs with the three characters dollar sign/backslash/newline:
var := one$\ word
After make removes the backslash/newline and condenses the following line into a single space, this is equivalent to:
var := one$ word
Then make will perform variable expansion. The variable reference ‘$ ’ refers to a variable with the one-character name “ ” (space) which does not exist, and so expands to the empty string, giving a final assignment which is the equivalent of:
var := oneword
3.2 What Name to Give Your Makefile
By default, when make looks for the makefile, it tries the following names, in order: GNUmakefile, makefile and Makefile.
Normally you should call your makefile either makefile or Makefile. (We recommend Makefile because it appears prominently near the beginning of a directory listing, right near other important files such as README.) The first name checked, GNUmakefile, is not recommended for most makefiles. You should use this name if you have a makefile that is

Chapter 3: Writing Makefiles

13

specific to GNU make, and will not be understood by other versions of make. Other make programs look for makefile and Makefile, but not GNUmakefile.
If make finds none of these names, it does not use any makefile. Then you must specify a goal with a command argument, and make will attempt to figure out how to remake it using only its built-in implicit rules. See Chapter 10 [Using Implicit Rules], page 115.
If you want to use a nonstandard name for your makefile, you can specify the makefile name with the ‘-f’ or ‘--file’ option. The arguments ‘-f name’ or ‘--file=name’ tell make to read the file name as the makefile. If you use more than one ‘-f’ or ‘--file’ option, you can specify several makefiles. All the makefiles are effectively concatenated in the order specified. The default makefile names GNUmakefile, makefile and Makefile are not checked automatically if you specify ‘-f’ or ‘--file’.
3.3 Including Other Makefiles
The include directive tells make to suspend reading the current makefile and read one or more other makefiles before continuing. The directive is a line in the makefile that looks like this:
include filenames...
filenames can contain shell file name patterns. If filenames is empty, nothing is included and no error is printed.
Extra spaces are allowed and ignored at the beginning of the line, but the first character must not be a tab (or the value of .RECIPEPREFIX)—if the line begins with a tab, it will be considered a recipe line. Whitespace is required between include and the file names, and between file names; extra whitespace is ignored there and at the end of the directive. A comment starting with ‘#’ is allowed at the end of the line. If the file names contain any variable or function references, they are expanded. See Chapter 6 [How to Use Variables], page 61.
For example, if you have three .mk files, a.mk, b.mk, and c.mk, and $(bar) expands to bish bash, then the following expression
include foo *.mk $(bar)
is equivalent to
include foo a.mk b.mk c.mk bish bash
When make processes an include directive, it suspends reading of the containing makefile and reads from each listed file in turn. When that is finished, make resumes reading the makefile in which the directive appears.
One occasion for using include directives is when several programs, handled by individual makefiles in various directories, need to use a common set of variable definitions (see Section 6.5 [Setting Variables], page 67) or pattern rules (see Section 10.5 [Defining and Redefining Pattern Rules], page 123).
Another such occasion is when you want to generate prerequisites from source files automatically; the prerequisites can be put in a file that is included by the main makefile. This practice is generally cleaner than that of somehow appending the prerequisites to the end of the main makefile as has been traditionally done with other versions of make. See Section 4.13 [Automatic Prerequisites], page 41.

14

GNU make

If the specified name does not start with a slash, and the file is not found in the current directory, several other directories are searched. First, any directories you have specified with the ‘-I’ or ‘--include-dir’ option are searched (see Section 9.7 [Summary of Options], page 108). Then the following directories (if they exist) are searched, in this order: prefix/include (normally /usr/local/include1) /usr/gnu/include, /usr/local/include, /usr/include.
If an included makefile cannot be found in any of these directories, a warning message is generated, but it is not an immediately fatal error; processing of the makefile containing the include continues. Once it has finished reading makefiles, make will try to remake any that are out of date or don’t exist. See Section 3.5 [How Makefiles Are Remade], page 15. Only after it has tried to find a way to remake a makefile and failed, will make diagnose the missing makefile as a fatal error.
If you want make to simply ignore a makefile which does not exist or cannot be remade, with no error message, use the -include directive instead of include, like this:
-include filenames...
This acts like include in every way except that there is no error (not even a warning) if any of the filenames (or any prerequisites of any of the filenames) do not exist or cannot be remade.
For compatibility with some other make implementations, sinclude is another name for -include.
3.4 The Variable MAKEFILES
If the environment variable MAKEFILES is defined, make considers its value as a list of names (separated by whitespace) of additional makefiles to be read before the others. This works much like the include directive: various directories are searched for those files (see Section 3.3 [Including Other Makefiles], page 13). In addition, the default goal is never taken from one of these makefiles (or any makefile included by them) and it is not an error if the files listed in MAKEFILES are not found.
The main use of MAKEFILES is in communication between recursive invocations of make (see Section 5.7 [Recursive Use of make], page 53). It usually is not desirable to set the environment variable before a top-level invocation of make, because it is usually better not to mess with a makefile from outside. However, if you are running make without a specific makefile, a makefile in MAKEFILES can do useful things to help the built-in implicit rules work better, such as defining search paths (see Section 4.4 [Directory Search], page 27).
Some users are tempted to set MAKEFILES in the environment automatically on login, and program makefiles to expect this to be done. This is a very bad idea, because such makefiles will fail to work if run by anyone else. It is much better to write explicit include directives in the makefiles. See Section 3.3 [Including Other Makefiles], page 13.
1 GNU Make compiled for MS-DOS and MS-Windows behaves as if prefix has been defined to be the root of the DJGPP tree hierarchy.

Chapter 3: Writing Makefiles

15

3.5 How Makefiles Are Remade
Sometimes makefiles can be remade from other files, such as RCS or SCCS files. If a makefile can be remade from other files, you probably want make to get an up-to-date version of the makefile to read in.
To this end, after reading in all makefiles make will consider each as a goal target and attempt to update it. If a makefile has a rule which says how to update it (found either in that very makefile or in another one) or if an implicit rule applies to it (see Chapter 10 [Using Implicit Rules], page 115), it will be updated if necessary. After all makefiles have been checked, if any have actually been changed, make starts with a clean slate and reads all the makefiles over again. (It will also attempt to update each of them over again, but normally this will not change them again, since they are already up to date.) Each restart will cause the special variable MAKE_RESTARTS to be updated (see Section 6.14 [Special Variables], page 75).
If you know that one or more of your makefiles cannot be remade and you want to keep make from performing an implicit rule search on them, perhaps for efficiency reasons, you can use any normal method of preventing implicit rule look-up to do so. For example, you can write an explicit rule with the makefile as the target, and an empty recipe (see Section 5.9 [Using Empty Recipes], page 59).
If the makefiles specify a double-colon rule to remake a file with a recipe but no prerequisites, that file will always be remade (see Section 4.12 [Double-Colon], page 40). In the case of makefiles, a makefile that has a double-colon rule with a recipe but no prerequisites will be remade every time make is run, and then again after make starts over and reads the makefiles in again. This would cause an infinite loop: make would constantly remake the makefile, and never do anything else. So, to avoid this, make will not attempt to remake makefiles which are specified as targets of a double-colon rule with a recipe but no prerequisites.
If you do not specify any makefiles to be read with ‘-f’ or ‘--file’ options, make will try the default makefile names; see Section 3.2 [What Name to Give Your Makefile], page 12. Unlike makefiles explicitly requested with ‘-f’ or ‘--file’ options, make is not certain that these makefiles should exist. However, if a default makefile does not exist but can be created by running make rules, you probably want the rules to be run so that the makefile can be used.
Therefore, if none of the default makefiles exists, make will try to make each of them in the same order in which they are searched for (see Section 3.2 [What Name to Give Your Makefile], page 12) until it succeeds in making one, or it runs out of names to try. Note that it is not an error if make cannot find or make any makefile; a makefile is not always necessary.
When you use the ‘-t’ or ‘--touch’ option (see Section 9.3 [Instead of Executing Recipes], page 105), you would not want to use an out-of-date makefile to decide which targets to touch. So the ‘-t’ option has no effect on updating makefiles; they are really updated even if ‘-t’ is specified. Likewise, ‘-q’ (or ‘--question’) and ‘-n’ (or ‘--just-print’) do not prevent updating of makefiles, because an out-of-date makefile would result in the wrong output for other targets. Thus, ‘make -f mfile -n foo’ will update mfile, read it in, and then print the recipe to update foo and its prerequisites without running it. The recipe printed for foo will be the one specified in the updated contents of mfile.

16

GNU make

However, on occasion you might actually wish to prevent updating of even the makefiles. You can do this by specifying the makefiles as goals in the command line as well as specifying them as makefiles. When the makefile name is specified explicitly as a goal, the options ‘-t’ and so on do apply to them.
Thus, ‘make -f mfile -n mfile foo’ would read the makefile mfile, print the recipe needed to update it without actually running it, and then print the recipe needed to update foo without running that. The recipe for foo will be the one specified by the existing contents of mfile.

3.6 Overriding Part of Another Makefile

Sometimes it is useful to have a makefile that is mostly just like another makefile. You can often use the ‘include’ directive to include one in the other, and add more targets or variable definitions. However, it is invalid for two makefiles to give different recipes for the same target. But there is another way.

In the containing makefile (the one that wants to include the other), you can use a match-anything pattern rule to say that to remake any target that cannot be made from the information in the containing makefile, make should look in another makefile. See Section 10.5 [Pattern Rules], page 123, for more information on pattern rules.

For example, if you have a makefile called Makefile that says how to make the target ‘foo’ (and other targets), you can write a makefile called GNUmakefile that contains:

foo:

frobnicate > foo

%: force @$(MAKE) -f Makefile $@
force: ;
If you say ‘make foo’, make will find GNUmakefile, read it, and see that to make foo, it needs to run the recipe ‘frobnicate > foo’. If you say ‘make bar’, make will find no way to make bar in GNUmakefile, so it will use the recipe from the pattern rule: ‘make -f Makefile bar’. If Makefile provides a rule for updating bar, make will apply the rule. And likewise for any other target that GNUmakefile does not say how to make.
The way this works is that the pattern rule has a pattern of just ‘%’, so it matches any target whatever. The rule specifies a prerequisite force, to guarantee that the recipe will be run even if the target file already exists. We give the force target an empty recipe to prevent make from searching for an implicit rule to build it—otherwise it would apply the same match-anything rule to force itself and create a prerequisite loop!

3.7 How make Reads a Makefile
GNU make does its work in two distinct phases. During the first phase it reads all the makefiles, included makefiles, etc. and internalizes all the variables and their values and implicit and explicit rules, and builds a dependency graph of all the targets and their prerequisites. During the second phase, make uses this internalized data to determine which targets need to be updated and run the recipes necessary to update them.

Chapter 3: Writing Makefiles

17

It’s important to understand this two-phase approach because it has a direct impact on how variable and function expansion happens; this is often a source of some confusion when writing makefiles. Below is a summary of the different constructs that can be found in a makefile, and the phase in which expansion happens for each part of the construct.
We say that expansion is immediate if it happens during the first phase: make will expand that part of the construct as the makefile is parsed. We say that expansion is deferred if it is not immediate. Expansion of a deferred construct part is delayed until the expansion is used: either when it is referenced in an immediate context, or when it is needed during the second phase.
You may not be familiar with some of these constructs yet. You can reference this section as you become familiar with them, in later chapters.
Variable Assignment
Variable definitions are parsed as follows: immediate = deferred immediate ?= deferred immediate := immediate immediate ::= immediate immediate += deferred or immediate immediate != immediate
define immediate deferred
endef
define immediate = deferred
endef
define immediate ?= deferred
endef
define immediate := immediate
endef
define immediate ::= immediate
endef
define immediate += deferred or immediate
endef
define immediate !=

18

GNU make

immediate endef For the append operator ‘+=’, the right-hand side is considered immediate if the variable was previously set as a simple variable (‘:=’ or ‘::=’), and deferred otherwise. For the shell assignment operator ‘!=’, the right-hand side is evaluated immediately and handed to the shell. The result is stored in the variable named on the left, and that variable becomes a simple variable (and will thus be re-evaluated on each reference).
Conditional Directives
Conditional directives are parsed immediately. This means, for example, that automatic variables cannot be used in conditional directives, as automatic variables are not set until the recipe for that rule is invoked. If you need to use automatic variables in a conditional directive you must move the condition into the recipe and use shell conditional syntax instead.
Rule Definition
A rule is always expanded the same way, regardless of the form: immediate : immediate ; deferred deferred
That is, the target and prerequisite sections are expanded immediately, and the recipe used to build the target is always deferred. This is true for explicit rules, pattern rules, suffix rules, static pattern rules, and simple prerequisite definitions.
3.8 How Makefiles Are Parsed
GNU make parses makefiles line-by-line. Parsing proceeds using the following steps: 1. Read in a full logical line, including backslash-escaped lines (see Section 3.1.1 [Splitting Long Lines], page 12). 2. Remove comments (see Section 3.1 [What Makefiles Contain], page 11). 3. If the line begins with the recipe prefix character and we are in a rule context, add the line to the current recipe and read the next line (see Section 5.1 [Recipe Syntax], page 43). 4. Expand elements of the line which appear in an immediate expansion context (see Section 3.7 [How make Reads a Makefile], page 16). 5. Scan the line for a separator character, such as ‘:’ or ‘=’, to determine whether the line is a macro assignment or a rule (see Section 5.1 [Recipe Syntax], page 43). 6. Internalize the resulting operation and read the next line.
An important consequence of this is that a macro can expand to an entire rule, if it is one line long. This will work:
myrule = target : ; echo built
$(myrule) However, this will not work because make does not re-split lines after it has expanded them:
define myrule

Chapter 3: Writing Makefiles

19

target: echo built
endef
$(myrule) The above makefile results in the definition of a target ‘target’ with prerequisites ‘echo’ and ‘built’, as if the makefile contained target: echo built, rather than a rule with a recipe. Newlines still present in a line after expansion is complete are ignored as normal whitespace.
In order to properly expand a multi-line macro you must use the eval function: this causes the make parser to be run on the results of the expanded macro (see Section 8.9 [Eval Function], page 97).
3.9 Secondary Expansion
Previously we learned that GNU make works in two distinct phases: a read-in phase and a target-update phase (see Section 3.7 [How make Reads a Makefile], page 16). GNU make also has the ability to enable a second expansion of the prerequisites (only) for some or all targets defined in the makefile. In order for this second expansion to occur, the special target .SECONDEXPANSION must be defined before the first prerequisite list that makes use of this feature.
If that special target is defined then in between the two phases mentioned above, right at the end of the read-in phase, all the prerequisites of the targets defined after the special target are expanded a second time. In most circumstances this secondary expansion will have no effect, since all variable and function references will have been expanded during the initial parsing of the makefiles. In order to take advantage of the secondary expansion phase of the parser, then, it’s necessary to escape the variable or function reference in the makefile. In this case the first expansion merely un-escapes the reference but doesn’t expand it, and expansion is left to the secondary expansion phase. For example, consider this makefile:
.SECONDEXPANSION: ONEVAR = onefile TWOVAR = twofile myfile: $(ONEVAR) $$(TWOVAR) After the first expansion phase the prerequisites list of the myfile target will be onefile and $(TWOVAR); the first (unescaped) variable reference to ONEVAR is expanded, while the second (escaped) variable reference is simply unescaped, without being recognized as a variable reference. Now during the secondary expansion the first word is expanded again but since it contains no variable or function references it remains the value onefile, while the second word is now a normal reference to the variable TWOVAR, which is expanded to the value twofile. The final result is that there are two prerequisites, onefile and twofile. Obviously, this is not a very interesting case since the same result could more easily have been achieved simply by having both variables appear, unescaped, in the prerequisites list. One difference becomes apparent if the variables are reset; consider this example:
.SECONDEXPANSION: AVAR = top

20

GNU make

onefile: $(AVAR) twofile: $$(AVAR) AVAR = bottom Here the prerequisite of onefile will be expanded immediately, and resolve to the value top, while the prerequisite of twofile will not be full expanded until the secondary expansion and yield a value of bottom. This is marginally more exciting, but the true power of this feature only becomes apparent when you discover that secondary expansions always take place within the scope of the automatic variables for that target. This means that you can use variables such as $@, $*, etc. during the second expansion and they will have their expected values, just as in the recipe. All you have to do is defer the expansion by escaping the $. Also, secondary expansion occurs for both explicit and implicit (pattern) rules. Knowing this, the possible uses for this feature increase dramatically. For example:
.SECONDEXPANSION: main_OBJS := main.o try.o test.o lib_OBJS := lib.o api.o
main lib: $$($$@_OBJS) Here, after the initial expansion the prerequisites of both the main and lib targets will be $($@_OBJS). During the secondary expansion, the $@ variable is set to the name of the target and so the expansion for the main target will yield $(main_OBJS), or main.o try.o test.o, while the secondary expansion for the lib target will yield $(lib_OBJS), or lib.o api.o. You can also mix in functions here, as long as they are properly escaped:
main_SRCS := main.c try.c test.c lib_SRCS := lib.c api.c
.SECONDEXPANSION: main lib: $$(patsubst %.c,%.o,$$($$@_SRCS)) This version allows users to specify source files rather than object files, but gives the same resulting prerequisites list as the previous example. Evaluation of automatic variables during the secondary expansion phase, especially of the target name variable $$@, behaves similarly to evaluation within recipes. However, there are some subtle differences and “corner cases” which come into play for the different types of rule definitions that make understands. The subtleties of using the different automatic variables are described below.
Secondary Expansion of Explicit Rules
During the secondary expansion of explicit rules, $$@ and $$% evaluate, respectively, to the file name of the target and, when the target is an archive member, the target member name. The $$< variable evaluates to the first prerequisite in the first rule for this target. $$^ and $$+ evaluate to the list of all prerequisites of rules that have already appeared for the same target ($$+ with repetitions and $$^ without). The following example will help illustrate these behaviors:
.SECONDEXPANSION:

Chapter 3: Writing Makefiles

21

foo: foo.1 bar.1 $$< $$^ $$+ # line #1
foo: foo.2 bar.2 $$< $$^ $$+ # line #2
foo: foo.3 bar.3 $$< $$^ $$+ # line #3 In the first prerequisite list, all three variables ($$<, $$^, and $$+) expand to the empty string. In the second, they will have values foo.1, foo.1 bar.1, and foo.1 bar.1 respectively. In the third they will have values foo.1, foo.1 bar.1 foo.2 bar.2, and foo.1 bar.1 foo.2 bar.2 foo.1 foo.1 bar.1 foo.1 bar.1 respectively. Rules undergo secondary expansion in makefile order, except that the rule with the recipe is always evaluated last. The variables $$? and $$* are not available and expand to the empty string.
Secondary Expansion of Static Pattern Rules
Rules for secondary expansion of static pattern rules are identical to those for explicit rules, above, with one exception: for static pattern rules the $$* variable is set to the pattern stem. As with explicit rules, $$? is not available and expands to the empty string.
Secondary Expansion of Implicit Rules
As make searches for an implicit rule, it substitutes the stem and then performs secondary expansion for every rule with a matching target pattern. The value of the automatic variables is derived in the same fashion as for static pattern rules. As an example:
.SECONDEXPANSION:
foo: bar
foo foz: fo%: bo%
%oo: $$< $$^ $$+ $$* When the implicit rule is tried for target foo, $$< expands to bar, $$^ expands to bar boo, $$+ also expands to bar boo, and $$* expands to f. Note that the directory prefix (D), as described in Section 10.8 [Implicit Rule Search Algorithm], page 131, is appended (after expansion) to all the patterns in the prerequisites list. As an example:
.SECONDEXPANSION:
/tmp/foo.o:
%.o: $$(addsuffix /%.c,foo bar) foo.h @echo $^
The prerequisite list printed, after the secondary expansion and directory prefix reconstruction, will be /tmp/foo/foo.c /tmp/bar/foo.c foo.h. If you are not interested in this reconstruction, you can use $$* instead of % in the prerequisites list.

23
4 Writing Rules
A rule appears in the makefile and says when and how to remake certain files, called the rule’s targets (most often only one per rule). It lists the other files that are the prerequisites of the target, and the recipe to use to create or update the target.
The order of rules is not significant, except for determining the default goal: the target for make to consider, if you do not otherwise specify one. The default goal is the target of the first rule in the first makefile. If the first rule has multiple targets, only the first target is taken as the default. There are two exceptions: a target starting with a period is not a default unless it contains one or more slashes, ‘/’, as well; and, a target that defines a pattern rule has no effect on the default goal. (See Section 10.5 [Defining and Redefining Pattern Rules], page 123.)
Therefore, we usually write the makefile so that the first rule is the one for compiling the entire program or all the programs described by the makefile (often with a target called ‘all’). See Section 9.2 [Arguments to Specify the Goals], page 103.
4.1 Rule Syntax
In general, a rule looks like this:
targets : prerequisites recipe ...
or like this:
targets : prerequisites ; recipe recipe ...
The targets are file names, separated by spaces. Wildcard characters may be used (see Section 4.3 [Using Wildcard Characters in File Names], page 25) and a name of the form a(m) represents member m in archive file a (see Section 11.1 [Archive Members as Targets], page 133). Usually there is only one target per rule, but occasionally there is a reason to have more (see Section 4.9 [Multiple Targets in a Rule], page 36).
The recipe lines start with a tab character (or the first character in the value of the .RECIPEPREFIX variable; see Section 6.14 [Special Variables], page 75). The first recipe line may appear on the line after the prerequisites, with a tab character, or may appear on the same line, with a semicolon. Either way, the effect is the same. There are other differences in the syntax of recipes. See Chapter 5 [Writing Recipes in Rules], page 43.
Because dollar signs are used to start make variable references, if you really want a dollar sign in a target or prerequisite you must write two of them, ‘$$’ (see Chapter 6 [How to Use Variables], page 61). If you have enabled secondary expansion (see Section 3.9 [Secondary Expansion], page 19) and you want a literal dollar sign in the prerequisites list, you must actually write four dollar signs (‘$$$$’).
You may split a long line by inserting a backslash followed by a newline, but this is not required, as make places no limit on the length of a line in a makefile.
A rule tells make two things: when the targets are out of date, and how to update them when necessary.

24

GNU make

The criterion for being out of date is specified in terms of the prerequisites, which consist of file names separated by spaces. (Wildcards and archive members (see Chapter 11 [Archives], page 133) are allowed here too.) A target is out of date if it does not exist or if it is older than any of the prerequisites (by comparison of last-modification times). The idea is that the contents of the target file are computed based on information in the prerequisites, so if any of the prerequisites changes, the contents of the existing target file are no longer necessarily valid.
How to update is specified by a recipe. This is one or more lines to be executed by the shell (normally ‘sh’), but with some extra features (see Chapter 5 [Writing Recipes in Rules], page 43).
4.2 Types of Prerequisites
There are actually two different types of prerequisites understood by GNU make: normal prerequisites such as described in the previous section, and order-only prerequisites. A normal prerequisite makes two statements: first, it imposes an order in which recipes will be invoked: the recipes for all prerequisites of a target will be completed before the recipe for the target is run. Second, it imposes a dependency relationship: if any prerequisite is newer than the target, then the target is considered out-of-date and must be rebuilt.
Normally, this is exactly what you want: if a target’s prerequisite is updated, then the target should also be updated.
Occasionally, however, you have a situation where you want to impose a specific ordering on the rules to be invoked without forcing the target to be updated if one of those rules is executed. In that case, you want to define order-only prerequisites. Order-only prerequisites can be specified by placing a pipe symbol (|) in the prerequisites list: any prerequisites to the left of the pipe symbol are normal; any prerequisites to the right are order-only:
targets : normal-prerequisites | order-only-prerequisites The normal prerequisites section may of course be empty. Also, you may still declare multiple lines of prerequisites for the same target: they are appended appropriately (normal prerequisites are appended to the list of normal prerequisites; order-only prerequisites are appended to the list of order-only prerequisites). Note that if you declare the same file to be both a normal and an order-only prerequisite, the normal prerequisite takes precedence (since they have a strict superset of the behavior of an order-only prerequisite). Consider an example where your targets are to be placed in a separate directory, and that directory might not exist before make is run. In this situation, you want the directory to be created before any targets are placed into it but, because the timestamps on directories change whenever a file is added, removed, or renamed, we certainly don’t want to rebuild all the targets whenever the directory’s timestamp changes. One way to manage this is with order-only prerequisites: make the directory an order-only prerequisite on all the targets:
OBJDIR := objdir OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)
$(OBJDIR)/%.o : %.c $(COMPILE.c) $(OUTPUT_OPTION) $<
all: $(OBJS)

Chapter 4: Writing Rules

25

$(OBJS): | $(OBJDIR)
$(OBJDIR): mkdir $(OBJDIR)
Now the rule to create the objdir directory will be run, if needed, before any ‘.o’ is built, but no ‘.o’ will be built because the objdir directory timestamp changed.
4.3 Using Wildcard Characters in File Names
A single file name can specify many files using wildcard characters. The wildcard characters in make are ‘*’, ‘?’ and ‘[...]’, the same as in the Bourne shell. For example, *.c specifies a list of all the files (in the working directory) whose names end in ‘.c’.
The character ‘~’ at the beginning of a file name also has special significance. If alone, or followed by a slash, it represents your home directory. For example ~/bin expands to /home/you/bin. If the ‘~’ is followed by a word, the string represents the home directory of the user named by that word. For example ~john/bin expands to /home/john/bin. On systems which don’t have a home directory for each user (such as MS-DOS or MS-Windows), this functionality can be simulated by setting the environment variable HOME.
Wildcard expansion is performed by make automatically in targets and in prerequisites. In recipes, the shell is responsible for wildcard expansion. In other contexts, wildcard expansion happens only if you request it explicitly with the wildcard function.
The special significance of a wildcard character can be turned off by preceding it with a backslash. Thus, foo\*bar would refer to a specific file whose name consists of ‘foo’, an asterisk, and ‘bar’.
4.3.1 Wildcard Examples
Wildcards can be used in the recipe of a rule, where they are expanded by the shell. For example, here is a rule to delete all the object files:
clean: rm -f *.o
Wildcards are also useful in the prerequisites of a rule. With the following rule in the makefile, ‘make print’ will print all the ‘.c’ files that have changed since the last time you printed them:
print: *.c lpr -p $? touch print
This rule uses print as an empty target file; see Section 4.7 [Empty Target Files to Record Events], page 33. (The automatic variable ‘$?’ is used to print only those files that have changed; see Section 10.5.3 [Automatic Variables], page 124.)
Wildcard expansion does not happen when you define a variable. Thus, if you write this:
objects = *.o then the value of the variable objects is the actual string ‘*.o’. However, if you use the value of objects in a target or prerequisite, wildcard expansion will take place there. If

26

GNU make

you use the value of objects in a recipe, the shell may perform wildcard expansion when the recipe runs. To set objects to the expansion, instead use:
objects := $(wildcard *.o) See Section 4.3.3 [Wildcard Function], page 26.
4.3.2 Pitfalls of Using Wildcards
Now here is an example of a naive way of using wildcard expansion, that does not do what you would intend. Suppose you would like to say that the executable file foo is made from all the object files in the directory, and you write this:
objects = *.o
foo : $(objects) cc -o foo $(CFLAGS) $(objects)
The value of objects is the actual string ‘*.o’. Wildcard expansion happens in the rule for foo, so that each existing ‘.o’ file becomes a prerequisite of foo and will be recompiled if necessary.
But what if you delete all the ‘.o’ files? When a wildcard matches no files, it is left as it is, so then foo will depend on the oddly-named file *.o. Since no such file is likely to exist, make will give you an error saying it cannot figure out how to make *.o. This is not what you want!
Actually it is possible to obtain the desired result with wildcard expansion, but you need more sophisticated techniques, including the wildcard function and string substitution. These are described in the following section.
Microsoft operating systems (MS-DOS and MS-Windows) use backslashes to separate directories in pathnames, like so:
c:\foo\bar\baz.c This is equivalent to the Unix-style c:/foo/bar/baz.c (the c: part is the so-called drive letter). When make runs on these systems, it supports backslashes as well as the Unixstyle forward slashes in pathnames. However, this support does not include the wildcard expansion, where backslash is a quote character. Therefore, you must use Unix-style slashes in these cases.
4.3.3 The Function wildcard
Wildcard expansion happens automatically in rules. But wildcard expansion does not normally take place when a variable is set, or inside the arguments of a function. If you want to do wildcard expansion in such places, you need to use the wildcard function, like this:
$(wildcard pattern...) This string, used anywhere in a makefile, is replaced by a space-separated list of names of existing files that match one of the given file name patterns. If no existing file name matches a pattern, then that pattern is omitted from the output of the wildcard function. Note that this is different from how unmatched wildcards behave in rules, where they are used verbatim rather than ignored (see Section 4.3.2 [Wildcard Pitfall], page 26).
One use of the wildcard function is to get a list of all the C source files in a directory, like this:
$(wildcard *.c)

Chapter 4: Writing Rules

27

We can change the list of C source files into a list of object files by replacing the ‘.c’ suffix with ‘.o’ in the result, like this:
$(patsubst %.c,%.o,$(wildcard *.c)) (Here we have used another function, patsubst. See Section 8.2 [Functions for String Substitution and Analysis], page 88.)
Thus, a makefile to compile all C source files in the directory and then link them together could be written as follows:
objects := $(patsubst %.c,%.o,$(wildcard *.c))
foo : $(objects) cc -o foo $(objects)
(This takes advantage of the implicit rule for compiling C programs, so there is no need to write explicit rules for compiling the files. See Section 6.2 [The Two Flavors of Variables], page 62, for an explanation of ‘:=’, which is a variant of ‘=’.)
4.4 Searching Directories for Prerequisites
For large systems, it is often desirable to put sources in a separate directory from the binaries. The directory search features of make facilitate this by searching several directories automatically to find a prerequisite. When you redistribute the files among directories, you do not need to change the individual rules, just the search paths.
4.4.1 VPATH: Search Path for All Prerequisites
The value of the make variable VPATH specifies a list of directories that make should search. Most often, the directories are expected to contain prerequisite files that are not in the current directory; however, make uses VPATH as a search list for both prerequisites and targets of rules.
Thus, if a file that is listed as a target or prerequisite does not exist in the current directory, make searches the directories listed in VPATH for a file with that name. If a file is found in one of them, that file may become the prerequisite (see below). Rules may then specify the names of files in the prerequisite list as if they all existed in the current directory. See Section 4.4.4 [Writing Recipes with Directory Search], page 29.
In the VPATH variable, directory names are separated by colons or blanks. The order in which directories are listed is the order followed by make in its search. (On MS-DOS and MS-Windows, semi-colons are used as separators of directory names in VPATH, since the colon can be used in the pathname itself, after the drive letter.)
For example,
VPATH = src:../headers specifies a path containing two directories, src and ../headers, which make searches in that order.
With this value of VPATH, the following rule, foo.o : foo.c
is interpreted as if it were written like this:
foo.o : src/foo.c

28

GNU make

assuming the file foo.c does not exist in the current directory but is found in the directory src.

4.4.2 The vpath Directive
Similar to the VPATH variable, but more selective, is the vpath directive (note lower case), which allows you to specify a search path for a particular class of file names: those that match a particular pattern. Thus you can supply certain search directories for one class of file names and other directories (or none) for other file names.
There are three forms of the vpath directive:

vpath pattern directories Specify the search path directories for file names that match pattern.
The search path, directories, is a list of directories to be searched, separated by colons (semi-colons on MS-DOS and MS-Windows) or blanks, just like the search path used in the VPATH variable.
vpath pattern Clear out the search path associated with pattern.

vpath

Clear all search paths previously specified with vpath directives.

A vpath pattern is a string containing a ‘%’ character. The string must match the file name of a prerequisite that is being searched for, the ‘%’ character matching any sequence of zero or more characters (as in pattern rules; see Section 10.5 [Defining and Redefining Pattern Rules], page 123). For example, %.h matches files that end in .h. (If there is no ‘%’, the pattern must match the prerequisite exactly, which is not useful very often.)
‘%’ characters in a vpath directive’s pattern can be quoted with preceding backslashes (‘\’). Backslashes that would otherwise quote ‘%’ characters can be quoted with more backslashes. Backslashes that quote ‘%’ characters or other backslashes are removed from the pattern before it is compared to file names. Backslashes that are not in danger of quoting ‘%’ characters go unmolested.
When a prerequisite fails to exist in the current directory, if the pattern in a vpath directive matches the name of the prerequisite file, then the directories in that directive are searched just like (and before) the directories in the VPATH variable.
For example,

vpath %.h ../headers
tells make to look for any prerequisite whose name ends in .h in the directory ../headers if the file is not found in the current directory.

If several vpath patterns match the prerequisite file’s name, then make processes each matching vpath directive one by one, searching all the directories mentioned in each directive. make handles multiple vpath directives in the order in which they appear in the makefile; multiple directives with the same pattern are independent of each other.
Thus,

vpath %.c foo vpath % blish vpath %.c bar

Chapter 4: Writing Rules

29

will look for a file ending in ‘.c’ in foo, then blish, then bar, while
vpath %.c foo:bar vpath % blish will look for a file ending in ‘.c’ in foo, then bar, then blish.
4.4.3 How Directory Searches are Performed
When a prerequisite is found through directory search, regardless of type (general or selective), the pathname located may not be the one that make actually provides you in the prerequisite list. Sometimes the path discovered through directory search is thrown away.
The algorithm make uses to decide whether to keep or abandon a path found via directory search is as follows:
1. If a target file does not exist at the path specified in the makefile, directory search is performed.
2. If the directory search is successful, that path is kept and this file is tentatively stored as the target.
3. All prerequisites of this target are examined using this same method. 4. After processing the prerequisites, the target may or may not need to be rebuilt:
a. If the target does not need to be rebuilt, the path to the file found during directory search is used for any prerequisite lists which contain this target. In short, if make doesn’t need to rebuild the target then you use the path found via directory search.
b. If the target does need to be rebuilt (is out-of-date), the pathname found during directory search is thrown away, and the target is rebuilt using the file name specified in the makefile. In short, if make must rebuild, then the target is rebuilt locally, not in the directory found via directory search.
This algorithm may seem complex, but in practice it is quite often exactly what you want.
Other versions of make use a simpler algorithm: if the file does not exist, and it is found via directory search, then that pathname is always used whether or not the target needs to be built. Thus, if the target is rebuilt it is created at the pathname discovered during directory search.
If, in fact, this is the behavior you want for some or all of your directories, you can use the GPATH variable to indicate this to make.
GPATH has the same syntax and format as VPATH (that is, a space- or colon-delimited list of pathnames). If an out-of-date target is found by directory search in a directory that also appears in GPATH, then that pathname is not thrown away. The target is rebuilt using the expanded path.
4.4.4 Writing Recipes with Directory Search
When a prerequisite is found in another directory through directory search, this cannot change the recipe of the rule; they will execute as written. Therefore, you must write the recipe with care so that it will look for the prerequisite in the directory where make finds it.
This is done with the automatic variables such as ‘$^’ (see Section 10.5.3 [Automatic Variables], page 124). For instance, the value of ‘$^’ is a list of all the prerequisites of the

30

GNU make

rule, including the names of the directories in which they were found, and the value of ‘$@’ is the target. Thus:
foo.o : foo.c cc -c $(CFLAGS) $^ -o $@
(The variable CFLAGS exists so you can specify flags for C compilation by implicit rules; we use it here for consistency so it will affect all C compilations uniformly; see Section 10.3 [Variables Used by Implicit Rules], page 119.)
Often the prerequisites include header files as well, which you do not want to mention in the recipe. The automatic variable ‘$<’ is just the first prerequisite:
VPATH = src:../headers foo.o : foo.c defs.h hack.h
cc -c $(CFLAGS) $< -o $@
4.4.5 Directory Search and Implicit Rules
The search through the directories specified in VPATH or with vpath also happens during consideration of implicit rules (see Chapter 10 [Using Implicit Rules], page 115).
For example, when a file foo.o has no explicit rule, make considers implicit rules, such as the built-in rule to compile foo.c if that file exists. If such a file is lacking in the current directory, the appropriate directories are searched for it. If foo.c exists (or is mentioned in the makefile) in any of the directories, the implicit rule for C compilation is applied.
The recipes of implicit rules normally use automatic variables as a matter of necessity; consequently they will use the file names found by directory search with no extra effort.
4.4.6 Directory Search for Link Libraries
Directory search applies in a special way to libraries used with the linker. This special feature comes into play when you write a prerequisite whose name is of the form ‘-lname’. (You can tell something strange is going on here because the prerequisite is normally the name of a file, and the file name of a library generally looks like libname.a, not like ‘-lname’.)
When a prerequisite’s name has the form ‘-lname’, make handles it specially by searching for the file libname.so, and, if it is not found, for the file libname.a in the current directory, in directories specified by matching vpath search paths and the VPATH search path, and then in the directories /lib, /usr/lib, and prefix/lib (normally /usr/local/lib, but MSDOS/MS-Windows versions of make behave as if prefix is defined to be the root of the DJGPP installation tree).
For example, if there is a /usr/lib/libcurses.a library on your system (and no /usr/lib/libcurses.so file), then
foo : foo.c -lcurses cc $^ -o $@
would cause the command ‘cc foo.c /usr/lib/libcurses.a -o foo’ to be executed when foo is older than foo.c or than /usr/lib/libcurses.a.
Although the default set of files to be searched for is libname.so and libname.a, this is customizable via the .LIBPATTERNS variable. Each word in the value of this variable is a pattern string. When a prerequisite like ‘-lname’ is seen, make will replace the percent

Chapter 4: Writing Rules

31

in each pattern in the list with name and perform the above directory searches using each library file name.
The default value for .LIBPATTERNS is ‘lib%.so lib%.a’, which provides the default behavior described above.
You can turn off link library expansion completely by setting this variable to an empty value.
4.5 Phony Targets
A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.
If you write a rule whose recipe will not create the target file, the recipe will be executed every time the target comes up for remaking. Here is an example:
clean: rm *.o temp
Because the rm command does not create a file named clean, probably no such file will ever exist. Therefore, the rm command will be executed every time you say ‘make clean’.
In this example, the clean target will not work properly if a file named clean is ever created in this directory. Since it has no prerequisites, clean would always be considered up to date and its recipe would not be executed. To avoid this problem you can explicitly declare the target to be phony by making it a prerequisite of the special target .PHONY (see Section 4.8 [Special Built-in Target Names], page 34) as follows:
.PHONY: clean clean:
rm *.o temp
Once this is done, ‘make clean’ will run the recipe regardless of whether there is a file named clean.
Phony targets are also useful in conjunction with recursive invocations of make (see Section 5.7 [Recursive Use of make], page 53). In this situation the makefile will often contain a variable which lists a number of sub-directories to be built. A simplistic way to handle this is to define one rule with a recipe that loops over the sub-directories, like this:
SUBDIRS = foo bar baz
subdirs: for dir in $(SUBDIRS); do \ $(MAKE) -C $$dir; \ done
There are problems with this method, however. First, any error detected in a sub-make is ignored by this rule, so it will continue to build the rest of the directories even when one fails. This can be overcome by adding shell commands to note the error and exit, but then it will do so even if make is invoked with the -k option, which is unfortunate. Second, and perhaps more importantly, you cannot take advantage of make’s ability to build targets in parallel (see Section 5.4 [Parallel Execution], page 49), since there is only one rule.

32

GNU make

By declaring the sub-directories as .PHONY targets (you must do this as the sub-directory obviously always exists; otherwise it won’t be built) you can remove these problems:
SUBDIRS = foo bar baz
.PHONY: subdirs $(SUBDIRS)
subdirs: $(SUBDIRS)
$(SUBDIRS): $(MAKE) -C $@
foo: baz Here we’ve also declared that the foo sub-directory cannot be built until after the baz sub-directory is complete; this kind of relationship declaration is particularly important when attempting parallel builds. The implicit rule search (see Chapter 10 [Implicit Rules], page 115) is skipped for .PHONY targets. This is why declaring a target as .PHONY is good for performance, even if you are not worried about the actual file existing. A phony target should not be a prerequisite of a real target file; if it is, its recipe will be run every time make goes to update that file. As long as a phony target is never a prerequisite of a real target, the phony target recipe will be executed only when the phony target is a specified goal (see Section 9.2 [Arguments to Specify the Goals], page 103). Phony targets can have prerequisites. When one directory contains multiple programs, it is most convenient to describe all of the programs in one makefile ./Makefile. Since the target remade by default will be the first one in the makefile, it is common to make this a phony target named ‘all’ and give it, as prerequisites, all the individual programs. For example:
all : prog1 prog2 prog3 .PHONY : all
prog1 : prog1.o utils.o cc -o prog1 prog1.o utils.o
prog2 : prog2.o cc -o prog2 prog2.o
prog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o
Now you can say just ‘make’ to remake all three programs, or specify as arguments the ones to remake (as in ‘make prog1 prog3’). Phoniness is not inherited: the prerequisites of a phony target are not themselves phony, unless explicitly declared to be so.
When one phony target is a prerequisite of another, it serves as a subroutine of the other. For example, here ‘make cleanall’ will delete the object files, the difference files, and the file program:
.PHONY: cleanall cleanobj cleandiff

Chapter 4: Writing Rules

33

cleanall : cleanobj cleandiff rm program
cleanobj : rm *.o
cleandiff : rm *.diff
4.6 Rules without Recipes or Prerequisites
If a rule has no prerequisites or recipe, and the target of the rule is a nonexistent file, then make imagines this target to have been updated whenever its rule is run. This implies that all targets depending on this one will always have their recipe run.
An example will illustrate this:
clean: FORCE rm $(objects)
FORCE: Here the target ‘FORCE’ satisfies the special conditions, so the target clean that depends on it is forced to run its recipe. There is nothing special about the name ‘FORCE’, but that is one name commonly used this way. As you can see, using ‘FORCE’ this way has the same results as using ‘.PHONY: clean’. Using ‘.PHONY’ is more explicit and more efficient. However, other versions of make do not support ‘.PHONY’; thus ‘FORCE’ appears in many makefiles. See Section 4.5 [Phony Targets], page 31.
4.7 Empty Target Files to Record Events
The empty target is a variant of the phony target; it is used to hold recipes for an action that you request explicitly from time to time. Unlike a phony target, this target file can really exist; but the file’s contents do not matter, and usually are empty.
The purpose of the empty target file is to record, with its last-modification time, when the rule’s recipe was last executed. It does so because one of the commands in the recipe is a touch command to update the target file.
The empty target file should have some prerequisites (otherwise it doesn’t make sense). When you ask to remake the empty target, the recipe is executed if any prerequisite is more recent than the target; in other words, if a prerequisite has changed since the last time you remade the target. Here is an example:
print: foo.c bar.c lpr -p $? touch print
With this rule, ‘make print’ will execute the lpr command if either source file has changed since the last ‘make print’. The automatic variable ‘$?’ is used to print only those files that have changed (see Section 10.5.3 [Automatic Variables], page 124).

34

GNU make

4.8 Special Built-in Target Names

Certain names have special meanings if they appear as targets.

.PHONY

The prerequisites of the special target .PHONY are considered to be phony targets. When it is time to consider such a target, make will run its recipe unconditionally, regardless of whether a file with that name exists or what its last-modification time is. See Section 4.5 [Phony Targets], page 31.

.SUFFIXES The prerequisites of the special target .SUFFIXES are the list of suffixes to be used in checking for suffix rules. See Section 10.7 [Old-Fashioned Suffix Rules], page 129.

.DEFAULT

The recipe specified for .DEFAULT is used for any target for which no rules are found (either explicit rules or implicit rules). See Section 10.6 [Last Resort], page 129. If a .DEFAULT recipe is specified, every file mentioned as a prerequisite, but not as a target in a rule, will have that recipe executed on its behalf. See Section 10.8 [Implicit Rule Search Algorithm], page 131.

.PRECIOUS The targets which .PRECIOUS depends on are given the following special treatment: if make is killed or interrupted during the execution of their recipes, the target is not deleted. See Section 5.6 [Interrupting or Killing make], page 52. Also, if the target is an intermediate file, it will not be deleted after it is no longer needed, as is normally done. See Section 10.4 [Chains of Implicit Rules], page 121. In this latter respect it overlaps with the .SECONDARY special target.
You can also list the target pattern of an implicit rule (such as ‘%.o’) as a prerequisite file of the special target .PRECIOUS to preserve intermediate files created by rules whose target patterns match that file’s name.

.INTERMEDIATE The targets which .INTERMEDIATE depends on are treated as intermediate files. See Section 10.4 [Chains of Implicit Rules], page 121. .INTERMEDIATE with no prerequisites has no effect.

.SECONDARY The targets which .SECONDARY depends on are treated as intermediate files, except that they are never automatically deleted. See Section 10.4 [Chains of Implicit Rules], page 121.
.SECONDARY with no prerequisites causes all targets to be treated as secondary (i.e., no target is removed because it is considered intermediate).

.SECONDEXPANSION If .SECONDEXPANSION is mentioned as a target anywhere in the makefile, then all prerequisite lists defined after it appears will be expanded a second time after all makefiles have been read in. See Section 3.9 [Secondary Expansion], page 19.

Chapter 4: Writing Rules

35

.DELETE_ON_ERROR If .DELETE_ON_ERROR is mentioned as a target anywhere in the makefile, then make will delete the target of a rule if it has changed and its recipe exits with a nonzero exit status, just as it does when it receives a signal. See Section 5.5 [Errors in Recipes], page 51.

.IGNORE

If you specify prerequisites for .IGNORE, then make will ignore errors in execution of the recipe for those particular files. The recipe for .IGNORE (if any) is ignored.
If mentioned as a target with no prerequisites, .IGNORE says to ignore errors in execution of recipes for all files. This usage of ‘.IGNORE’ is supported only for historical compatibility. Since this affects every recipe in the makefile, it is not very useful; we recommend you use the more selective ways to ignore errors in specific recipes. See Section 5.5 [Errors in Recipes], page 51.

.LOW_RESOLUTION_TIME If you specify prerequisites for .LOW_RESOLUTION_TIME, make assumes that these files are created by commands that generate low resolution time stamps. The recipe for the .LOW_RESOLUTION_TIME target are ignored.
The high resolution file time stamps of many modern file systems lessen the chance of make incorrectly concluding that a file is up to date. Unfortunately, some hosts do not provide a way to set a high resolution file time stamp, so commands like ‘cp -p’ that explicitly set a file’s time stamp must discard its sub-second part. If a file is created by such a command, you should list it as a prerequisite of .LOW_RESOLUTION_TIME so that make does not mistakenly conclude that the file is out of date. For example:
.LOW_RESOLUTION_TIME: dst dst: src
cp -p src dst
Since ‘cp -p’ discards the sub-second part of src’s time stamp, dst is typically slightly older than src even when it is up to date. The .LOW_RESOLUTION_TIME line causes make to consider dst to be up to date if its time stamp is at the start of the same second that src’s time stamp is in.
Due to a limitation of the archive format, archive member time stamps are always low resolution. You need not list archive members as prerequisites of .LOW_RESOLUTION_TIME, as make does this automatically.

.SILENT

If you specify prerequisites for .SILENT, then make will not print the recipe used to remake those particular files before executing them. The recipe for .SILENT is ignored.
If mentioned as a target with no prerequisites, .SILENT says not to print any recipes before executing them. You may also use more selective ways to silence specific recipe command lines. See Section 5.2 [Recipe Echoing], page 45. If you want to silence all recipes for a particular run of make, use the ‘-s’ or ‘--silent’ option (see Section 9.7 [Options Summary], page 108).

36

GNU make

.EXPORT_ALL_VARIABLES Simply by being mentioned as a target, this tells make to export all variables to child processes by default. See Section 5.7.2 [Communicating Variables to a Sub-make], page 54.

.NOTPARALLEL If .NOTPARALLEL is mentioned as a target, then this invocation of make will be run serially, even if the ‘-j’ option is given. Any recursively invoked make command will still run recipes in parallel (unless its makefile also contains this target). Any prerequisites on this target are ignored.

.ONESHELL If .ONESHELL is mentioned as a target, then when a target is built all lines of the recipe will be given to a single invocation of the shell rather than each line being invoked separately (see Section 5.3 [Recipe Execution], page 46).

.POSIX

If .POSIX is mentioned as a target, then the makefile will be parsed and run in POSIX-conforming mode. This does not mean that only POSIX-conforming makefiles will be accepted: all advanced GNU make features are still available. Rather, this target causes make to behave as required by POSIX in those areas where make’s default behavior differs.
In particular, if this target is mentioned then recipes will be invoked as if the shell had been passed the -e flag: the first failing command in a recipe will cause the recipe to fail immediately.

Any defined implicit rule suffix also counts as a special target if it appears as a target, and so does the concatenation of two suffixes, such as ‘.c.o’. These targets are suffix rules, an obsolete way of defining implicit rules (but a way still widely used). In principle, any target name could be special in this way if you break it in two and add both pieces to the suffix list. In practice, suffixes normally begin with ‘.’, so these special target names also begin with ‘.’. See Section 10.7 [Old-Fashioned Suffix Rules], page 129.

4.9 Multiple Targets in a Rule
When an explicit rule has multiple targets they can be treated in one of two possible ways: as independent targets or as grouped targets. The manner in which they are treated is determined by the separator that appears after the list of targets.
Rules with Independent Targets
Rules that use the standard target separator, :, define independent targets. This is equivalent to writing the same rule once for each target, with duplicated prerequisites and recipes. Typically, the recipe would use automatic variables such as ‘$@’ to specify which target is being built.
Rules with independent targets are useful in two cases: • You want just prerequisites, no recipe. For example:
kbd.o command.o files.o: command.h

Chapter 4: Writing Rules

37

gives an additional prerequisite to each of the three object files mentioned. It is equivalent to writing:
kbd.o: command.h command.o: command.h files.o: command.h • Similar recipes work for all the targets. The automatic variable ‘$@’ can be used to substitute the particular target to be remade into the commands (see Section 10.5.3 [Automatic Variables], page 124). For example:
bigoutput littleoutput : text.g generate text.g -$(subst output,,$@) > $@
is equivalent to
bigoutput : text.g generate text.g -big > bigoutput
littleoutput : text.g generate text.g -little > littleoutput
Here we assume the hypothetical program generate makes two types of output, one if given ‘-big’ and one if given ‘-little’. See Section 8.2 [Functions for String Substitution and Analysis], page 88, for an explanation of the subst function.
Suppose you would like to vary the prerequisites according to the target, much as the variable ‘$@’ allows you to vary the recipe. You cannot do this with multiple targets in an ordinary rule, but you can do it with a static pattern rule. See Section 4.11 [Static Pattern Rules], page 38.
Rules with Grouped Targets
If instead of independent targets you have a recipe that generates multiple files from a single invocation, you can express that relationship by declaring your rule to use grouped targets. A grouped target rule uses the separator &: (the ‘&’ here is used to imply “all”).
When make builds any one of the grouped targets, it understands that all the other targets in the group are also created as a result of the invocation of the recipe. Furthermore, if only some of the grouped targets are out of date or missing make will realize that running the recipe will update all of the targets.
As an example, this rule defines a grouped target:
foo bar biz &: baz boz echo $^ > foo echo $^ > bar echo $^ > biz
During the execution of a grouped target’s recipe, the automatic variable ‘$@’ is set to the name of the particular target in the group which triggered the rule. Caution must be used if relying on this variable in the recipe of a grouped target rule.
Unlike independent targets, a grouped target rule must include a recipe. However, targets that are members of a grouped target may also appear in independent target rule definitions that do not have recipes.
Each target may have only one recipe associated with it. If a grouped target appears in either an independent target rule or in another grouped target rule with a recipe, you will

38

GNU make

get a warning and the latter recipe will replace the former recipe. Additionally the target will be removed from the previous group and appear only in the new group.
If you would like a target to appear in multiple groups, then you must use the doublecolon grouped target separator, &:: when declaring all of the groups containing that target. Grouped double-colon targets are each considered independently, and each grouped doublecolon rule’s recipe is executed at most once, if at least one of its multiple targets requires updating.
4.10 Multiple Rules for One Target
One file can be the target of several rules. All the prerequisites mentioned in all the rules are merged into one list of prerequisites for the target. If the target is older than any prerequisite from any rule, the recipe is executed.
There can only be one recipe to be executed for a file. If more than one rule gives a recipe for the same file, make uses the last one given and prints an error message. (As a special case, if the file’s name begins with a dot, no error message is printed. This odd behavior is only for compatibility with other implementations of make. . . you should avoid using it). Occasionally it is useful to have the same target invoke multiple recipes which are defined in different parts of your makefile; you can use double-colon rules (see Section 4.12 [Double-Colon], page 40) for this.
An extra rule with just prerequisites can be used to give a few extra prerequisites to many files at once. For example, makefiles often have a variable, such as objects, containing a list of all the compiler output files in the system being made. An easy way to say that all of them must be recompiled if config.h changes is to write the following:
objects = foo.o bar.o foo.o : defs.h bar.o : defs.h test.h $(objects) : config.h
This could be inserted or taken out without changing the rules that really specify how to make the object files, making it a convenient form to use if you wish to add the additional prerequisite intermittently.
Another wrinkle is that the additional prerequisites could be specified with a variable that you set with a command line argument to make (see Section 9.5 [Overriding Variables], page 107). For example,
extradeps= $(objects) : $(extradeps)
means that the command ‘make extradeps=foo.h’ will consider foo.h as a prerequisite of each object file, but plain ‘make’ will not.
If none of the explicit rules for a target has a recipe, then make searches for an applicable implicit rule to find one see Chapter 10 [Using Implicit Rules], page 115).
4.11 Static Pattern Rules
Static pattern rules are rules which specify multiple targets and construct the prerequisite names for each target based on the target name. They are more general than ordinary rules

Chapter 4: Writing Rules

39

with multiple targets because the targets do not have to have identical prerequisites. Their prerequisites must be analogous, but not necessarily identical.
4.11.1 Syntax of Static Pattern Rules
Here is the syntax of a static pattern rule:
targets ...: target-pattern: prereq-patterns ... recipe ...
The targets list specifies the targets that the rule applies to. The targets can contain wildcard characters, just like the targets of ordinary rules (see Section 4.3 [Using Wildcard Characters in File Names], page 25).
The target-pattern and prereq-patterns say how to compute the prerequisites of each target. Each target is matched against the target-pattern to extract a part of the target name, called the stem. This stem is substituted into each of the prereq-patterns to make the prerequisite names (one from each prereq-pattern).
Each pattern normally contains the character ‘%’ just once. When the target-pattern matches a target, the ‘%’ can match any part of the target name; this part is called the stem. The rest of the pattern must match exactly. For example, the target foo.o matches the pattern ‘%.o’, with ‘foo’ as the stem. The targets foo.c and foo.out do not match that pattern.
The prerequisite names for each target are made by substituting the stem for the ‘%’ in each prerequisite pattern. For example, if one prerequisite pattern is %.c, then substitution of the stem ‘foo’ gives the prerequisite name foo.c. It is legitimate to write a prerequisite pattern that does not contain ‘%’; then this prerequisite is the same for all targets.
‘%’ characters in pattern rules can be quoted with preceding backslashes (‘\’). Backslashes that would otherwise quote ‘%’ characters can be quoted with more backslashes. Backslashes that quote ‘%’ characters or other backslashes are removed from the pattern before it is compared to file names or has a stem substituted into it. Backslashes that are not in danger of quoting ‘%’ characters go unmolested. For example, the pattern the\%weird\\%pattern\\ has ‘the%weird\’ preceding the operative ‘%’ character, and ‘pattern\\’ following it. The final two backslashes are left alone because they cannot affect any ‘%’ character.
Here is an example, which compiles each of foo.o and bar.o from the corresponding .c file:
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c $(CC) -c $(CFLAGS) $< -o $@
Here ‘$<’ is the automatic variable that holds the name of the prerequisite and ‘$@’ is the automatic variable that holds the name of the target; see Section 10.5.3 [Automatic Variables], page 124.
Each target specified must match the target pattern; a warning is issued for each target that does not. If you have a list of files, only some of which will match the pattern, you can

40

GNU make

use the filter function to remove non-matching file names (see Section 8.2 [Functions for String Substitution and Analysis], page 88):
files = foo.elc bar.o lose.o
$(filter %.o,$(files)): %.o: %.c $(CC) -c $(CFLAGS) $< -o $@
$(filter %.elc,$(files)): %.elc: %.el emacs -f batch-byte-compile $<
In this example the result of ‘$(filter %.o,$(files))’ is bar.o lose.o, and the first static pattern rule causes each of these object files to be updated by compiling the corresponding C source file. The result of ‘$(filter %.elc,$(files))’ is foo.elc, so that file is made from foo.el.
Another example shows how to use $* in static pattern rules:
bigoutput littleoutput : %output : text.g generate text.g -$* > $@
When the generate command is run, $* will expand to the stem, either ‘big’ or ‘little’.
4.11.2 Static Pattern Rules versus Implicit Rules
A static pattern rule has much in common with an implicit rule defined as a pattern rule (see Section 10.5 [Defining and Redefining Pattern Rules], page 123). Both have a pattern for the target and patterns for constructing the names of prerequisites. The difference is in how make decides when the rule applies.
An implicit rule can apply to any target that matches its pattern, but it does apply only when the target has no recipe otherwise specified, and only when the prerequisites can be found. If more than one implicit rule appears applicable, only one applies; the choice depends on the order of rules.
By contrast, a static pattern rule applies to the precise list of targets that you specify in the rule. It cannot apply to any other target and it invariably does apply to each of the targets specified. If two conflicting rules apply, and both have recipes, that’s an error.
The static pattern rule can be better than an implicit rule for these reasons:
• You may wish to override the usual implicit rule for a few files whose names cannot be categorized syntactically but can be given in an explicit list.
• If you cannot be sure of the precise contents of the directories you are using, you may not be sure which other irrelevant files might lead make to use the wrong implicit rule. The choice might depend on the order in which the implicit rule search is done. With static pattern rules, there is no uncertainty: each rule applies to precisely the targets specified.
4.12 Double-Colon Rules
Double-colon rules are explicit rules written with ‘::’ instead of ‘:’ after the target names. They are handled differently from ordinary rules when the same target appears in more than one rule. Pattern rules with double-colons have an entirely different meaning (see Section 10.5.5 [Match-Anything Rules], page 127).

Chapter 4: Writing Rules

41

When a target appears in multiple rules, all the rules must be the same type: all ordinary, or all double-colon. If they are double-colon, each of them is independent of the others. Each double-colon rule’s recipe is executed if the target is older than any prerequisites of that rule. If there are no prerequisites for that rule, its recipe is always executed (even if the target already exists). This can result in executing none, any, or all of the double-colon rules.
Double-colon rules with the same target are in fact completely separate from one another. Each double-colon rule is processed individually, just as rules with different targets are processed.
The double-colon rules for a target are executed in the order they appear in the makefile. However, the cases where double-colon rules really make sense are those where the order of executing the recipes would not matter.
Double-colon rules are somewhat obscure and not often very useful; they provide a mechanism for cases in which the method used to update a target differs depending on which prerequisite files caused the update, and such cases are rare.
Each double-colon rule should specify a recipe; if it does not, an implicit rule will be used if one applies. See Chapter 10 [Using Implicit Rules], page 115.
4.13 Generating Prerequisites Automatically
In the makefile for a program, many of the rules you need to write often say only that some object file depends on some header file. For example, if main.c uses defs.h via an #include, you would write:
main.o: defs.h You need this rule so that make knows that it must remake main.o whenever defs.h changes. You can see that for a large program you would have to write dozens of such rules in your makefile. And, you must always be very careful to update the makefile every time you add or remove an #include.
To avoid this hassle, most modern C compilers can write these rules for you, by looking at the #include lines in the source files. Usually this is done with the ‘-M’ option to the compiler. For example, the command:
cc -M main.c generates the output:
main.o : main.c defs.h Thus you no longer have to write all those rules yourself. The compiler will do it for you.
Note that such a rule constitutes mentioning main.o in a makefile, so it can never be considered an intermediate file by implicit rule search. This means that make won’t ever remove the file after using it; see Section 10.4 [Chains of Implicit Rules], page 121.
With old make programs, it was traditional practice to use this compiler feature to generate prerequisites on demand with a command like ‘make depend’. That command would create a file depend containing all the automatically-generated prerequisites; then the makefile could use include to read them in (see Section 3.3 [Include], page 13).
In GNU make, the feature of remaking makefiles makes this practice obsolete—you need never tell make explicitly to regenerate the prerequisites, because it always regenerates any makefile that is out of date. See Section 3.5 [Remaking Makefiles], page 15.

42

GNU make

The practice we recommend for automatic prerequisite generation is to have one makefile corresponding to each source file. For each source file name.c there is a makefile name.d which lists what files the object file name.o depends on. That way only the source files that have changed need to be rescanned to produce the new prerequisites.
Here is the pattern rule to generate a file of prerequisites (i.e., a makefile) called name.d from a C source file called name.c:
%.d: %.c @set -e; rm -f $@; \ $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \ sed ’s,\($*\)\.o[ :]*,\1.o $@ : ,g’ < $@.$$$$ > $@; \ rm -f $@.$$$$
See Section 10.5 [Pattern Rules], page 123, for information on defining pattern rules. The ‘-e’ flag to the shell causes it to exit immediately if the $(CC) command (or any other command) fails (exits with a nonzero status).
With the GNU C compiler, you may wish to use the ‘-MM’ flag instead of ‘-M’. This omits prerequisites on system header files. See Section “Options Controlling the Preprocessor” in Using GNU CC, for details.
The purpose of the sed command is to translate (for example):
main.o : main.c defs.h
into:
main.o main.d : main.c defs.h
This makes each ‘.d’ file depend on all the source and header files that the corresponding ‘.o’ file depends on. make then knows it must regenerate the prerequisites whenever any of the source or header files changes.
Once you’ve defined the rule to remake the ‘.d’ files, you then use the include directive to read them all in. See Section 3.3 [Include], page 13. For example:
sources = foo.c bar.c
include $(sources:.c=.d)
(This example uses a substitution variable reference to translate the list of source files ‘foo.c bar.c’ into a list of prerequisite makefiles, ‘foo.d bar.d’. See Section 6.3.1 [Substitution Refs], page 64, for full information on substitution references.) Since the ‘.d’ files are makefiles like any others, make will remake them as necessary with no further work from you. See Section 3.5 [Remaking Makefiles], page 15.
Note that the ‘.d’ files contain target definitions; you should be sure to place the include directive after the first, default goal in your makefiles or run the risk of having a random object file become the default goal. See Section 2.3 [How Make Works], page 5.

43
5 Writing Recipes in Rules
The recipe of a rule consists of one or more shell command lines to be executed, one at a time, in the order they appear. Typically, the result of executing these commands is that the target of the rule is brought up to date.
Users use many different shell programs, but recipes in makefiles are always interpreted by /bin/sh unless the makefile specifies otherwise. See Section 5.3 [Recipe Execution], page 46.
5.1 Recipe Syntax
Makefiles have the unusual property that there are really two distinct syntaxes in one file. Most of the makefile uses make syntax (see Chapter 3 [Writing Makefiles], page 11). However, recipes are meant to be interpreted by the shell and so they are written using shell syntax. The make program does not try to understand shell syntax: it performs only a very few specific translations on the content of the recipe before handing it to the shell.
Each line in the recipe must start with a tab (or the first character in the value of the .RECIPEPREFIX variable; see Section 6.14 [Special Variables], page 75), except that the first recipe line may be attached to the target-and-prerequisites line with a semicolon in between. Any line in the makefile that begins with a tab and appears in a “rule context” (that is, after a rule has been started until another rule or variable definition) will be considered part of a recipe for that rule. Blank lines and lines of just comments may appear among the recipe lines; they are ignored.
Some consequences of these rules include: • A blank line that begins with a tab is not blank: it’s an empty recipe (see Section 5.9
[Empty Recipes], page 59). • A comment in a recipe is not a make comment; it will be passed to the shell as-is.
Whether the shell treats it as a comment or not depends on your shell. • A variable definition in a “rule context” which is indented by a tab as the first character
on the line, will be considered part of a recipe, not a make variable definition, and passed to the shell. • A conditional expression (ifdef, ifeq, etc. see Section 7.2 [Syntax of Conditionals], page 82) in a “rule context” which is indented by a tab as the first character on the line, will be considered part of a recipe and be passed to the shell.
5.1.1 Splitting Recipe Lines
One of the few ways in which make does interpret recipes is checking for a backslash just before the newline. As in normal makefile syntax, a single logical recipe line can be split into multiple physical lines in the makefile by placing a backslash before each newline. A sequence of lines like this is considered a single recipe line, and one instance of the shell will be invoked to run it.
However, in contrast to how they are treated in other places in a makefile (see Section 3.1.1 [Splitting Long Lines], page 12), backslash/newline pairs are not removed from the recipe. Both the backslash and the newline characters are preserved and passed to the shell. How the backslash/newline is interpreted depends on your shell. If the first

44

GNU make

character of the next line after the backslash/newline is the recipe prefix character (a tab by default; see Section 6.14 [Special Variables], page 75), then that character (and only that character) is removed. Whitespace is never added to the recipe.

For example, the recipe for the all target in this makefile:

all : space

@echo no\
@echo no\ space @echo one \ space @echo one\
space

consists of four separate shell commands where the output is:

nospace nospace one space one space

As a more complex example, this makefile:

all : ; @echo ’hello \ world’ ; echo "hello \
world" will invoke one shell with a command of:

echo ’hello \ world’ ; echo "hello \
world"

which, according to shell quoting rules, will yield the following output:

hello \ world hello

world

Notice how the backslash/newline pair was removed inside the string quoted with double quotes ("..."), but not from the string quoted with single quotes (’...’). This is the way the default shell (/bin/sh) handles backslash/newline pairs. If you specify a different shell in your makefiles it may treat them differently.

Sometimes you want to split a long line inside of single quotes, but you don’t want the backslash/newline to appear in the quoted content. This is often the case when passing scripts to languages such as Perl, where extraneous backslashes inside the script can change its meaning or even be a syntax error. One simple way of handling this is to place the quoted string, or even the entire command, into a make variable then use the variable in the recipe. In this situation the newline quoting rules for makefiles will be used, and the backslash/newline will be removed. If we rewrite our example above using this method:

HELLO = ’hello \ world’

all : ; @echo $(HELLO)

Chapter 5: Writing Recipes in Rules

45

we will get output like this:
hello world
If you like, you can also use target-specific variables (see Section 6.11 [Target-specific Variable Values], page 73) to obtain a tighter correspondence between the variable and the recipe that uses it.
5.1.2 Using Variables in Recipes
The other way in which make processes recipes is by expanding any variable references in them (see Section 6.1 [Reference], page 61). This occurs after make has finished reading all the makefiles and the target is determined to be out of date; so, the recipes for targets which are not rebuilt are never expanded.
Variable and function references in recipes have identical syntax and semantics to references elsewhere in the makefile. They also have the same quoting rules: if you want a dollar sign to appear in your recipe, you must double it (‘$$’). For shells like the default shell, that use dollar signs to introduce variables, it’s important to keep clear in your mind whether the variable you want to reference is a make variable (use a single dollar sign) or a shell variable (use two dollar signs). For example:
LIST = one two three all:
for i in $(LIST); do \ echo $$i; \
done
results in the following command being passed to the shell:
for i in one two three; do \ echo $i; \
done
which generates the expected result:
one two three
5.2 Recipe Echoing
Normally make prints each line of the recipe before it is executed. We call this echoing because it gives the appearance that you are typing the lines yourself.
When a line starts with ‘@’, the echoing of that line is suppressed. The ‘@’ is discarded before the line is passed to the shell. Typically you would use this for a command whose only effect is to print something, such as an echo command to indicate progress through the makefile:
@echo About to make distribution files
When make is given the flag ‘-n’ or ‘--just-print’ it only echoes most recipes, without executing them. See Section 9.7 [Summary of Options], page 108. In this case even the recipe lines starting with ‘@’ are printed. This flag is useful for finding out which recipes make thinks are necessary without actually doing them.

46

GNU make

The ‘-s’ or ‘--silent’ flag to make prevents all echoing, as if all recipes started with ‘@’. A rule in the makefile for the special target .SILENT without prerequisites has the same effect (see Section 4.8 [Special Built-in Target Names], page 34).
5.3 Recipe Execution
When it is time to execute recipes to update a target, they are executed by invoking a new sub-shell for each line of the recipe, unless the .ONESHELL special target is in effect (see Section 5.3.1 [Using One Shell], page 46) (In practice, make may take shortcuts that do not affect the results.)
Please note: this implies that setting shell variables and invoking shell commands such as cd that set a context local to each process will not affect the following lines in the recipe.1 If you want to use cd to affect the next statement, put both statements in a single recipe line. Then make will invoke one shell to run the entire line, and the shell will execute the statements in sequence. For example:
foo : bar/lose cd $(<D) && gobble $(<F) > ../$@
Here we use the shell AND operator (&&) so that if the cd command fails, the script will fail without trying to invoke the gobble command in the wrong directory, which could cause problems (in this case it would certainly cause ../foo to be truncated, at least).
5.3.1 Using One Shell
Sometimes you would prefer that all the lines in the recipe be passed to a single invocation of the shell. There are generally two situations where this is useful: first, it can improve performance in makefiles where recipes consist of many command lines, by avoiding extra processes. Second, you might want newlines to be included in your recipe command (for example perhaps you are using a very different interpreter as your SHELL). If the .ONESHELL special target appears anywhere in the makefile then all recipe lines for each target will be provided to a single invocation of the shell. Newlines between recipe lines will be preserved. For example:
.ONESHELL: foo : bar/lose
cd $(@D) gobble $(@F) > ../$@ would now work as expected even though the commands are on different recipe lines.
If .ONESHELL is provided, then only the first line of the recipe will be checked for the special prefix characters (‘@’, ‘-’, and ‘+’). Subsequent lines will include the special characters in the recipe line when the SHELL is invoked. If you want your recipe to start with one of these special characters you’ll need to arrange for them to not be the first characters on the first line, perhaps by adding a comment or similar. For example, this would be a syntax error in Perl because the first ‘@’ is removed by make:
.ONESHELL: SHELL = /usr/bin/perl
1 On MS-DOS, the value of current working directory is global, so changing it will affect the following recipe lines on those systems.

Chapter 5: Writing Recipes in Rules

47

.SHELLFLAGS = -e show :
@f = qw(a b c); print "@f\n";
However, either of these alternatives would work properly:
.ONESHELL: SHELL = /usr/bin/perl .SHELLFLAGS = -e show :
# Make sure "@" is not the first character on the first line @f = qw(a b c); print "@f\n";
or
.ONESHELL: SHELL = /usr/bin/perl .SHELLFLAGS = -e show :
my @f = qw(a b c); print "@f\n";
As a special feature, if SHELL is determined to be a POSIX-style shell, the special prefix characters in “internal” recipe lines will be removed before the recipe is processed. This feature is intended to allow existing makefiles to add the .ONESHELL special target and still run properly without extensive modifications. Since the special prefix characters are not legal at the beginning of a line in a POSIX shell script this is not a loss in functionality. For example, this works as expected:
.ONESHELL: foo : bar/lose
@cd $(@D) @gobble $(@F) > ../$@
Even with this special feature, however, makefiles with .ONESHELL will behave differently in ways that could be noticeable. For example, normally if any line in the recipe fails, that causes the rule to fail and no more recipe lines are processed. Under .ONESHELL a failure of any but the final recipe line will not be noticed by make. You can modify .SHELLFLAGS to add the -e option to the shell which will cause any failure anywhere in the command line to cause the shell to fail, but this could itself cause your recipe to behave differently. Ultimately you may need to harden your recipe lines to allow them to work with .ONESHELL.
5.3.2 Choosing the Shell
The program used as the shell is taken from the variable SHELL. If this variable is not set in your makefile, the program /bin/sh is used as the shell. The argument(s) passed to the shell are taken from the variable .SHELLFLAGS. The default value of .SHELLFLAGS is -c normally, or -ec in POSIX-conforming mode.
Unlike most variables, the variable SHELL is never set from the environment. This is because the SHELL environment variable is used to specify your personal choice of shell

48

GNU make

program for interactive use. It would be very bad for personal choices like this to affect the functioning of makefiles. See Section 6.10 [Variables from the Environment], page 72.
Furthermore, when you do set SHELL in your makefile that value is not exported in the environment to recipe lines that make invokes. Instead, the value inherited from the user’s environment, if any, is exported. You can override this behavior by explicitly exporting SHELL (see Section 5.7.2 [Communicating Variables to a Sub-make], page 54), forcing it to be passed in the environment to recipe lines.
However, on MS-DOS and MS-Windows the value of SHELL in the environment is used, since on those systems most users do not set this variable, and therefore it is most likely set specifically to be used by make. On MS-DOS, if the setting of SHELL is not suitable for make, you can set the variable MAKESHELL to the shell that make should use; if set it will be used as the shell instead of the value of SHELL.
Choosing a Shell in DOS and Windows
Choosing a shell in MS-DOS and MS-Windows is much more complex than on other systems.
On MS-DOS, if SHELL is not set, the value of the variable COMSPEC (which is always set) is used instead.
The processing of lines that set the variable SHELL in Makefiles is different on MS-DOS. The stock shell, command.com, is ridiculously limited in its functionality and many users of make tend to install a replacement shell. Therefore, on MS-DOS, make examines the value of SHELL, and changes its behavior based on whether it points to a Unix-style or DOS-style shell. This allows reasonable functionality even if SHELL points to command.com.
If SHELL points to a Unix-style shell, make on MS-DOS additionally checks whether that shell can indeed be found; if not, it ignores the line that sets SHELL. In MS-DOS, GNU make searches for the shell in the following places:
1. In the precise place pointed to by the value of SHELL. For example, if the makefile specifies ‘SHELL = /bin/sh’, make will look in the directory /bin on the current drive.
2. In the current directory.
3. In each of the directories in the PATH variable, in order.
In every directory it examines, make will first look for the specific file (sh in the example above). If this is not found, it will also look in that directory for that file with one of the known extensions which identify executable files. For example .exe, .com, .bat, .btm, .sh, and some others.
If any of these attempts is successful, the value of SHELL will be set to the full pathname of the shell as found. However, if none of these is found, the value of SHELL will not be changed, and thus the line that sets it will be effectively ignored. This is so make will only support features specific to a Unix-style shell if such a shell is actually installed on the system where make runs.
Note that this extended search for the shell is limited to the cases where SHELL is set from the Makefile; if it is set in the environment or command line, you are expected to set it to the full pathname of the shell, exactly as things are on Unix.
The effect of the above DOS-specific processing is that a Makefile that contains ‘SHELL = /bin/sh’ (as many Unix makefiles do), will work on MS-DOS unaltered if you have e.g. sh.exe installed in some directory along your PATH.

Chapter 5: Writing Recipes in Rules

49

5.4 Parallel Execution
GNU make knows how to execute several recipes at once. Normally, make will execute only one recipe at a time, waiting for it to finish before executing the next. However, the ‘-j’ or ‘--jobs’ option tells make to execute many recipes simultaneously. You can inhibit parallelism in a particular makefile with the .NOTPARALLEL pseudo-target (see Section 4.8 [Special Targets], page 34).
On MS-DOS, the ‘-j’ option has no effect, since that system doesn’t support multiprocessing.
If the ‘-j’ option is followed by an integer, this is the number of recipes to execute at once; this is called the number of job slots. If there is nothing looking like an integer after the ‘-j’ option, there is no limit on the number of job slots. The default number of job slots is one, which means serial execution (one thing at a time).
Handling recursive make invocations raises issues for parallel execution. For more information on this, see Section 5.7.3 [Communicating Options to a Sub-make], page 56.
If a recipe fails (is killed by a signal or exits with a nonzero status), and errors are not ignored for that recipe (see Section 5.5 [Errors in Recipes], page 51), the remaining recipe lines to remake the same target will not be run. If a recipe fails and the ‘-k’ or ‘--keep-going’ option was not given (see Section 9.7 [Summary of Options], page 108), make aborts execution. If make terminates for any reason (including a signal) with child processes running, it waits for them to finish before actually exiting.
When the system is heavily loaded, you will probably want to run fewer jobs than when it is lightly loaded. You can use the ‘-l’ option to tell make to limit the number of jobs to run at once, based on the load average. The ‘-l’ or ‘--max-load’ option is followed by a floating-point number. For example,
-l 2.5
will not let make start more than one job if the load average is above 2.5. The ‘-l’ option with no following number removes the load limit, if one was given with a previous ‘-l’ option.
More precisely, when make goes to start up a job, and it already has at least one job running, it checks the current load average; if it is not lower than the limit given with ‘-l’, make waits until the load average goes below that limit, or until all the other jobs finish.
By default, there is no load limit.
5.4.1 Output During Parallel Execution
When running several recipes in parallel the output from each recipe appears as soon as it is generated, with the result that messages from different recipes may be interspersed, sometimes even appearing on the same line. This can make reading the output very difficult.
To avoid this you can use the ‘--output-sync’ (‘-O’) option. This option instructs make to save the output from the commands it invokes and print it all once the commands are completed. Additionally, if there are multiple recursive make invocations running in parallel, they will communicate so that only one of them is generating output at a time.
If working directory printing is enabled (see Section 5.7.4 [The ‘--print-directory’ Option], page 57), the enter/leave messages are printed around each output grouping. If you prefer not to see these messages add the ‘--no-print-directory’ option to MAKEFLAGS.

50

GNU make

There are four levels of granularity when synchronizing output, specified by giving an argument to the option (e.g., ‘-Oline’ or ‘--output-sync=recurse’).

none

This is the default: all output is sent directly as it is generated and no synchronization is performed.

line

Output from each individual line of the recipe is grouped and printed as soon as that line is complete. If a recipe consists of multiple lines, they may be interspersed with lines from other recipes.

target

Output from the entire recipe for each target is grouped and printed once the target is complete. This is the default if the --output-sync or -O option is given with no argument.

recurse Output from each recursive invocation of make is grouped and printed once the recursive invocation is complete.

Regardless of the mode chosen, the total build time will be the same. The only difference is in how the output appears.
The ‘target’ and ‘recurse’ modes both collect the output of the entire recipe of a target and display it uninterrupted when the recipe completes. The difference between them is in how recipes that contain recursive invocations of make are treated (see Section 5.7 [Recursive Use of make], page 53). For all recipes which have no recursive lines, the ‘target’ and ‘recurse’ modes behave identically.
If the ‘recurse’ mode is chosen, recipes that contain recursive make invocations are treated the same as other targets: the output from the recipe, including the output from the recursive make, is saved and printed after the entire recipe is complete. This ensures output from all the targets built by a given recursive make instance are grouped together, which may make the output easier to understand. However it also leads to long periods of time during the build where no output is seen, followed by large bursts of output. If you are not watching the build as it proceeds, but instead viewing a log of the build after the fact, this may be the best option for you.
If you are watching the output, the long gaps of quiet during the build can be frustrating. The ‘target’ output synchronization mode detects when make is going to be invoked recursively, using the standard methods, and it will not synchronize the output of those lines. The recursive make will perform the synchronization for its targets and the output from each will be displayed immediately when it completes. Be aware that output from recursive lines of the recipe are not synchronized (for example if the recursive line prints a message before running make, that message will not be synchronized).
The ‘line’ mode can be useful for front-ends that are watching the output of make to track when recipes are started and completed.
Some programs invoked by make may behave differently if they determine they’re writing output to a terminal versus a file (often described as “interactive” vs. “non-interactive” modes). For example, many programs that can display colorized output will not do so if they determine they are not writing to a terminal. If your makefile invokes a program like this then using the output synchronization options will cause the program to believe it’s running in “non-interactive” mode even though the output will ultimately go to the terminal.

Chapter 5: Writing Recipes in Rules

51

5.4.2 Input During Parallel Execution
Two processes cannot both take input from the same device at the same time. To make sure that only one recipe tries to take input from the terminal at once, make will invalidate the standard input streams of all but one running recipe. If another recipe attempts to read from standard input it will usually incur a fatal error (a ‘Broken pipe’ signal).
It is unpredictable which recipe will have a valid standard input stream (which will come from the terminal, or wherever you redirect the standard input of make). The first recipe run will always get it first, and the first recipe started after that one finishes will get it next, and so on.
We will change how this aspect of make works if we find a better alternative. In the mean time, you should not rely on any recipe using standard input at all if you are using the parallel execution feature; but if you are not using this feature, then standard input works normally in all recipes.
5.5 Errors in Recipes
After each shell invocation returns, make looks at its exit status. If the shell completed successfully (the exit status is zero), the next line in the recipe is executed in a new shell; after the last line is finished, the rule is finished.
If there is an error (the exit status is nonzero), make gives up on the current rule, and perhaps on all rules.
Sometimes the failure of a certain recipe line does not indicate a problem. For example, you may use the mkdir command to ensure that a directory exists. If the directory already exists, mkdir will report an error, but you probably want make to continue regardless.
To ignore errors in a recipe line, write a ‘-’ at the beginning of the line’s text (after the initial tab). The ‘-’ is discarded before the line is passed to the shell for execution.
For example,
clean: -rm -f *.o
This causes make to continue even if rm is unable to remove a file.
When you run make with the ‘-i’ or ‘--ignore-errors’ flag, errors are ignored in all recipes of all rules. A rule in the makefile for the special target .IGNORE has the same effect, if there are no prerequisites. This is less flexible but sometimes useful.
When errors are to be ignored, because of either a ‘-’ or the ‘-i’ flag, make treats an error return just like success, except that it prints out a message that tells you the status code the shell exited with, and says that the error has been ignored.
When an error happens that make has not been told to ignore, it implies that the current target cannot be correctly remade, and neither can any other that depends on it either directly or indirectly. No further recipes will be executed for these targets, since their preconditions have not been achieved.
Normally make gives up immediately in this circumstance, returning a nonzero status. However, if the ‘-k’ or ‘--keep-going’ flag is specified, make continues to consider the other prerequisites of the pending targets, remaking them if necessary, before it gives up and returns nonzero status. For example, after an error in compiling one object file, ‘make

52

GNU make

-k’ will continue compiling other object files even though it already knows that linking them will be impossible. See Section 9.7 [Summary of Options], page 108.
The usual behavior assumes that your purpose is to get the specified targets up to date; once make learns that this is impossible, it might as well report the failure immediately. The ‘-k’ option says that the real purpose is to test as many of the changes made in the program as possible, perhaps to find several independent problems so that you can correct them all before the next attempt to compile. This is why Emacs’ compile command passes the ‘-k’ flag by default.
Usually when a recipe line fails, if it has changed the target file at all, the file is corrupted and cannot be used—or at least it is not completely updated. Yet the file’s time stamp says that it is now up to date, so the next time make runs, it will not try to update that file. The situation is just the same as when the shell is killed by a signal; see Section 5.6 [Interrupts], page 52. So generally the right thing to do is to delete the target file if the recipe fails after beginning to change the file. make will do this if .DELETE_ON_ERROR appears as a target. This is almost always what you want make to do, but it is not historical practice; so for compatibility, you must explicitly request it.
5.6 Interrupting or Killing make
If make gets a fatal signal while a shell is executing, it may delete the target file that the recipe was supposed to update. This is done if the target file’s last-modification time has changed since make first checked it.
The purpose of deleting the target is to make sure that it is remade from scratch when make is next run. Why is this? Suppose you type Ctrl-c while a compiler is running, and it has begun to write an object file foo.o. The Ctrl-c kills the compiler, resulting in an incomplete file whose last-modification time is newer than the source file foo.c. But make also receives the Ctrl-c signal and deletes this incomplete file. If make did not do this, the next invocation of make would think that foo.o did not require updating—resulting in a strange error message from the linker when it tries to link an object file half of which is missing.
You can prevent the deletion of a target file in this way by making the special target .PRECIOUS depend on it. Before remaking a target, make checks to see whether it appears on the prerequisites of .PRECIOUS, and thereby decides whether the target should be deleted if a signal happens. Some reasons why you might do this are that the target is updated in some atomic fashion, or exists only to record a modification-time (its contents do not matter), or must exist at all times to prevent other sorts of trouble.
Although make does its best to clean up there are certain situations in which cleanup is impossible. For example, make may be killed by an uncatchable signal. Or, one of the programs make invokes may be killed or crash, leaving behind an up-to-date but corrupt target file: make will not realize that this failure requires the target to be cleaned. Or make itself may encounter a bug and crash.
For these reasons it’s best to write defensive recipes, which won’t leave behind corrupted targets even if they fail. Most commonly these recipes create temporary files rather than updating the target directly, then rename the temporary file to the final target name. Some compilers already behave this way, so that you don’t need to write a defensive recipe.

Chapter 5: Writing Recipes in Rules

53

5.7 Recursive Use of make
Recursive use of make means using make as a command in a makefile. This technique is useful when you want separate makefiles for various subsystems that compose a larger system. For example, suppose you have a sub-directory subdir which has its own makefile, and you would like the containing directory’s makefile to run make on the sub-directory. You can do it by writing this:
subsystem: cd subdir && $(MAKE)
or, equivalently, this (see Section 9.7 [Summary of Options], page 108):
subsystem: $(MAKE) -C subdir
You can write recursive make commands just by copying this example, but there are many things to know about how they work and why, and about how the sub-make relates to the top-level make. You may also find it useful to declare targets that invoke recursive make commands as ‘.PHONY’ (for more discussion on when this is useful, see Section 4.5 [Phony Targets], page 31).
For your convenience, when GNU make starts (after it has processed any -C options) it sets the variable CURDIR to the pathname of the current working directory. This value is never touched by make again: in particular note that if you include files from other directories the value of CURDIR does not change. The value has the same precedence it would have if it were set in the makefile (by default, an environment variable CURDIR will not override this value). Note that setting this variable has no impact on the operation of make (it does not cause make to change its working directory, for example).
5.7.1 How the MAKE Variable Works
Recursive make commands should always use the variable MAKE, not the explicit command name ‘make’, as shown here:
subsystem: cd subdir && $(MAKE)
The value of this variable is the file name with which make was invoked. If this file name was /bin/make, then the recipe executed is ‘cd subdir && /bin/make’. If you use a special version of make to run the top-level makefile, the same special version will be executed for recursive invocations.
As a special feature, using the variable MAKE in the recipe of a rule alters the effects of the ‘-t’ (‘--touch’), ‘-n’ (‘--just-print’), or ‘-q’ (‘--question’) option. Using the MAKE variable has the same effect as using a ‘+’ character at the beginning of the recipe line. See Section 9.3 [Instead of Executing the Recipes], page 105. This special feature is only enabled if the MAKE variable appears directly in the recipe: it does not apply if the MAKE variable is referenced through expansion of another variable. In the latter case you must use the ‘+’ token to get these special effects.
Consider the command ‘make -t’ in the above example. (The ‘-t’ option marks targets as up to date without actually running any recipes; see Section 9.3 [Instead of Execution], page 105.) Following the usual definition of ‘-t’, a ‘make -t’ command in the example would create a file named subsystem and do nothing else. What you really want it to do is

54

GNU make

run ‘cd subdir && make -t’; but that would require executing the recipe, and ‘-t’ says not to execute recipes.
The special feature makes this do what you want: whenever a recipe line of a rule contains the variable MAKE, the flags ‘-t’, ‘-n’ and ‘-q’ do not apply to that line. Recipe lines containing MAKE are executed normally despite the presence of a flag that causes most recipes not to be run. The usual MAKEFLAGS mechanism passes the flags to the sub-make (see Section 5.7.3 [Communicating Options to a Sub-make], page 56), so your request to touch the files, or print the recipes, is propagated to the subsystem.
5.7.2 Communicating Variables to a Sub-make
Variable values of the top-level make can be passed to the sub-make through the environment by explicit request. These variables are defined in the sub-make as defaults, but they do not override variables defined in the makefile used by the sub-make unless you use the ‘-e’ switch (see Section 9.7 [Summary of Options], page 108).
To pass down, or export, a variable, make adds the variable and its value to the environment for running each line of the recipe. The sub-make, in turn, uses the environment to initialize its table of variable values. See Section 6.10 [Variables from the Environment], page 72.
Except by explicit request, make exports a variable only if it is either defined in the environment initially or set on the command line, and if its name consists only of letters, numbers, and underscores. Some shells cannot cope with environment variable names consisting of characters other than letters, numbers, and underscores.
The value of the make variable SHELL is not exported. Instead, the value of the SHELL variable from the invoking environment is passed to the sub-make. You can force make to export its value for SHELL by using the export directive, described below. See Section 5.3.2 [Choosing the Shell], page 47.
The special variable MAKEFLAGS is always exported (unless you unexport it). MAKEFILES is exported if you set it to anything.
make automatically passes down variable values that were defined on the command line, by putting them in the MAKEFLAGS variable. See the next section.
Variables are not normally passed down if they were created by default by make (see Section 10.3 [Variables Used by Implicit Rules], page 119). The sub-make will define these for itself.
If you want to export specific variables to a sub-make, use the export directive, like this:
export variable ...
If you want to prevent a variable from being exported, use the unexport directive, like this:
unexport variable ...
In both of these forms, the arguments to export and unexport are expanded, and so could be variables or functions which expand to a (list of) variable names to be (un)exported.
As a convenience, you can define a variable and export it at the same time by doing:
export variable = value
has the same result as:
variable = value

Chapter 5: Writing Recipes in Rules

55

export variable and
export variable := value has the same result as:
variable := value export variable Likewise,
export variable += value is just like:
variable += value export variable See Section 6.6 [Appending More Text to Variables], page 69.
You may notice that the export and unexport directives work in make in the same way they work in the shell, sh.
If you want all variables to be exported by default, you can use export by itself:
export This tells make that variables which are not explicitly mentioned in an export or unexport directive should be exported. Any variable given in an unexport directive will still not be exported. If you use export by itself to export variables by default, variables whose names contain characters other than alphanumerics and underscores will not be exported unless specifically mentioned in an export directive.
The behavior elicited by an export directive by itself was the default in older versions of GNU make. If your makefiles depend on this behavior and you want to be compatible with old versions of make, you can write a rule for the special target .EXPORT_ALL_VARIABLES instead of using the export directive. This will be ignored by old makes, while the export directive will cause a syntax error.
Likewise, you can use unexport by itself to tell make not to export variables by default. Since this is the default behavior, you would only need to do this if export had been used by itself earlier (in an included makefile, perhaps). You cannot use export and unexport by themselves to have variables exported for some recipes and not for others. The last export or unexport directive that appears by itself determines the behavior for the entire run of make.
As a special feature, the variable MAKELEVEL is changed when it is passed down from level to level. This variable’s value is a string which is the depth of the level as a decimal number. The value is ‘0’ for the top-level make; ‘1’ for a sub-make, ‘2’ for a sub-sub-make, and so on. The incrementation happens when make sets up the environment for a recipe.
The main use of MAKELEVEL is to test it in a conditional directive (see Chapter 7 [Conditional Parts of Makefiles], page 81); this way you can write a makefile that behaves one way if run recursively and another way if run directly by you.
You can use the variable MAKEFILES to cause all sub-make commands to use additional makefiles. The value of MAKEFILES is a whitespace-separated list of file names. This variable, if defined in the outer-level makefile, is passed down through the environment; then it serves as a list of extra makefiles for the sub-make to read before the usual or specified ones. See Section 3.4 [The Variable MAKEFILES], page 14.

56

GNU make

5.7.3 Communicating Options to a Sub-make
Flags such as ‘-s’ and ‘-k’ are passed automatically to the sub-make through the variable MAKEFLAGS. This variable is set up automatically by make to contain the flag letters that make received. Thus, if you do ‘make -ks’ then MAKEFLAGS gets the value ‘ks’.
As a consequence, every sub-make gets a value for MAKEFLAGS in its environment. In response, it takes the flags from that value and processes them as if they had been given as arguments. See Section 9.7 [Summary of Options], page 108.
Likewise variables defined on the command line are passed to the sub-make through MAKEFLAGS. Words in the value of MAKEFLAGS that contain ‘=’, make treats as variable definitions just as if they appeared on the command line. See Section 9.5 [Overriding Variables], page 107.
The options ‘-C’, ‘-f’, ‘-o’, and ‘-W’ are not put into MAKEFLAGS; these options are not passed down.
The ‘-j’ option is a special case (see Section 5.4 [Parallel Execution], page 49). If you set it to some numeric value ‘N’ and your operating system supports it (most any UNIX system will; others typically won’t), the parent make and all the sub-makes will communicate to ensure that there are only ‘N’ jobs running at the same time between them all. Note that any job that is marked recursive (see Section 9.3 [Instead of Executing Recipes], page 105) doesn’t count against the total jobs (otherwise we could get ‘N’ sub-makes running and have no slots left over for any real work!)
If your operating system doesn’t support the above communication, then no ‘-j’ is added to MAKEFLAGS, so that sub-makes run in non-parallel mode. If the ‘-j’ option were passed down to sub-makes you would get many more jobs running in parallel than you asked for. If you give ‘-j’ with no numeric argument, meaning to run as many jobs as possible in parallel, this is passed down, since multiple infinities are no more than one.
If you do not want to pass the other flags down, you must change the value of MAKEFLAGS, like this:
subsystem: cd subdir && $(MAKE) MAKEFLAGS=
The command line variable definitions really appear in the variable MAKEOVERRIDES, and MAKEFLAGS contains a reference to this variable. If you do want to pass flags down normally, but don’t want to pass down the command line variable definitions, you can reset MAKEOVERRIDES to empty, like this:
MAKEOVERRIDES =
This is not usually useful to do. However, some systems have a small fixed limit on the size of the environment, and putting so much information into the value of MAKEFLAGS can exceed it. If you see the error message ‘Arg list too long’, this may be the problem. (For strict compliance with POSIX.2, changing MAKEOVERRIDES does not affect MAKEFLAGS if the special target ‘.POSIX’ appears in the makefile. You probably do not care about this.)
A similar variable MFLAGS exists also, for historical compatibility. It has the same value as MAKEFLAGS except that it does not contain the command line variable definitions, and it always begins with a hyphen unless it is empty (MAKEFLAGS begins with a hyphen only when it begins with an option that has no single-letter version, such as

Chapter 5: Writing Recipes in Rules

57

‘--warn-undefined-variables’). MFLAGS was traditionally used explicitly in the recursive make command, like this:
subsystem: cd subdir && $(MAKE) $(MFLAGS)
but now MAKEFLAGS makes this usage redundant. If you want your makefiles to be compatible with old make programs, use this technique; it will work fine with more modern make versions too.
The MAKEFLAGS variable can also be useful if you want to have certain options, such as ‘-k’ (see Section 9.7 [Summary of Options], page 108), set each time you run make. You simply put a value for MAKEFLAGS in your environment. You can also set MAKEFLAGS in a makefile, to specify additional flags that should also be in effect for that makefile. (Note that you cannot use MFLAGS this way. That variable is set only for compatibility; make does not interpret a value you set for it in any way.)
When make interprets the value of MAKEFLAGS (either from the environment or from a makefile), it first prepends a hyphen if the value does not already begin with one. Then it chops the value into words separated by blanks, and parses these words as if they were options given on the command line (except that ‘-C’, ‘-f’, ‘-h’, ‘-o’, ‘-W’, and their longnamed versions are ignored; and there is no error for an invalid option).
If you do put MAKEFLAGS in your environment, you should be sure not to include any options that will drastically affect the actions of make and undermine the purpose of makefiles and of make itself. For instance, the ‘-t’, ‘-n’, and ‘-q’ options, if put in one of these variables, could have disastrous consequences and would certainly have at least surprising and probably annoying effects.
If you’d like to run other implementations of make in addition to GNU make, and hence do not want to add GNU make-specific flags to the MAKEFLAGS variable, you can add them to the GNUMAKEFLAGS variable instead. This variable is parsed just before MAKEFLAGS, in the same way as MAKEFLAGS. When make constructs MAKEFLAGS to pass to a recursive make it will include all flags, even those taken from GNUMAKEFLAGS. As a result, after parsing GNUMAKEFLAGS GNU make sets this variable to the empty string to avoid duplicating flags during recursion.
It’s best to use GNUMAKEFLAGS only with flags which won’t materially change the behavior of your makefiles. If your makefiles require GNU make anyway then simply use MAKEFLAGS. Flags such as ‘--no-print-directory’ or ‘--output-sync’ may be appropriate for GNUMAKEFLAGS.
5.7.4 The ‘--print-directory’ Option
If you use several levels of recursive make invocations, the ‘-w’ or ‘--print-directory’ option can make the output a lot easier to understand by showing each directory as make starts processing it and as make finishes processing it. For example, if ‘make -w’ is run in the directory /u/gnu/make, make will print a line of the form:
make: Entering directory ‘/u/gnu/make’.
before doing anything else, and a line of the form:
make: Leaving directory ‘/u/gnu/make’.
when processing is completed.

58

GNU make

Normally, you do not need to specify this option because ‘make’ does it for you: ‘-w’ is turned on automatically when you use the ‘-C’ option, and in sub-makes. make will not automatically turn on ‘-w’ if you also use ‘-s’, which says to be silent, or if you use ‘--no-print-directory’ to explicitly disable it.
5.8 Defining Canned Recipes
When the same sequence of commands is useful in making various targets, you can define it as a canned sequence with the define directive, and refer to the canned sequence from the recipes for those targets. The canned sequence is actually a variable, so the name must not conflict with other variable names.
Here is an example of defining a canned recipe:
define run-yacc = yacc $(firstword $^) mv y.tab.c $@ endef
Here run-yacc is the name of the variable being defined; endef marks the end of the definition; the lines in between are the commands. The define directive does not expand variable references and function calls in the canned sequence; the ‘$’ characters, parentheses, variable names, and so on, all become part of the value of the variable you are defining. See Section 6.8 [Defining Multi-Line Variables], page 71, for a complete explanation of define.
The first command in this example runs Yacc on the first prerequisite of whichever rule uses the canned sequence. The output file from Yacc is always named y.tab.c. The second command moves the output to the rule’s target file name.
To use the canned sequence, substitute the variable into the recipe of a rule. You can substitute it like any other variable (see Section 6.1 [Basics of Variable References], page 61). Because variables defined by define are recursively expanded variables, all the variable references you wrote inside the define are expanded now. For example:
foo.c : foo.y $(run-yacc)
‘foo.y’ will be substituted for the variable ‘$^’ when it occurs in run-yacc’s value, and ‘foo.c’ for ‘$@’.
This is a realistic example, but this particular one is not needed in practice because make has an implicit rule to figure out these commands based on the file names involved (see Chapter 10 [Using Implicit Rules], page 115).
In recipe execution, each line of a canned sequence is treated just as if the line appeared on its own in the rule, preceded by a tab. In particular, make invokes a separate sub-shell for each line. You can use the special prefix characters that affect command lines (‘@’, ‘-’, and ‘+’) on each line of a canned sequence. See Chapter 5 [Writing Recipes in Rules], page 43. For example, using this canned sequence:
define frobnicate = @echo "frobnicating target $@" frob-step-1 $< -o $@-step-1 frob-step-2 $@-step-1 -o $@ endef

Chapter 5: Writing Recipes in Rules

59

make will not echo the first line, the echo command. But it will echo the following two recipe lines.
On the other hand, prefix characters on the recipe line that refers to a canned sequence apply to every line in the sequence. So the rule:
frob.out: frob.in @$(frobnicate)
does not echo any recipe lines. (See Section 5.2 [Recipe Echoing], page 45, for a full explanation of ‘@’.)
5.9 Using Empty Recipes
It is sometimes useful to define recipes which do nothing. This is done simply by giving a recipe that consists of nothing but whitespace. For example:
target: ; defines an empty recipe for target. You could also use a line beginning with a recipe prefix character to define an empty recipe, but this would be confusing because such a line looks empty.
You may be wondering why you would want to define a recipe that does nothing. One reason this is useful is to prevent a target from getting implicit recipes (from implicit rules or the .DEFAULT special target; see Chapter 10 [Implicit Rules], page 115, and see Section 10.6 [Defining Last-Resort Default Rules], page 129).
Empty recipes can also be used to avoid errors for targets that will be created as a side-effect of another recipe: if the target does not exist the empty recipe ensures that make won’t complain that it doesn’t know how to build the target, and make will assume the target is out of date.
You may be inclined to define empty recipes for targets that are not actual files, but only exist so that their prerequisites can be remade. However, this is not the best way to do that, because the prerequisites may not be remade properly if the target file actually does exist. See Section 4.5 [Phony Targets], page 31, for a better way to do this.

61
6 How to Use Variables
A variable is a name defined in a makefile to represent a string of text, called the variable’s value. These values are substituted by explicit request into targets, prerequisites, recipes, and other parts of the makefile. (In some other versions of make, variables are called macros.)
Variables and functions in all parts of a makefile are expanded when read, except for in recipes, the right-hand sides of variable definitions using ‘=’, and the bodies of variable definitions using the define directive.
Variables can represent lists of file names, options to pass to compilers, programs to run, directories to look in for source files, directories to write output in, or anything else you can imagine.
A variable name may be any sequence of characters not containing ‘:’, ‘#’, ‘=’, or whitespace. However, variable names containing characters other than letters, numbers, and underscores should be considered carefully, as in some shells they cannot be passed through the environment to a sub-make (see Section 5.7.2 [Communicating Variables to a Sub-make], page 54). Variable names beginning with ‘.’ and an uppercase letter may be given special meaning in future versions of make.
Variable names are case-sensitive. The names ‘foo’, ‘FOO’, and ‘Foo’ all refer to different variables.
It is traditional to use upper case letters in variable names, but we recommend using lower case letters for variable names that serve internal purposes in the makefile, and reserving upper case for parameters that control implicit rules or for parameters that the user should override with command options (see Section 9.5 [Overriding Variables], page 107).
A few variables have names that are a single punctuation character or just a few characters. These are the automatic variables, and they have particular specialized uses. See Section 10.5.3 [Automatic Variables], page 124.
6.1 Basics of Variable References
To substitute a variable’s value, write a dollar sign followed by the name of the variable in parentheses or braces: either ‘$(foo)’ or ‘${foo}’ is a valid reference to the variable foo. This special significance of ‘$’ is why you must write ‘$$’ to have the effect of a single dollar sign in a file name or recipe.
Variable references can be used in any context: targets, prerequisites, recipes, most directives, and new variable values. Here is an example of a common case, where a variable holds the names of all the object files in a program:
objects = program.o foo.o utils.o program : $(objects)
cc -o program $(objects)
$(objects) : defs.h Variable references work by strict textual substitution. Thus, the rule
foo = c prog.o : prog.$(foo)
$(foo)$(foo) -$(foo) prog.$(foo)

62

GNU make

could be used to compile a C program prog.c. Since spaces before the variable value are ignored in variable assignments, the value of foo is precisely ‘c’. (Don’t actually write your makefiles this way!)
A dollar sign followed by a character other than a dollar sign, open-parenthesis or openbrace treats that single character as the variable name. Thus, you could reference the variable x with ‘$x’. However, this practice can lead to confusion (e.g., ‘$foo’ refers to the variable f followed by the string oo) so we recommend using parentheses or braces around all variables, even single-letter variables, unless omitting them gives significant readability improvements. One place where readability is often improved is automatic variables (see Section 10.5.3 [Automatic Variables], page 124).
6.2 The Two Flavors of Variables
There are two ways that a variable in GNU make can have a value; we call them the two flavors of variables. The two flavors are distinguished in how they are defined and in what they do when expanded.
The first flavor of variable is a recursively expanded variable. Variables of this sort are defined by lines using ‘=’ (see Section 6.5 [Setting Variables], page 67) or by the define directive (see Section 6.8 [Defining Multi-Line Variables], page 71). The value you specify is installed verbatim; if it contains references to other variables, these references are expanded whenever this variable is substituted (in the course of expanding some other string). When this happens, it is called recursive expansion.
For example,
foo = $(bar) bar = $(ugh) ugh = Huh?
all:;echo $(foo) will echo ‘Huh?’: ‘$(foo)’ expands to ‘$(bar)’ which expands to ‘$(ugh)’ which finally expands to ‘Huh?’.
This flavor of variable is the only sort supported by most other versions of make. It has its advantages and its disadvantages. An advantage (most would say) is that:
CFLAGS = $(include_dirs) -O include_dirs = -Ifoo -Ibar will do what was intended: when ‘CFLAGS’ is expanded in a recipe, it will expand to ‘-Ifoo -Ibar -O’. A major disadvantage is that you cannot append something on the end of a variable, as in
CFLAGS = $(CFLAGS) -O because it will cause an infinite loop in the variable expansion. (Actually make detects the infinite loop and reports an error.)
Another disadvantage is that any functions (see Chapter 8 [Functions for Transforming Text], page 87) referenced in the definition will be executed every time the variable is expanded. This makes make run slower; worse, it causes the wildcard and shell functions to give unpredictable results because you cannot easily control when they are called, or even how many times.

Chapter 6: How to Use Variables

63

To avoid all the problems and inconveniences of recursively expanded variables, there is another flavor: simply expanded variables.
Simply expanded variables are defined by lines using ‘:=’ or ‘::=’ (see Section 6.5 [Setting Variables], page 67). Both forms are equivalent in GNU make; however only the ‘::=’ form is described by the POSIX standard (support for ‘::=’ was added to the POSIX standard in 2012, so older versions of make won’t accept this form either).
The value of a simply expanded variable is scanned once and for all, expanding any references to other variables and functions, when the variable is defined. The actual value of the simply expanded variable is the result of expanding the text that you write. It does not contain any references to other variables; it contains their values as of the time this variable was defined. Therefore,
x := foo y := $(x) bar x := later
is equivalent to
y := foo bar x := later
When a simply expanded variable is referenced, its value is substituted verbatim.
Here is a somewhat more complicated example, illustrating the use of ‘:=’ in conjunction with the shell function. (See Section 8.13 [The shell Function], page 101.) This example also shows use of the variable MAKELEVEL, which is changed when it is passed down from level to level. (See Section 5.7.2 [Communicating Variables to a Sub-make], page 54, for information about MAKELEVEL.)
ifeq (0,${MAKELEVEL}) whoami := $(shell whoami) host-type := $(shell arch) MAKE := ${MAKE} host-type=${host-type} whoami=${whoami} endif
An advantage of this use of ‘:=’ is that a typical ‘descend into a directory’ recipe then looks like this:
${subdirs}: ${MAKE} -C $@ all
Simply expanded variables generally make complicated makefile programming more predictable because they work like variables in most programming languages. They allow you to redefine a variable using its own value (or its value processed in some way by one of the expansion functions) and to use the expansion functions much more efficiently (see Chapter 8 [Functions for Transforming Text], page 87).
You can also use them to introduce controlled leading whitespace into variable values. Leading whitespace characters are discarded from your input before substitution of variable references and function calls; this means you can include leading spaces in a variable value by protecting them with variable references, like this:
nullstring := space := $(nullstring) # end of the line

64

GNU make

Here the value of the variable space is precisely one space. The comment ‘# end of the line’ is included here just for clarity. Since trailing space characters are not stripped from variable values, just a space at the end of the line would have the same effect (but be rather hard to read). If you put whitespace at the end of a variable value, it is a good idea to put a comment like that at the end of the line to make your intent clear. Conversely, if you do not want any whitespace characters at the end of your variable value, you must remember not to put a random comment on the end of the line after some whitespace, such as this:
dir := /foo/bar # directory to put the frobs in Here the value of the variable dir is ‘/foo/bar ’ (with four trailing spaces), which was probably not the intention. (Imagine something like ‘$(dir)/file’ with this definition!)
There is another assignment operator for variables, ‘?=’. This is called a conditional variable assignment operator, because it only has an effect if the variable is not yet defined. This statement:
FOO ?= bar is exactly equivalent to this (see Section 8.10 [The origin Function], page 98):
ifeq ($(origin FOO), undefined) FOO = bar
endif Note that a variable set to an empty value is still defined, so ‘?=’ will not set that variable.
6.3 Advanced Features for Reference to Variables
This section describes some advanced features you can use to reference variables in more flexible ways.
6.3.1 Substitution References
A substitution reference substitutes the value of a variable with alterations that you specify. It has the form ‘$(var:a=b)’ (or ‘${var:a=b}’) and its meaning is to take the value of the variable var, replace every a at the end of a word with b in that value, and substitute the resulting string.
When we say “at the end of a word”, we mean that a must appear either followed by whitespace or at the end of the value in order to be replaced; other occurrences of a in the value are unaltered. For example:
foo := a.o b.o l.a c.o bar := $(foo:.o=.c) sets ‘bar’ to ‘a.c b.c l.a c.c’. See Section 6.5 [Setting Variables], page 67. A substitution reference is shorthand for the patsubst expansion function (see Section 8.2 [Functions for String Substitution and Analysis], page 88): ‘$(var:a=b)’ is equivalent to ‘$(patsubst %a,%b,var)’. We provide substitution references as well as patsubst for compatibility with other implementations of make. Another type of substitution reference lets you use the full power of the patsubst function. It has the same form ‘$(var:a=b)’ described above, except that now a must contain a

Chapter 6: How to Use Variables

65

single ‘%’ character. This case is equivalent to ‘$(patsubst a,b,$(var))’. See Section 8.2 [Functions for String Substitution and Analysis], page 88, for a description of the patsubst function.
For example:
foo := a.o b.o l.a c.o bar := $(foo:%.o=%.c) sets ‘bar’ to ‘a.c b.c l.a c.c’.
6.3.2 Computed Variable Names
Computed variable names are a complicated concept needed only for sophisticated makefile programming. For most purposes you need not consider them, except to know that making a variable with a dollar sign in its name might have strange results. However, if you are the type that wants to understand everything, or you are actually interested in what they do, read on.
Variables may be referenced inside the name of a variable. This is called a computed variable name or a nested variable reference. For example,
x=y y=z a := $($(x)) defines a as ‘z’: the ‘$(x)’ inside ‘$($(x))’ expands to ‘y’, so ‘$($(x))’ expands to ‘$(y)’ which in turn expands to ‘z’. Here the name of the variable to reference is not stated explicitly; it is computed by expansion of ‘$(x)’. The reference ‘$(x)’ here is nested within the outer variable reference.
The previous example shows two levels of nesting, but any number of levels is possible. For example, here are three levels:
x=y y=z z=u a := $($($(x))) Here the innermost ‘$(x)’ expands to ‘y’, so ‘$($(x))’ expands to ‘$(y)’ which in turn expands to ‘z’; now we have ‘$(z)’, which becomes ‘u’. References to recursively-expanded variables within a variable name are re-expanded in the usual fashion. For example:
x = $(y) y=z z = Hello a := $($(x)) defines a as ‘Hello’: ‘$($(x))’ becomes ‘$($(y))’ which becomes ‘$(z)’ which becomes ‘Hello’. Nested variable references can also contain modified references and function invocations (see Chapter 8 [Functions for Transforming Text], page 87), just like any other reference. For example, using the subst function (see Section 8.2 [Functions for String Substitution and Analysis], page 88):

66

GNU make

x = variable1 variable2 := Hello y = $(subst 1,2,$(x)) z=y a := $($($(z)))
eventually defines a as ‘Hello’. It is doubtful that anyone would ever want to write a nested reference as convoluted as this one, but it works: ‘$($($(z)))’ expands to ‘$($(y))’ which becomes ‘$($(subst 1,2,$(x)))’. This gets the value ‘variable1’ from x and changes it by substitution to ‘variable2’, so that the entire string becomes ‘$(variable2)’, a simple variable reference whose value is ‘Hello’.
A computed variable name need not consist entirely of a single variable reference. It can contain several variable references, as well as some invariant text. For example,
a_dirs := dira dirb 1_dirs := dir1 dir2
a_files := filea fileb 1_files := file1 file2
ifeq "$(use_a)" "yes" a1 := a else a1 := 1 endif
ifeq "$(use_dirs)" "yes" df := dirs else df := files endif
dirs := $($(a1)_$(df))
will give dirs the same value as a_dirs, 1_dirs, a_files or 1_files depending on the settings of use_a and use_dirs.
Computed variable names can also be used in substitution references:
a_objects := a.o b.o c.o 1_objects := 1.o 2.o 3.o
sources := $($(a1)_objects:.o=.c)
defines sources as either ‘a.c b.c c.c’ or ‘1.c 2.c 3.c’, depending on the value of a1.
The only restriction on this sort of use of nested variable references is that they cannot specify part of the name of a function to be called. This is because the test for a recognized function name is done before the expansion of nested references. For example,

Chapter 6: How to Use Variables

67

ifdef do_sort func := sort else func := strip endif
bar := a d b g q c
foo := $($(func) $(bar)) attempts to give ‘foo’ the value of the variable ‘sort a d b g q c’ or ‘strip a d b g q c’, rather than giving ‘a d b g q c’ as the argument to either the sort or the strip function. This restriction could be removed in the future if that change is shown to be a good idea.
You can also use computed variable names in the left-hand side of a variable assignment, or in a define directive, as in:
dir = foo $(dir)_sources := $(wildcard $(dir)/*.c) define $(dir)_print = lpr $($(dir)_sources) endef This example defines the variables ‘dir’, ‘foo_sources’, and ‘foo_print’. Note that nested variable references are quite different from recursively expanded variables (see Section 6.2 [The Two Flavors of Variables], page 62), though both are used together in complex ways when doing makefile programming.
6.4 How Variables Get Their Values
Variables can get values in several different ways: • You can specify an overriding value when you run make. See Section 9.5 [Overriding Variables], page 107. • You can specify a value in the makefile, either with an assignment (see Section 6.5 [Setting Variables], page 67) or with a verbatim definition (see Section 6.8 [Defining Multi-Line Variables], page 71). • Variables in the environment become make variables. See Section 6.10 [Variables from the Environment], page 72. • Several automatic variables are given new values for each rule. Each of these has a single conventional use. See Section 10.5.3 [Automatic Variables], page 124. • Several variables have constant initial values. See Section 10.3 [Variables Used by Implicit Rules], page 119.
6.5 Setting Variables
To set a variable from the makefile, write a line starting with the variable name followed by ‘=’, ‘:=’, or ‘::=’. Whatever follows the ‘=’, ‘:=’, or ‘::=’ on the line becomes the value. For example,
objects = main.o foo.o bar.o utils.o

68

GNU make

defines a variable named objects. Whitespace around the variable name and immediately after the ‘=’ is ignored.
Variables defined with ‘=’ are recursively expanded variables. Variables defined with ‘:=’ or ‘::=’ are simply expanded variables; these definitions can contain variable references which will be expanded before the definition is made. See Section 6.2 [The Two Flavors of Variables], page 62.
The variable name may contain function and variable references, which are expanded when the line is read to find the actual variable name to use.
There is no limit on the length of the value of a variable except the amount of memory on the computer. You can split the value of a variable into multiple physical lines for readability (see Section 3.1.1 [Splitting Long Lines], page 12).
Most variable names are considered to have the empty string as a value if you have never set them. Several variables have built-in initial values that are not empty, but you can set them in the usual ways (see Section 10.3 [Variables Used by Implicit Rules], page 119). Several special variables are set automatically to a new value for each rule; these are called the automatic variables (see Section 10.5.3 [Automatic Variables], page 124).
If you’d like a variable to be set to a value only if it’s not already set, then you can use the shorthand operator ‘?=’ instead of ‘=’. These two settings of the variable ‘FOO’ are identical (see Section 8.10 [The origin Function], page 98):
FOO ?= bar
and
ifeq ($(origin FOO), undefined) FOO = bar endif
The shell assignment operator ‘!=’ can be used to execute a shell script and set a variable to its output. This operator first evaluates the right-hand side, then passes that result to the shell for execution. If the result of the execution ends in a newline, that one newline is removed; all other newlines are replaced by spaces. The resulting string is then placed into the named recursively-expanded variable. For example:
hash != printf ’\043’ file_list != find . -name ’*.c’
If the result of the execution could produce a $, and you don’t intend what follows that to be interpreted as a make variable or function reference, then you must replace every $ with $$ as part of the execution. Alternatively, you can set a simply expanded variable to the result of running a program using the shell function call. See Section 8.13 [The shell Function], page 101. For example:
hash := $(shell printf ’\043’) var := $(shell find . -name "*.c")
As with the shell function, the exit status of the just-invoked shell script is stored in the .SHELLSTATUS variable.

Chapter 6: How to Use Variables

69

6.6 Appending More Text to Variables
Often it is useful to add more text to the value of a variable already defined. You do this with a line containing ‘+=’, like this:
objects += another.o
This takes the value of the variable objects, and adds the text ‘another.o’ to it (preceded by a single space, if it has a value already). Thus:
objects = main.o foo.o bar.o utils.o objects += another.o
sets objects to ‘main.o foo.o bar.o utils.o another.o’.
Using ‘+=’ is similar to:
objects = main.o foo.o bar.o utils.o objects := $(objects) another.o
but differs in ways that become important when you use more complex values.
When the variable in question has not been defined before, ‘+=’ acts just like normal ‘=’: it defines a recursively-expanded variable. However, when there is a previous definition, exactly what ‘+=’ does depends on what flavor of variable you defined originally. See Section 6.2 [The Two Flavors of Variables], page 62, for an explanation of the two flavors of variables.
When you add to a variable’s value with ‘+=’, make acts essentially as if you had included the extra text in the initial definition of the variable. If you defined it first with ‘:=’ or ‘::=’, making it a simply-expanded variable, ‘+=’ adds to that simply-expanded definition, and expands the new text before appending it to the old value just as ‘:=’ does (see Section 6.5 [Setting Variables], page 67, for a full explanation of ‘:=’ or ‘::=’). In fact,
variable := value variable += more
is exactly equivalent to:
variable := value variable := $(variable) more
On the other hand, when you use ‘+=’ with a variable that you defined first to be recursively-expanded using plain ‘=’, make does something a bit different. Recall that when you define a recursively-expanded variable, make does not expand the value you set for variable and function references immediately. Instead it stores the text verbatim, and saves these variable and function references to be expanded later, when you refer to the new variable (see Section 6.2 [The Two Flavors of Variables], page 62). When you use ‘+=’ on a recursively-expanded variable, it is this unexpanded text to which make appends the new text you specify.
variable = value variable += more
is roughly equivalent to:
temp = value variable = $(temp) more

70

GNU make

except that of course it never defines a variable called temp. The importance of this comes when the variable’s old value contains variable references. Take this common example:
CFLAGS = $(includes) -O ... CFLAGS += -pg # enable profiling
The first line defines the CFLAGS variable with a reference to another variable, includes. (CFLAGS is used by the rules for C compilation; see Section 10.2 [Catalogue of Built-In Rules], page 116.) Using ‘=’ for the definition makes CFLAGS a recursively-expanded variable, meaning ‘$(includes) -O’ is not expanded when make processes the definition of CFLAGS. Thus, includes need not be defined yet for its value to take effect. It only has to be defined before any reference to CFLAGS. If we tried to append to the value of CFLAGS without using ‘+=’, we might do it like this:
CFLAGS := $(CFLAGS) -pg # enable profiling
This is pretty close, but not quite what we want. Using ‘:=’ redefines CFLAGS as a simplyexpanded variable; this means make expands the text ‘$(CFLAGS) -pg’ before setting the variable. If includes is not yet defined, we get ‘ -O -pg’, and a later definition of includes will have no effect. Conversely, by using ‘+=’ we set CFLAGS to the unexpanded value ‘$(includes) -O -pg’. Thus we preserve the reference to includes, so if that variable gets defined at any later point, a reference like ‘$(CFLAGS)’ still uses its value.
6.7 The override Directive
If a variable has been set with a command argument (see Section 9.5 [Overriding Variables], page 107), then ordinary assignments in the makefile are ignored. If you want to set the variable in the makefile even though it was set with a command argument, you can use an override directive, which is a line that looks like this:
override variable = value
or
override variable := value
To append more text to a variable defined on the command line, use:
override variable += more text
See Section 6.6 [Appending More Text to Variables], page 69.
Variable assignments marked with the override flag have a higher priority than all other assignments, except another override. Subsequent assignments or appends to this variable which are not marked override will be ignored.
The override directive was not invented for escalation in the war between makefiles and command arguments. It was invented so you can alter and add to values that the user specifies with command arguments.
For example, suppose you always want the ‘-g’ switch when you run the C compiler, but you would like to allow the user to specify the other switches with a command argument just as usual. You could use this override directive:
override CFLAGS += -g

Chapter 6: How to Use Variables

71

You can also use override directives with define directives. This is done as you might expect:
override define foo = bar endef
See the next section for information about define.
6.8 Defining Multi-Line Variables
Another way to set the value of a variable is to use the define directive. This directive has an unusual syntax which allows newline characters to be included in the value, which is convenient for defining both canned sequences of commands (see Section 5.8 [Defining Canned Recipes], page 58), and also sections of makefile syntax to use with eval (see Section 8.9 [Eval Function], page 97).
The define directive is followed on the same line by the name of the variable being defined and an (optional) assignment operator, and nothing more. The value to give the variable appears on the following lines. The end of the value is marked by a line containing just the word endef.
Aside from this difference in syntax, define works just like any other variable definition. The variable name may contain function and variable references, which are expanded when the directive is read to find the actual variable name to use.
The final newline before the endef is not included in the value; if you want your value to contain a trailing newline you must include a blank line. For example in order to define a variable that contains a newline character you must use two empty lines, not one:
define newline
endef
You may omit the variable assignment operator if you prefer. If omitted, make assumes it to be ‘=’ and creates a recursively-expanded variable (see Section 6.2 [The Two Flavors of Variables], page 62). When using a ‘+=’ operator, the value is appended to the previous value as with any other append operation: with a single space separating the old and new values.
You may nest define directives: make will keep track of nested directives and report an error if they are not all properly closed with endef. Note that lines beginning with the recipe prefix character are considered part of a recipe, so any define or endef strings appearing on such a line will not be considered make directives.
define two-lines echo foo echo $(bar) endef When used in a recipe, the previous example is functionally equivalent to this:
two-lines = echo foo; echo $(bar)

72

GNU make

since two commands separated by semicolon behave much like two separate shell commands. However, note that using two separate lines means make will invoke the shell twice, running an independent sub-shell for each line. See Section 5.3 [Recipe Execution], page 46.
If you want variable definitions made with define to take precedence over command-line variable definitions, you can use the override directive together with define:
override define two-lines = foo $(bar) endef See Section 6.7 [The override Directive], page 70.
6.9 Undefining Variables
If you want to clear a variable, setting its value to empty is usually sufficient. Expanding such a variable will yield the same result (empty string) regardless of whether it was set or not. However, if you are using the flavor (see Section 8.11 [Flavor Function], page 100) and origin (see Section 8.10 [Origin Function], page 98) functions, there is a difference between a variable that was never set and a variable with an empty value. In such situations you may want to use the undefine directive to make a variable appear as if it was never set. For example:
foo := foo bar = bar
undefine foo undefine bar
$(info $(origin foo)) $(info $(flavor bar)) This example will print “undefined” for both variables. If you want to undefine a command-line variable definition, you can use the override directive together with undefine, similar to how this is done for variable definitions: override undefine CFLAGS
6.10 Variables from the Environment
Variables in make can come from the environment in which make is run. Every environment variable that make sees when it starts up is transformed into a make variable with the same name and value. However, an explicit assignment in the makefile, or with a command argument, overrides the environment. (If the ‘-e’ flag is specified, then values from the environment override assignments in the makefile. See Section 9.7 [Summary of Options], page 108. But this is not recommended practice.)
Thus, by setting the variable CFLAGS in your environment, you can cause all C compilations in most makefiles to use the compiler switches you prefer. This is safe for variables with standard or conventional meanings because you know that no makefile will use them for other things. (Note this is not totally reliable; some makefiles set CFLAGS explicitly and therefore are not affected by the value in the environment.)

Chapter 6: How to Use Variables

73

When make runs a recipe, variables defined in the makefile are placed into the environment of each shell. This allows you to pass values to sub-make invocations (see Section 5.7 [Recursive Use of make], page 53). By default, only variables that came from the environment or the command line are passed to recursive invocations. You can use the export directive to pass other variables. See Section 5.7.2 [Communicating Variables to a Submake], page 54, for full details.
Other use of variables from the environment is not recommended. It is not wise for makefiles to depend for their functioning on environment variables set up outside their control, since this would cause different users to get different results from the same makefile. This is against the whole purpose of most makefiles.
Such problems would be especially likely with the variable SHELL, which is normally present in the environment to specify the user’s choice of interactive shell. It would be very undesirable for this choice to affect make; so, make handles the SHELL environment variable in a special way; see Section 5.3.2 [Choosing the Shell], page 47.
6.11 Target-specific Variable Values
Variable values in make are usually global; that is, they are the same regardless of where they are evaluated (unless they’re reset, of course). One exception to that is automatic variables (see Section 10.5.3 [Automatic Variables], page 124).
The other exception is target-specific variable values. This feature allows you to define different values for the same variable, based on the target that make is currently building. As with automatic variables, these values are only available within the context of a target’s recipe (and in other target-specific assignments).
Set a target-specific variable value like this:
target ... : variable-assignment
Target-specific variable assignments can be prefixed with any or all of the special keywords export, override, or private; these apply their normal behavior to this instance of the variable only.
Multiple target values create a target-specific variable value for each member of the target list individually.
The variable-assignment can be any valid form of assignment; recursive (‘=’), simple (‘:=’ or ‘::=’), appending (‘+=’), or conditional (‘?=’). All variables that appear within the variable-assignment are evaluated within the context of the target: thus, any previouslydefined target-specific variable values will be in effect. Note that this variable is actually distinct from any “global” value: the two variables do not have to have the same flavor (recursive vs. simple).
Target-specific variables have the same priority as any other makefile variable. Variables provided on the command line (and in the environment if the ‘-e’ option is in force) will take precedence. Specifying the override directive will allow the target-specific variable value to be preferred.
There is one more special feature of target-specific variables: when you define a targetspecific variable that variable value is also in effect for all prerequisites of this target, and all their prerequisites, etc. (unless those prerequisites override that variable with their own target-specific variable value). So, for example, a statement like this:

74

GNU make

prog : CFLAGS = -g prog : prog.o foo.o bar.o will set CFLAGS to ‘-g’ in the recipe for prog, but it will also set CFLAGS to ‘-g’ in the recipes that create prog.o, foo.o, and bar.o, and any recipes which create their prerequisites. Be aware that a given prerequisite will only be built once per invocation of make, at most. If the same file is a prerequisite of multiple targets, and each of those targets has a different value for the same target-specific variable, then the first target to be built will cause that prerequisite to be built and the prerequisite will inherit the target-specific value from the first target. It will ignore the target-specific values from any other targets.
6.12 Pattern-specific Variable Values
In addition to target-specific variable values (see Section 6.11 [Target-specific Variable Values], page 73), GNU make supports pattern-specific variable values. In this form, the variable is defined for any target that matches the pattern specified.
Set a pattern-specific variable value like this: pattern ... : variable-assignment
where pattern is a %-pattern. As with target-specific variable values, multiple pattern values create a pattern-specific variable value for each pattern individually. The variableassignment can be any valid form of assignment. Any command line variable setting will take precedence, unless override is specified.
For example: %.o : CFLAGS = -O
will assign CFLAGS the value of ‘-O’ for all targets matching the pattern %.o. If a target matches more than one pattern, the matching pattern-specific variables with
longer stems are interpreted first. This results in more specific variables taking precedence over the more generic ones, for example:
%.o: %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
lib/%.o: CFLAGS := -fPIC -g %.o: CFLAGS := -g
all: foo.o lib/bar.o In this example the first definition of the CFLAGS variable will be used to update lib/bar.o even though the second one also applies to this target. Pattern-specific variables which result in the same stem length are considered in the order in which they were defined in the makefile. Pattern-specific variables are searched after any target-specific variables defined explicitly for that target, and before target-specific variables defined for the parent target.
6.13 Suppressing Inheritance
As described in previous sections, make variables are inherited by prerequisites. This capability allows you to modify the behavior of a prerequisite based on which targets caused it

Chapter 6: How to Use Variables

75

to be rebuilt. For example, you might set a target-specific variable on a debug target, then running ‘make debug’ will cause that variable to be inherited by all prerequisites of debug, while just running ‘make all’ (for example) would not have that assignment.
Sometimes, however, you may not want a variable to be inherited. For these situations, make provides the private modifier. Although this modifier can be used with any variable assignment, it makes the most sense with target- and pattern-specific variables. Any variable marked private will be visible to its local target but will not be inherited by prerequisites of that target. A global variable marked private will be visible in the global scope but will not be inherited by any target, and hence will not be visible in any recipe.
As an example, consider this makefile:
EXTRA_CFLAGS =

prog: private EXTRA_CFLAGS = -L/usr/local/lib prog: a.o b.o
Due to the private modifier, a.o and b.o will not inherit the EXTRA_CFLAGS variable assignment from the prog target.

6.14 Other Special Variables
GNU make supports some variables that have special properties.
MAKEFILE_LIST Contains the name of each makefile that is parsed by make, in the order in which it was parsed. The name is appended just before make begins to parse the makefile. Thus, if the first thing a makefile does is examine the last word in this variable, it will be the name of the current makefile. Once the current makefile has used include, however, the last word will be the just-included makefile.
If a makefile named Makefile has this content:
name1 := $(lastword $(MAKEFILE_LIST))

include inc.mk

name2 := $(lastword $(MAKEFILE_LIST))

all:

@echo name1 = $(name1) @echo name2 = $(name2)

then you would expect to see this output:

name1 = Makefile name2 = inc.mk

.DEFAULT_GOAL Sets the default goal to be used if no targets were specified on the command line (see Section 9.2 [Arguments to Specify the Goals], page 103). The .DEFAULT_ GOAL variable allows you to discover the current default goal, restart the default

76

GNU make

goal selection algorithm by clearing its value, or to explicitly set the default goal. The following example illustrates these cases:
# Query the default goal. ifeq ($(.DEFAULT_GOAL),)
$(warning no default goal is set) endif
.PHONY: foo foo: ; @echo $@
$(warning default goal is $(.DEFAULT_GOAL))
# Reset the default goal. .DEFAULT_GOAL :=
.PHONY: bar bar: ; @echo $@
$(warning default goal is $(.DEFAULT_GOAL))
# Set our own. .DEFAULT_GOAL := foo This makefile prints: no default goal is set default goal is foo default goal is bar foo Note that assigning more than one target name to .DEFAULT_GOAL is invalid and will result in an error.
MAKE_RESTARTS This variable is set only if this instance of make has restarted (see Section 3.5 [How Makefiles Are Remade], page 15): it will contain the number of times this instance has restarted. Note this is not the same as recursion (counted by the MAKELEVEL variable). You should not set, modify, or export this variable.
MAKE_TERMOUT MAKE_TERMERR
When make starts it will check whether stdout and stderr will show their output on a terminal. If so, it will set MAKE_TERMOUT and MAKE_TERMERR, respectively, to the name of the terminal device (or true if this cannot be determined). If set these variables will be marked for export. These variables will not be changed by make and they will not be modified if already set. These values can be used (particularly in combination with output synchronization (see Section 5.4.1 [Output During Parallel Execution], page 49) to determine whether make itself is writing to a terminal; they can be tested to decide whether to force recipe commands to generate colorized output for example.

Chapter 6: How to Use Variables

77

If you invoke a sub-make and redirect its stdout or stderr it is your responsibility to reset or unexport these variables as well, if your makefiles rely on them.
.RECIPEPREFIX The first character of the value of this variable is used as the character make assumes is introducing a recipe line. If the variable is empty (as it is by default) that character is the standard tab character. For example, this is a valid makefile:
.RECIPEPREFIX = > all: > @echo Hello, world The value of .RECIPEPREFIX can be changed multiple times; once set it stays in effect for all rules parsed until it is modified.
.VARIABLES Expands to a list of the names of all global variables defined so far. This includes variables which have empty values, as well as built-in variables (see Section 10.3 [Variables Used by Implicit Rules], page 119), but does not include any variables which are only defined in a target-specific context. Note that any value you assign to this variable will be ignored; it will always return its special value.
.FEATURES Expands to a list of special features supported by this version of make. Possible values include, but are not limited to:
‘archives’ Supports ar (archive) files using special file name syntax. See Chapter 11 [Using make to Update Archive Files], page 133.
‘check-symlink’ Supports the -L (--check-symlink-times) flag. See Section 9.7 [Summary of Options], page 108.
‘else-if’ Supports “else if” non-nested conditionals. See Section 7.2 [Syntax of Conditionals], page 82.
‘jobserver’ Supports “job server” enhanced parallel builds. See Section 5.4 [Parallel Execution], page 49.
‘oneshell’ Supports the .ONESHELL special target. See Section 5.3.1 [Using One Shell], page 46.
‘order-only’ Supports order-only prerequisites. See Section 4.2 [Types of Prerequisites], page 24.
‘second-expansion’ Supports secondary expansion of prerequisite lists.

78

GNU make

‘shortest-stem’ Uses the “shortest stem” method of choosing which pattern, of multiple applicable options, will be used. See Section 10.5.4 [How Patterns Match], page 126.

‘target-specific’ Supports target-specific and pattern-specific variable assignments. See Section 6.11 [Target-specific Variable Values], page 73.

‘undefine’ Supports the undefine directive. See Section 6.9 [Undefine Directive], page 72.

‘guile’

Has GNU Guile available as an embedded extension language. See Section 12.1 [GNU Guile Integration], page 137.

‘load’

Supports dynamically loadable objects for creating custom extensions. See Section 12.2 [Loading Dynamic Objects], page 139.

.INCLUDE_DIRS Expands to a list of directories that make searches for included makefiles (see Section 3.3 [Including Other Makefiles], page 13).

.EXTRA_PREREQS Each word in this variable is a new prerequisite which is added to targets for which it is set. These prerequisites differ from normal prerequisites in that they do not appear in any of the automatic variables (see Section 10.5.3 [Automatic Variables], page 124). This allows prerequisites to be defined which do not impact the recipe.
Consider a rule to link a program:
myprog: myprog.o file1.o file2.o $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LDLIBS)
Now suppose you want to enhance this makefile to ensure that updates to the compiler cause the program to be re-linked. You can add the compiler as a prerequisite, but you must ensure that it’s not passed as an argument to link command. You’ll need something like this:
myprog: myprog.o file1.o file2.o $(CC) $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(filter-out $(CC),$^) $(LDLIBS)
Then consider having multiple extra prerequisites: they would all have to be filtered out. Using .EXTRA_PREREQS and target-specific variables provides a simpler solution:
myprog: myprog.o file1.o file2.o $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LDLIBS)
myprog: .EXTRA_PREREQS = $(CC)
This feature can also be useful if you want to add prerequisites to a makefile you cannot easily modify: you can create a new file such as extra.mk:
myprog: .EXTRA_PREREQS = $(CC)
then invoke make -f extra.mk -f Makefile.

79
Setting .EXTRA_PREREQS globally will cause those prerequisites to be added to all targets (which did not themselves override it with a target-specific value). Note make is smart enough not to add a prerequisite listed in .EXTRA_PREREQS as a prerequisite to itself.

81
7 Conditional Parts of Makefiles
A conditional directive causes part of a makefile to be obeyed or ignored depending on the values of variables. Conditionals can compare the value of one variable to another, or the value of a variable to a constant string. Conditionals control what make actually “sees” in the makefile, so they cannot be used to control recipes at the time of execution.
7.1 Example of a Conditional
The following example of a conditional tells make to use one set of libraries if the CC variable is ‘gcc’, and a different set of libraries otherwise. It works by controlling which of two recipe lines will be used for the rule. The result is that ‘CC=gcc’ as an argument to make changes not only which compiler is used but also which libraries are linked.
libs_for_gcc = -lgnu normal_libs =
foo: $(objects) ifeq ($(CC),gcc)
$(CC) -o foo $(objects) $(libs_for_gcc) else
$(CC) -o foo $(objects) $(normal_libs) endif This conditional uses three directives: one ifeq, one else and one endif. The ifeq directive begins the conditional, and specifies the condition. It contains two arguments, separated by a comma and surrounded by parentheses. Variable substitution is performed on both arguments and then they are compared. The lines of the makefile following the ifeq are obeyed if the two arguments match; otherwise they are ignored. The else directive causes the following lines to be obeyed if the previous conditional failed. In the example above, this means that the second alternative linking command is used whenever the first alternative is not used. It is optional to have an else in a conditional. The endif directive ends the conditional. Every conditional must end with an endif. Unconditional makefile text follows. As this example illustrates, conditionals work at the textual level: the lines of the conditional are treated as part of the makefile, or ignored, according to the condition. This is why the larger syntactic units of the makefile, such as rules, may cross the beginning or the end of the conditional. When the variable CC has the value ‘gcc’, the above example has this effect: foo: $(objects)
$(CC) -o foo $(objects) $(libs_for_gcc) When the variable CC has any other value, the effect is this:
foo: $(objects) $(CC) -o foo $(objects) $(normal_libs)

82

GNU make

Equivalent results can be obtained in another way by conditionalizing a variable assignment and then using the variable unconditionally:
libs_for_gcc = -lgnu normal_libs =
ifeq ($(CC),gcc) libs=$(libs_for_gcc)
else libs=$(normal_libs)
endif
foo: $(objects) $(CC) -o foo $(objects) $(libs)
7.2 Syntax of Conditionals
The syntax of a simple conditional with no else is as follows:
conditional-directive text-if-true endif
The text-if-true may be any lines of text, to be considered as part of the makefile if the condition is true. If the condition is false, no text is used instead.
The syntax of a complex conditional is as follows:
conditional-directive text-if-true else text-if-false endif
or:
conditional-directive-one text-if-one-is-true else conditional-directive-two text-if-two-is-true else text-if-one-and-two-are-false endif
There can be as many “else conditional-directive” clauses as necessary. Once a given condition is true, text-if-true is used and no other clause is used; if no condition is true then text-if-false is used. The text-if-true and text-if-false can be any number of lines of text.
The syntax of the conditional-directive is the same whether the conditional is simple or complex; after an else or not. There are four different directives that test different conditions. Here is a table of them:

Chapter 7: Conditional Parts of Makefiles

83

ifeq (arg1, arg2) ifeq ’arg1’ ’arg2’ ifeq "arg1" "arg2" ifeq "arg1" ’arg2’ ifeq ’arg1’ "arg2"
Expand all variable references in arg1 and arg2 and compare them. If they are identical, the text-if-true is effective; otherwise, the text-if-false, if any, is effective.
Often you want to test if a variable has a non-empty value. When the value results from complex expansions of variables and functions, expansions you would consider empty may actually contain whitespace characters and thus are not seen as empty. However, you can use the strip function (see Section 8.2 [Text Functions], page 88) to avoid interpreting whitespace as a non-empty value. For example:
ifeq ($(strip $(foo)),) text-if-empty endif
will evaluate text-if-empty even if the expansion of $(foo) contains whitespace characters.
ifneq (arg1, arg2) ifneq ’arg1’ ’arg2’ ifneq "arg1" "arg2" ifneq "arg1" ’arg2’ ifneq ’arg1’ "arg2"
Expand all variable references in arg1 and arg2 and compare them. If they are different, the text-if-true is effective; otherwise, the text-if-false, if any, is effective.
ifdef variable-name The ifdef form takes the name of a variable as its argument, not a reference to a variable. If the value of that variable has a non-empty value, the text-if-true is effective; otherwise, the text-if-false, if any, is effective. Variables that have never been defined have an empty value. The text variable-name is expanded, so it could be a variable or function that expands to the name of a variable. For example:
bar = true foo = bar ifdef $(foo) frobozz = yes endif
The variable reference $(foo) is expanded, yielding bar, which is considered to be the name of a variable. The variable bar is not expanded, but its value is examined to determine if it is non-empty.
Note that ifdef only tests whether a variable has a value. It does not expand the variable to see if that value is nonempty. Consequently, tests using ifdef

84

GNU make

return true for all definitions except those like foo =. To test for an empty value, use ifeq ($(foo),). For example,
bar = foo = $(bar) ifdef foo frobozz = yes else frobozz = no endif sets ‘frobozz’ to ‘yes’, while:
foo = ifdef foo frobozz = yes else frobozz = no endif sets ‘frobozz’ to ‘no’.
ifndef variable-name If the variable variable-name has an empty value, the text-if-true is effective; otherwise, the text-if-false, if any, is effective. The rules for expansion and testing of variable-name are identical to the ifdef directive.
Extra spaces are allowed and ignored at the beginning of the conditional directive line, but a tab is not allowed. (If the line begins with a tab, it will be considered part of a recipe for a rule.) Aside from this, extra spaces or tabs may be inserted with no effect anywhere except within the directive name or within an argument. A comment starting with ‘#’ may appear at the end of the line.
The other two directives that play a part in a conditional are else and endif. Each of these directives is written as one word, with no arguments. Extra spaces are allowed and ignored at the beginning of the line, and spaces or tabs at the end. A comment starting with ‘#’ may appear at the end of the line.
Conditionals affect which lines of the makefile make uses. If the condition is true, make reads the lines of the text-if-true as part of the makefile; if the condition is false, make ignores those lines completely. It follows that syntactic units of the makefile, such as rules, may safely be split across the beginning or the end of the conditional.
make evaluates conditionals when it reads a makefile. Consequently, you cannot use automatic variables in the tests of conditionals because they are not defined until recipes are run (see Section 10.5.3 [Automatic Variables], page 124).
To prevent intolerable confusion, it is not permitted to start a conditional in one makefile and end it in another. However, you may write an include directive within a conditional, provided you do not attempt to terminate the conditional inside the included file.
7.3 Conditionals that Test Flags
You can write a conditional that tests make command flags such as ‘-t’ by using the variable MAKEFLAGS together with the findstring function (see Section 8.2 [Functions for String

Chapter 7: Conditional Parts of Makefiles

85

Substitution and Analysis], page 88). This is useful when touch is not enough to make a file appear up to date.
The findstring function determines whether one string appears as a substring of another. If you want to test for the ‘-t’ flag, use ‘t’ as the first string and the value of MAKEFLAGS as the other.
For example, here is how to arrange to use ‘ranlib -t’ to finish marking an archive file up to date:
archive.a: ... ifneq (,$(findstring t,$(MAKEFLAGS)))
+touch archive.a +ranlib -t archive.a else ranlib archive.a endif
The ‘+’ prefix marks those recipe lines as “recursive” so that they will be executed despite use of the ‘-t’ flag. See Section 5.7 [Recursive Use of make], page 53.

87
8 Functions for Transforming Text
Functions allow you to do text processing in the makefile to compute the files to operate on or the commands to use in recipes. You use a function in a function call, where you give the name of the function and some text (the arguments) for the function to operate on. The result of the function’s processing is substituted into the makefile at the point of the call, just as a variable might be substituted.
8.1 Function Call Syntax
A function call resembles a variable reference. It can appear anywhere a variable reference can appear, and it is expanded using the same rules as variable references. A function call looks like this:
$(function arguments)
or like this:
${function arguments}
Here function is a function name; one of a short list of names that are part of make. You can also essentially create your own functions by using the call built-in function.
The arguments are the arguments of the function. They are separated from the function name by one or more spaces or tabs, and if there is more than one argument, then they are separated by commas. Such whitespace and commas are not part of an argument’s value. The delimiters which you use to surround the function call, whether parentheses or braces, can appear in an argument only in matching pairs; the other kind of delimiters may appear singly. If the arguments themselves contain other function calls or variable references, it is wisest to use the same kind of delimiters for all the references; write ‘$(subst a,b,$(x))’, not ‘$(subst a,b,${x})’. This is because it is clearer, and because only one type of delimiter is matched to find the end of the reference.
The text written for each argument is processed by substitution of variables and function calls to produce the argument value, which is the text on which the function acts. The substitution is done in the order in which the arguments appear.
Commas and unmatched parentheses or braces cannot appear in the text of an argument as written; leading spaces cannot appear in the text of the first argument as written. These characters can be put into the argument value by variable substitution. First define variables comma and space whose values are isolated comma and space characters, then substitute these variables where such characters are wanted, like this:
comma:= , empty:= space:= $(empty) $(empty) foo:= a b c bar:= $(subst $(space),$(comma),$(foo)) # bar is now ‘a,b,c’.
Here the subst function replaces each space with a comma, through the value of foo, and substitutes the result.

88

GNU make

8.2 Functions for String Substitution and Analysis
Here are some functions that operate on strings:
$(subst from,to,text) Performs a textual replacement on the text text: each occurrence of from is replaced by to. The result is substituted for the function call. For example,
$(subst ee,EE,feet on the street) produces the value ‘fEEt on the strEEt’.
$(patsubst pattern,replacement,text) Finds whitespace-separated words in text that match pattern and replaces them with replacement. Here pattern may contain a ‘%’ which acts as a wildcard, matching any number of any characters within a word. If replacement also contains a ‘%’, the ‘%’ is replaced by the text that matched the ‘%’ in pattern. Only the first ‘%’ in the pattern and replacement is treated this way; any subsequent ‘%’ is unchanged. ‘%’ characters in patsubst function invocations can be quoted with preceding backslashes (‘\’). Backslashes that would otherwise quote ‘%’ characters can be quoted with more backslashes. Backslashes that quote ‘%’ characters or other backslashes are removed from the pattern before it is compared file names or has a stem substituted into it. Backslashes that are not in danger of quoting ‘%’ characters go unmolested. For example, the pattern the\%weird\\%pattern\\ has ‘the%weird\’ preceding the operative ‘%’ character, and ‘pattern\\’ following it. The final two backslashes are left alone because they cannot affect any ‘%’ character. Whitespace between words is folded into single space characters; leading and trailing whitespace is discarded. For example,
$(patsubst %.c,%.o,x.c.c bar.c) produces the value ‘x.c.o bar.o’. Substitution references (see Section 6.3.1 [Substitution References], page 64) are a simpler way to get the effect of the patsubst function:
$(var:pattern=replacement) is equivalent to
$(patsubst pattern,replacement,$(var)) The second shorthand simplifies one of the most common uses of patsubst: replacing the suffix at the end of file names.
$(var:suffix=replacement) is equivalent to
$(patsubst %suffix,%replacement,$(var)) For example, you might have a list of object files:
objects = foo.o bar.o baz.o To get the list of corresponding source files, you could simply write:
$(objects:.o=.c)

